/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fpravbala%2FDocuments%2FCoding%2FCursor-Songless%2Fsrc%2Fapp%2Fpage.tsx&server=false!":
/*!*************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fpravbala%2FDocuments%2FCoding%2FCursor-Songless%2Fsrc%2Fapp%2Fpage.tsx&server=false! ***!
  \*************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/page.tsx */ \"(app-pages-browser)/./src/app/page.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lMkZVc2VycyUyRnByYXZiYWxhJTJGRG9jdW1lbnRzJTJGQ29kaW5nJTJGQ3Vyc29yLVNvbmdsZXNzJTJGc3JjJTJGYXBwJTJGcGFnZS50c3gmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzhlMzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvcHJhdmJhbGEvRG9jdW1lbnRzL0NvZGluZy9DdXJzb3ItU29uZ2xlc3Mvc3JjL2FwcC9wYWdlLnRzeFwiKSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fpravbala%2FDocuments%2FCoding%2FCursor-Songless%2Fsrc%2Fapp%2Fpage.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/howler/dist/howler.js":
/*!********************************************!*\
  !*** ./node_modules/howler/dist/howler.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n *  howler.js v2.2.4\n *  howlerjs.com\n *\n *  (c) 2013-2020, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */ (function() {\n    \"use strict\";\n    /** Global Methods **/ /***************************************************************************/ /**\n   * Create the global controller. All contained methods and properties apply\n   * to all sounds that are currently playing or will be in the future.\n   */ var HowlerGlobal1 = function() {\n        this.init();\n    };\n    HowlerGlobal1.prototype = {\n        /**\n     * Initialize the global Howler object.\n     * @return {Howler}\n     */ init: function() {\n            var self = this || Howler1;\n            // Create a global ID counter.\n            self._counter = 1000;\n            // Pool of unlocked HTML5 Audio objects.\n            self._html5AudioPool = [];\n            self.html5PoolSize = 10;\n            // Internal properties.\n            self._codecs = {};\n            self._howls = [];\n            self._muted = false;\n            self._volume = 1;\n            self._canPlayEvent = \"canplaythrough\";\n            self._navigator =  true && window.navigator ? window.navigator : null;\n            // Public properties.\n            self.masterGain = null;\n            self.noAudio = false;\n            self.usingWebAudio = true;\n            self.autoSuspend = true;\n            self.ctx = null;\n            // Set to false to disable the auto audio unlocker.\n            self.autoUnlock = true;\n            // Setup the various state values for global tracking.\n            self._setup();\n            return self;\n        },\n        /**\n     * Get/set the global volume for all sounds.\n     * @param  {Float} vol Volume from 0.0 to 1.0.\n     * @return {Howler/Float}     Returns self or current volume.\n     */ volume: function(vol) {\n            var self = this || Howler1;\n            vol = parseFloat(vol);\n            // If we don't have an AudioContext created yet, run the setup.\n            if (!self.ctx) {\n                setupAudioContext();\n            }\n            if (typeof vol !== \"undefined\" && vol >= 0 && vol <= 1) {\n                self._volume = vol;\n                // Don't update any of the nodes if we are muted.\n                if (self._muted) {\n                    return self;\n                }\n                // When using Web Audio, we just need to adjust the master gain.\n                if (self.usingWebAudio) {\n                    self.masterGain.gain.setValueAtTime(vol, Howler1.ctx.currentTime);\n                }\n                // Loop through and change volume for all HTML5 audio nodes.\n                for(var i = 0; i < self._howls.length; i++){\n                    if (!self._howls[i]._webAudio) {\n                        // Get all of the sounds in this Howl group.\n                        var ids = self._howls[i]._getSoundIds();\n                        // Loop through all sounds and change the volumes.\n                        for(var j = 0; j < ids.length; j++){\n                            var sound = self._howls[i]._soundById(ids[j]);\n                            if (sound && sound._node) {\n                                sound._node.volume = sound._volume * vol;\n                            }\n                        }\n                    }\n                }\n                return self;\n            }\n            return self._volume;\n        },\n        /**\n     * Handle muting and unmuting globally.\n     * @param  {Boolean} muted Is muted or not.\n     */ mute: function(muted) {\n            var self = this || Howler1;\n            // If we don't have an AudioContext created yet, run the setup.\n            if (!self.ctx) {\n                setupAudioContext();\n            }\n            self._muted = muted;\n            // With Web Audio, we just need to mute the master gain.\n            if (self.usingWebAudio) {\n                self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler1.ctx.currentTime);\n            }\n            // Loop through and mute all HTML5 Audio nodes.\n            for(var i = 0; i < self._howls.length; i++){\n                if (!self._howls[i]._webAudio) {\n                    // Get all of the sounds in this Howl group.\n                    var ids = self._howls[i]._getSoundIds();\n                    // Loop through all sounds and mark the audio node as muted.\n                    for(var j = 0; j < ids.length; j++){\n                        var sound = self._howls[i]._soundById(ids[j]);\n                        if (sound && sound._node) {\n                            sound._node.muted = muted ? true : sound._muted;\n                        }\n                    }\n                }\n            }\n            return self;\n        },\n        /**\n     * Handle stopping all sounds globally.\n     */ stop: function() {\n            var self = this || Howler1;\n            // Loop through all Howls and stop them.\n            for(var i = 0; i < self._howls.length; i++){\n                self._howls[i].stop();\n            }\n            return self;\n        },\n        /**\n     * Unload and destroy all currently loaded Howl objects.\n     * @return {Howler}\n     */ unload: function() {\n            var self = this || Howler1;\n            for(var i = self._howls.length - 1; i >= 0; i--){\n                self._howls[i].unload();\n            }\n            // Create a new AudioContext to make sure it is fully reset.\n            if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== \"undefined\") {\n                self.ctx.close();\n                self.ctx = null;\n                setupAudioContext();\n            }\n            return self;\n        },\n        /**\n     * Check for codec support of specific extension.\n     * @param  {String} ext Audio file extention.\n     * @return {Boolean}\n     */ codecs: function(ext) {\n            return (this || Howler1)._codecs[ext.replace(/^x-/, \"\")];\n        },\n        /**\n     * Setup various state values for global tracking.\n     * @return {Howler}\n     */ _setup: function() {\n            var self = this || Howler1;\n            // Keeps track of the suspend/resume state of the AudioContext.\n            self.state = self.ctx ? self.ctx.state || \"suspended\" : \"suspended\";\n            // Automatically begin the 30-second suspend process\n            self._autoSuspend();\n            // Check if audio is available.\n            if (!self.usingWebAudio) {\n                // No audio is available on this system if noAudio is set to true.\n                if (typeof Audio !== \"undefined\") {\n                    try {\n                        var test = new Audio();\n                        // Check if the canplaythrough event is available.\n                        if (typeof test.oncanplaythrough === \"undefined\") {\n                            self._canPlayEvent = \"canplay\";\n                        }\n                    } catch (e) {\n                        self.noAudio = true;\n                    }\n                } else {\n                    self.noAudio = true;\n                }\n            }\n            // Test to make sure audio isn't disabled in Internet Explorer.\n            try {\n                var test = new Audio();\n                if (test.muted) {\n                    self.noAudio = true;\n                }\n            } catch (e) {}\n            // Check for supported codecs.\n            if (!self.noAudio) {\n                self._setupCodecs();\n            }\n            return self;\n        },\n        /**\n     * Check for browser support for various codecs and cache the results.\n     * @return {Howler}\n     */ _setupCodecs: function() {\n            var self = this || Howler1;\n            var audioTest = null;\n            // Must wrap in a try/catch because IE11 in server mode throws an error.\n            try {\n                audioTest = typeof Audio !== \"undefined\" ? new Audio() : null;\n            } catch (err) {\n                return self;\n            }\n            if (!audioTest || typeof audioTest.canPlayType !== \"function\") {\n                return self;\n            }\n            var mpegTest = audioTest.canPlayType(\"audio/mpeg;\").replace(/^no$/, \"\");\n            // Opera version <33 has mixed MP3 support, so we need to check for and block it.\n            var ua = self._navigator ? self._navigator.userAgent : \"\";\n            var checkOpera = ua.match(/OPR\\/(\\d+)/g);\n            var isOldOpera = checkOpera && parseInt(checkOpera[0].split(\"/\")[1], 10) < 33;\n            var checkSafari = ua.indexOf(\"Safari\") !== -1 && ua.indexOf(\"Chrome\") === -1;\n            var safariVersion = ua.match(/Version\\/(.*?) /);\n            var isOldSafari = checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15;\n            self._codecs = {\n                mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType(\"audio/mp3;\").replace(/^no$/, \"\"))),\n                mpeg: !!mpegTest,\n                opus: !!audioTest.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/, \"\"),\n                ogg: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, \"\"),\n                oga: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, \"\"),\n                wav: !!(audioTest.canPlayType('audio/wav; codecs=\"1\"') || audioTest.canPlayType(\"audio/wav\")).replace(/^no$/, \"\"),\n                aac: !!audioTest.canPlayType(\"audio/aac;\").replace(/^no$/, \"\"),\n                caf: !!audioTest.canPlayType(\"audio/x-caf;\").replace(/^no$/, \"\"),\n                m4a: !!(audioTest.canPlayType(\"audio/x-m4a;\") || audioTest.canPlayType(\"audio/m4a;\") || audioTest.canPlayType(\"audio/aac;\")).replace(/^no$/, \"\"),\n                m4b: !!(audioTest.canPlayType(\"audio/x-m4b;\") || audioTest.canPlayType(\"audio/m4b;\") || audioTest.canPlayType(\"audio/aac;\")).replace(/^no$/, \"\"),\n                mp4: !!(audioTest.canPlayType(\"audio/x-mp4;\") || audioTest.canPlayType(\"audio/mp4;\") || audioTest.canPlayType(\"audio/aac;\")).replace(/^no$/, \"\"),\n                weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, \"\")),\n                webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, \"\")),\n                dolby: !!audioTest.canPlayType('audio/mp4; codecs=\"ec-3\"').replace(/^no$/, \"\"),\n                flac: !!(audioTest.canPlayType(\"audio/x-flac;\") || audioTest.canPlayType(\"audio/flac;\")).replace(/^no$/, \"\")\n            };\n            return self;\n        },\n        /**\n     * Some browsers/devices will only allow audio to be played after a user interaction.\n     * Attempt to automatically unlock audio on the first user interaction.\n     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/\n     * @return {Howler}\n     */ _unlockAudio: function() {\n            var self = this || Howler1;\n            // Only run this if Web Audio is supported and it hasn't already been unlocked.\n            if (self._audioUnlocked || !self.ctx) {\n                return;\n            }\n            self._audioUnlocked = false;\n            self.autoUnlock = false;\n            // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.\n            // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.\n            // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.\n            if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {\n                self._mobileUnloaded = true;\n                self.unload();\n            }\n            // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:\n            // http://stackoverflow.com/questions/24119684\n            self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);\n            // Call this method on touch start to create and play a buffer,\n            // then check if the audio actually played to determine if\n            // audio has now been unlocked on iOS, Android, etc.\n            var unlock = function(e) {\n                // Create a pool of unlocked HTML5 Audio objects that can\n                // be used for playing sounds without user interaction. HTML5\n                // Audio objects must be individually unlocked, as opposed\n                // to the WebAudio API which only needs a single activation.\n                // This must occur before WebAudio setup or the source.onended\n                // event will not fire.\n                while(self._html5AudioPool.length < self.html5PoolSize){\n                    try {\n                        var audioNode = new Audio();\n                        // Mark this Audio object as unlocked to ensure it can get returned\n                        // to the unlocked pool when released.\n                        audioNode._unlocked = true;\n                        // Add the audio node to the pool.\n                        self._releaseHtml5Audio(audioNode);\n                    } catch (e) {\n                        self.noAudio = true;\n                        break;\n                    }\n                }\n                // Loop through any assigned audio nodes and unlock them.\n                for(var i = 0; i < self._howls.length; i++){\n                    if (!self._howls[i]._webAudio) {\n                        // Get all of the sounds in this Howl group.\n                        var ids = self._howls[i]._getSoundIds();\n                        // Loop through all sounds and unlock the audio nodes.\n                        for(var j = 0; j < ids.length; j++){\n                            var sound = self._howls[i]._soundById(ids[j]);\n                            if (sound && sound._node && !sound._node._unlocked) {\n                                sound._node._unlocked = true;\n                                sound._node.load();\n                            }\n                        }\n                    }\n                }\n                // Fix Android can not play in suspend state.\n                self._autoResume();\n                // Create an empty buffer.\n                var source = self.ctx.createBufferSource();\n                source.buffer = self._scratchBuffer;\n                source.connect(self.ctx.destination);\n                // Play the empty buffer.\n                if (typeof source.start === \"undefined\") {\n                    source.noteOn(0);\n                } else {\n                    source.start(0);\n                }\n                // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.\n                if (typeof self.ctx.resume === \"function\") {\n                    self.ctx.resume();\n                }\n                // Setup a timeout to check that we are unlocked on the next event loop.\n                source.onended = function() {\n                    source.disconnect(0);\n                    // Update the unlocked state and prevent this check from happening again.\n                    self._audioUnlocked = true;\n                    // Remove the touch start listener.\n                    document.removeEventListener(\"touchstart\", unlock, true);\n                    document.removeEventListener(\"touchend\", unlock, true);\n                    document.removeEventListener(\"click\", unlock, true);\n                    document.removeEventListener(\"keydown\", unlock, true);\n                    // Let all sounds know that audio has been unlocked.\n                    for(var i = 0; i < self._howls.length; i++){\n                        self._howls[i]._emit(\"unlock\");\n                    }\n                };\n            };\n            // Setup a touch start listener to attempt an unlock in.\n            document.addEventListener(\"touchstart\", unlock, true);\n            document.addEventListener(\"touchend\", unlock, true);\n            document.addEventListener(\"click\", unlock, true);\n            document.addEventListener(\"keydown\", unlock, true);\n            return self;\n        },\n        /**\n     * Get an unlocked HTML5 Audio object from the pool. If none are left,\n     * return a new Audio object and throw a warning.\n     * @return {Audio} HTML5 Audio object.\n     */ _obtainHtml5Audio: function() {\n            var self = this || Howler1;\n            // Return the next object from the pool if one exists.\n            if (self._html5AudioPool.length) {\n                return self._html5AudioPool.pop();\n            }\n            //.Check if the audio is locked and throw a warning.\n            var testPlay = new Audio().play();\n            if (testPlay && typeof Promise !== \"undefined\" && (testPlay instanceof Promise || typeof testPlay.then === \"function\")) {\n                testPlay.catch(function() {\n                    console.warn(\"HTML5 Audio pool exhausted, returning potentially locked audio object.\");\n                });\n            }\n            return new Audio();\n        },\n        /**\n     * Return an activated HTML5 Audio object to the pool.\n     * @return {Howler}\n     */ _releaseHtml5Audio: function(audio) {\n            var self = this || Howler1;\n            // Don't add audio to the pool if we don't know if it has been unlocked.\n            if (audio._unlocked) {\n                self._html5AudioPool.push(audio);\n            }\n            return self;\n        },\n        /**\n     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.\n     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.\n     * @return {Howler}\n     */ _autoSuspend: function() {\n            var self = this;\n            if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === \"undefined\" || !Howler1.usingWebAudio) {\n                return;\n            }\n            // Check if any sounds are playing.\n            for(var i = 0; i < self._howls.length; i++){\n                if (self._howls[i]._webAudio) {\n                    for(var j = 0; j < self._howls[i]._sounds.length; j++){\n                        if (!self._howls[i]._sounds[j]._paused) {\n                            return self;\n                        }\n                    }\n                }\n            }\n            if (self._suspendTimer) {\n                clearTimeout(self._suspendTimer);\n            }\n            // If no sound has played after 30 seconds, suspend the context.\n            self._suspendTimer = setTimeout(function() {\n                if (!self.autoSuspend) {\n                    return;\n                }\n                self._suspendTimer = null;\n                self.state = \"suspending\";\n                // Handle updating the state of the audio context after suspending.\n                var handleSuspension = function() {\n                    self.state = \"suspended\";\n                    if (self._resumeAfterSuspend) {\n                        delete self._resumeAfterSuspend;\n                        self._autoResume();\n                    }\n                };\n                // Either the state gets suspended or it is interrupted.\n                // Either way, we need to update the state to suspended.\n                self.ctx.suspend().then(handleSuspension, handleSuspension);\n            }, 30000);\n            return self;\n        },\n        /**\n     * Automatically resume the Web Audio AudioContext when a new sound is played.\n     * @return {Howler}\n     */ _autoResume: function() {\n            var self = this;\n            if (!self.ctx || typeof self.ctx.resume === \"undefined\" || !Howler1.usingWebAudio) {\n                return;\n            }\n            if (self.state === \"running\" && self.ctx.state !== \"interrupted\" && self._suspendTimer) {\n                clearTimeout(self._suspendTimer);\n                self._suspendTimer = null;\n            } else if (self.state === \"suspended\" || self.state === \"running\" && self.ctx.state === \"interrupted\") {\n                self.ctx.resume().then(function() {\n                    self.state = \"running\";\n                    // Emit to all Howls that the audio has resumed.\n                    for(var i = 0; i < self._howls.length; i++){\n                        self._howls[i]._emit(\"resume\");\n                    }\n                });\n                if (self._suspendTimer) {\n                    clearTimeout(self._suspendTimer);\n                    self._suspendTimer = null;\n                }\n            } else if (self.state === \"suspending\") {\n                self._resumeAfterSuspend = true;\n            }\n            return self;\n        }\n    };\n    // Setup the global audio controller.\n    var Howler1 = new HowlerGlobal1();\n    /** Group Methods **/ /***************************************************************************/ /**\n   * Create an audio group controller.\n   * @param {Object} o Passed in properties for this group.\n   */ var Howl1 = function(o) {\n        var self = this;\n        // Throw an error if no source is provided.\n        if (!o.src || o.src.length === 0) {\n            console.error(\"An array of source files must be passed with any new Howl.\");\n            return;\n        }\n        self.init(o);\n    };\n    Howl1.prototype = {\n        /**\n     * Initialize a new Howl group object.\n     * @param  {Object} o Passed in properties for this group.\n     * @return {Howl}\n     */ init: function(o) {\n            var self = this;\n            // If we don't have an AudioContext created yet, run the setup.\n            if (!Howler1.ctx) {\n                setupAudioContext();\n            }\n            // Setup user-defined default properties.\n            self._autoplay = o.autoplay || false;\n            self._format = typeof o.format !== \"string\" ? o.format : [\n                o.format\n            ];\n            self._html5 = o.html5 || false;\n            self._muted = o.mute || false;\n            self._loop = o.loop || false;\n            self._pool = o.pool || 5;\n            self._preload = typeof o.preload === \"boolean\" || o.preload === \"metadata\" ? o.preload : true;\n            self._rate = o.rate || 1;\n            self._sprite = o.sprite || {};\n            self._src = typeof o.src !== \"string\" ? o.src : [\n                o.src\n            ];\n            self._volume = o.volume !== undefined ? o.volume : 1;\n            self._xhr = {\n                method: o.xhr && o.xhr.method ? o.xhr.method : \"GET\",\n                headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,\n                withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false\n            };\n            // Setup all other default properties.\n            self._duration = 0;\n            self._state = \"unloaded\";\n            self._sounds = [];\n            self._endTimers = {};\n            self._queue = [];\n            self._playLock = false;\n            // Setup event listeners.\n            self._onend = o.onend ? [\n                {\n                    fn: o.onend\n                }\n            ] : [];\n            self._onfade = o.onfade ? [\n                {\n                    fn: o.onfade\n                }\n            ] : [];\n            self._onload = o.onload ? [\n                {\n                    fn: o.onload\n                }\n            ] : [];\n            self._onloaderror = o.onloaderror ? [\n                {\n                    fn: o.onloaderror\n                }\n            ] : [];\n            self._onplayerror = o.onplayerror ? [\n                {\n                    fn: o.onplayerror\n                }\n            ] : [];\n            self._onpause = o.onpause ? [\n                {\n                    fn: o.onpause\n                }\n            ] : [];\n            self._onplay = o.onplay ? [\n                {\n                    fn: o.onplay\n                }\n            ] : [];\n            self._onstop = o.onstop ? [\n                {\n                    fn: o.onstop\n                }\n            ] : [];\n            self._onmute = o.onmute ? [\n                {\n                    fn: o.onmute\n                }\n            ] : [];\n            self._onvolume = o.onvolume ? [\n                {\n                    fn: o.onvolume\n                }\n            ] : [];\n            self._onrate = o.onrate ? [\n                {\n                    fn: o.onrate\n                }\n            ] : [];\n            self._onseek = o.onseek ? [\n                {\n                    fn: o.onseek\n                }\n            ] : [];\n            self._onunlock = o.onunlock ? [\n                {\n                    fn: o.onunlock\n                }\n            ] : [];\n            self._onresume = [];\n            // Web Audio or HTML5 Audio?\n            self._webAudio = Howler1.usingWebAudio && !self._html5;\n            // Automatically try to enable audio.\n            if (typeof Howler1.ctx !== \"undefined\" && Howler1.ctx && Howler1.autoUnlock) {\n                Howler1._unlockAudio();\n            }\n            // Keep track of this Howl group in the global controller.\n            Howler1._howls.push(self);\n            // If they selected autoplay, add a play event to the load queue.\n            if (self._autoplay) {\n                self._queue.push({\n                    event: \"play\",\n                    action: function() {\n                        self.play();\n                    }\n                });\n            }\n            // Load the source file unless otherwise specified.\n            if (self._preload && self._preload !== \"none\") {\n                self.load();\n            }\n            return self;\n        },\n        /**\n     * Load the audio file.\n     * @return {Howler}\n     */ load: function() {\n            var self = this;\n            var url = null;\n            // If no audio is available, quit immediately.\n            if (Howler1.noAudio) {\n                self._emit(\"loaderror\", null, \"No audio support.\");\n                return;\n            }\n            // Make sure our source is in an array.\n            if (typeof self._src === \"string\") {\n                self._src = [\n                    self._src\n                ];\n            }\n            // Loop through the sources and pick the first one that is compatible.\n            for(var i = 0; i < self._src.length; i++){\n                var ext, str;\n                if (self._format && self._format[i]) {\n                    // If an extension was specified, use that instead.\n                    ext = self._format[i];\n                } else {\n                    // Make sure the source is a string.\n                    str = self._src[i];\n                    if (typeof str !== \"string\") {\n                        self._emit(\"loaderror\", null, \"Non-string found in selected audio sources - ignoring.\");\n                        continue;\n                    }\n                    // Extract the file extension from the URL or base64 data URI.\n                    ext = /^data:audio\\/([^;,]+);/i.exec(str);\n                    if (!ext) {\n                        ext = /\\.([^.]+)$/.exec(str.split(\"?\", 1)[0]);\n                    }\n                    if (ext) {\n                        ext = ext[1].toLowerCase();\n                    }\n                }\n                // Log a warning if no extension was found.\n                if (!ext) {\n                    console.warn('No file extension was found. Consider using the \"format\" property or specify an extension.');\n                }\n                // Check if this extension is available.\n                if (ext && Howler1.codecs(ext)) {\n                    url = self._src[i];\n                    break;\n                }\n            }\n            if (!url) {\n                self._emit(\"loaderror\", null, \"No codec support for selected audio sources.\");\n                return;\n            }\n            self._src = url;\n            self._state = \"loading\";\n            // If the hosting page is HTTPS and the source isn't,\n            // drop down to HTML5 Audio to avoid Mixed Content errors.\n            if (window.location.protocol === \"https:\" && url.slice(0, 5) === \"http:\") {\n                self._html5 = true;\n                self._webAudio = false;\n            }\n            // Create a new sound object and add it to the pool.\n            new Sound1(self);\n            // Load and decode the audio data for playback.\n            if (self._webAudio) {\n                loadBuffer(self);\n            }\n            return self;\n        },\n        /**\n     * Play a sound or resume previous playback.\n     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.\n     * @param  {Boolean} internal Internal Use: true prevents event firing.\n     * @return {Number}          Sound ID.\n     */ play: function(sprite, internal) {\n            var self = this;\n            var id = null;\n            // Determine if a sprite, sound id or nothing was passed\n            if (typeof sprite === \"number\") {\n                id = sprite;\n                sprite = null;\n            } else if (typeof sprite === \"string\" && self._state === \"loaded\" && !self._sprite[sprite]) {\n                // If the passed sprite doesn't exist, do nothing.\n                return null;\n            } else if (typeof sprite === \"undefined\") {\n                // Use the default sound sprite (plays the full audio length).\n                sprite = \"__default\";\n                // Check if there is a single paused sound that isn't ended.\n                // If there is, play that sound. If not, continue as usual.\n                if (!self._playLock) {\n                    var num = 0;\n                    for(var i = 0; i < self._sounds.length; i++){\n                        if (self._sounds[i]._paused && !self._sounds[i]._ended) {\n                            num++;\n                            id = self._sounds[i]._id;\n                        }\n                    }\n                    if (num === 1) {\n                        sprite = null;\n                    } else {\n                        id = null;\n                    }\n                }\n            }\n            // Get the selected node, or get one from the pool.\n            var sound = id ? self._soundById(id) : self._inactiveSound();\n            // If the sound doesn't exist, do nothing.\n            if (!sound) {\n                return null;\n            }\n            // Select the sprite definition.\n            if (id && !sprite) {\n                sprite = sound._sprite || \"__default\";\n            }\n            // If the sound hasn't loaded, we must wait to get the audio's duration.\n            // We also need to wait to make sure we don't run into race conditions with\n            // the order of function calls.\n            if (self._state !== \"loaded\") {\n                // Set the sprite value on this sound.\n                sound._sprite = sprite;\n                // Mark this sound as not ended in case another sound is played before this one loads.\n                sound._ended = false;\n                // Add the sound to the queue to be played on load.\n                var soundId = sound._id;\n                self._queue.push({\n                    event: \"play\",\n                    action: function() {\n                        self.play(soundId);\n                    }\n                });\n                return soundId;\n            }\n            // Don't play the sound if an id was passed and it is already playing.\n            if (id && !sound._paused) {\n                // Trigger the play event, in order to keep iterating through queue.\n                if (!internal) {\n                    self._loadQueue(\"play\");\n                }\n                return sound._id;\n            }\n            // Make sure the AudioContext isn't suspended, and resume it if it is.\n            if (self._webAudio) {\n                Howler1._autoResume();\n            }\n            // Determine how long to play for and where to start playing.\n            var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);\n            var duration = Math.max(0, (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000 - seek);\n            var timeout = duration * 1000 / Math.abs(sound._rate);\n            var start = self._sprite[sprite][0] / 1000;\n            var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;\n            sound._sprite = sprite;\n            // Mark the sound as ended instantly so that this async playback\n            // doesn't get grabbed by another call to play while this one waits to start.\n            sound._ended = false;\n            // Update the parameters of the sound.\n            var setParams = function() {\n                sound._paused = false;\n                sound._seek = seek;\n                sound._start = start;\n                sound._stop = stop;\n                sound._loop = !!(sound._loop || self._sprite[sprite][2]);\n            };\n            // End the sound instantly if seek is at the end.\n            if (seek >= stop) {\n                self._ended(sound);\n                return;\n            }\n            // Begin the actual playback.\n            var node = sound._node;\n            if (self._webAudio) {\n                // Fire this when the sound is ready to play to begin Web Audio playback.\n                var playWebAudio = function() {\n                    self._playLock = false;\n                    setParams();\n                    self._refreshBuffer(sound);\n                    // Setup the playback params.\n                    var vol = sound._muted || self._muted ? 0 : sound._volume;\n                    node.gain.setValueAtTime(vol, Howler1.ctx.currentTime);\n                    sound._playStart = Howler1.ctx.currentTime;\n                    // Play the sound using the supported method.\n                    if (typeof node.bufferSource.start === \"undefined\") {\n                        sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);\n                    } else {\n                        sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);\n                    }\n                    // Start a new timer if none is present.\n                    if (timeout !== Infinity) {\n                        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n                    }\n                    if (!internal) {\n                        setTimeout(function() {\n                            self._emit(\"play\", sound._id);\n                            self._loadQueue();\n                        }, 0);\n                    }\n                };\n                if (Howler1.state === \"running\" && Howler1.ctx.state !== \"interrupted\") {\n                    playWebAudio();\n                } else {\n                    self._playLock = true;\n                    // Wait for the audio context to resume before playing.\n                    self.once(\"resume\", playWebAudio);\n                    // Cancel the end timer.\n                    self._clearTimer(sound._id);\n                }\n            } else {\n                // Fire this when the sound is ready to play to begin HTML5 Audio playback.\n                var playHtml5 = function() {\n                    node.currentTime = seek;\n                    node.muted = sound._muted || self._muted || Howler1._muted || node.muted;\n                    node.volume = sound._volume * Howler1.volume();\n                    node.playbackRate = sound._rate;\n                    // Some browsers will throw an error if this is called without user interaction.\n                    try {\n                        var play = node.play();\n                        // Support older browsers that don't support promises, and thus don't have this issue.\n                        if (play && typeof Promise !== \"undefined\" && (play instanceof Promise || typeof play.then === \"function\")) {\n                            // Implements a lock to prevent DOMException: The play() request was interrupted by a call to pause().\n                            self._playLock = true;\n                            // Set param values immediately.\n                            setParams();\n                            // Releases the lock and executes queued actions.\n                            play.then(function() {\n                                self._playLock = false;\n                                node._unlocked = true;\n                                if (!internal) {\n                                    self._emit(\"play\", sound._id);\n                                } else {\n                                    self._loadQueue();\n                                }\n                            }).catch(function() {\n                                self._playLock = false;\n                                self._emit(\"playerror\", sound._id, \"Playback was unable to start. This is most commonly an issue \" + \"on mobile devices and Chrome where playback was not within a user interaction.\");\n                                // Reset the ended and paused values.\n                                sound._ended = true;\n                                sound._paused = true;\n                            });\n                        } else if (!internal) {\n                            self._playLock = false;\n                            setParams();\n                            self._emit(\"play\", sound._id);\n                        }\n                        // Setting rate before playing won't work in IE, so we set it again here.\n                        node.playbackRate = sound._rate;\n                        // If the node is still paused, then we can assume there was a playback issue.\n                        if (node.paused) {\n                            self._emit(\"playerror\", sound._id, \"Playback was unable to start. This is most commonly an issue \" + \"on mobile devices and Chrome where playback was not within a user interaction.\");\n                            return;\n                        }\n                        // Setup the end timer on sprites or listen for the ended event.\n                        if (sprite !== \"__default\" || sound._loop) {\n                            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n                        } else {\n                            self._endTimers[sound._id] = function() {\n                                // Fire ended on this audio node.\n                                self._ended(sound);\n                                // Clear this listener.\n                                node.removeEventListener(\"ended\", self._endTimers[sound._id], false);\n                            };\n                            node.addEventListener(\"ended\", self._endTimers[sound._id], false);\n                        }\n                    } catch (err) {\n                        self._emit(\"playerror\", sound._id, err);\n                    }\n                };\n                // If this is streaming audio, make sure the src is set and load again.\n                if (node.src === \"data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA\") {\n                    node.src = self._src;\n                    node.load();\n                }\n                // Play immediately if ready, or wait for the 'canplaythrough'e vent.\n                var loadedNoReadyState = window && window.ejecta || !node.readyState && Howler1._navigator.isCocoonJS;\n                if (node.readyState >= 3 || loadedNoReadyState) {\n                    playHtml5();\n                } else {\n                    self._playLock = true;\n                    self._state = \"loading\";\n                    var listener = function() {\n                        self._state = \"loaded\";\n                        // Begin playback.\n                        playHtml5();\n                        // Clear this listener.\n                        node.removeEventListener(Howler1._canPlayEvent, listener, false);\n                    };\n                    node.addEventListener(Howler1._canPlayEvent, listener, false);\n                    // Cancel the end timer.\n                    self._clearTimer(sound._id);\n                }\n            }\n            return sound._id;\n        },\n        /**\n     * Pause playback and save current position.\n     * @param  {Number} id The sound ID (empty to pause all in group).\n     * @return {Howl}\n     */ pause: function(id) {\n            var self = this;\n            // If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.\n            if (self._state !== \"loaded\" || self._playLock) {\n                self._queue.push({\n                    event: \"pause\",\n                    action: function() {\n                        self.pause(id);\n                    }\n                });\n                return self;\n            }\n            // If no id is passed, get all ID's to be paused.\n            var ids = self._getSoundIds(id);\n            for(var i = 0; i < ids.length; i++){\n                // Clear the end timer.\n                self._clearTimer(ids[i]);\n                // Get the sound.\n                var sound = self._soundById(ids[i]);\n                if (sound && !sound._paused) {\n                    // Reset the seek position.\n                    sound._seek = self.seek(ids[i]);\n                    sound._rateSeek = 0;\n                    sound._paused = true;\n                    // Stop currently running fades.\n                    self._stopFade(ids[i]);\n                    if (sound._node) {\n                        if (self._webAudio) {\n                            // Make sure the sound has been created.\n                            if (!sound._node.bufferSource) {\n                                continue;\n                            }\n                            if (typeof sound._node.bufferSource.stop === \"undefined\") {\n                                sound._node.bufferSource.noteOff(0);\n                            } else {\n                                sound._node.bufferSource.stop(0);\n                            }\n                            // Clean up the buffer source.\n                            self._cleanBuffer(sound._node);\n                        } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\n                            sound._node.pause();\n                        }\n                    }\n                }\n                // Fire the pause event, unless `true` is passed as the 2nd argument.\n                if (!arguments[1]) {\n                    self._emit(\"pause\", sound ? sound._id : null);\n                }\n            }\n            return self;\n        },\n        /**\n     * Stop playback and reset to start.\n     * @param  {Number} id The sound ID (empty to stop all in group).\n     * @param  {Boolean} internal Internal Use: true prevents event firing.\n     * @return {Howl}\n     */ stop: function(id, internal) {\n            var self = this;\n            // If the sound hasn't loaded, add it to the load queue to stop when capable.\n            if (self._state !== \"loaded\" || self._playLock) {\n                self._queue.push({\n                    event: \"stop\",\n                    action: function() {\n                        self.stop(id);\n                    }\n                });\n                return self;\n            }\n            // If no id is passed, get all ID's to be stopped.\n            var ids = self._getSoundIds(id);\n            for(var i = 0; i < ids.length; i++){\n                // Clear the end timer.\n                self._clearTimer(ids[i]);\n                // Get the sound.\n                var sound = self._soundById(ids[i]);\n                if (sound) {\n                    // Reset the seek position.\n                    sound._seek = sound._start || 0;\n                    sound._rateSeek = 0;\n                    sound._paused = true;\n                    sound._ended = true;\n                    // Stop currently running fades.\n                    self._stopFade(ids[i]);\n                    if (sound._node) {\n                        if (self._webAudio) {\n                            // Make sure the sound's AudioBufferSourceNode has been created.\n                            if (sound._node.bufferSource) {\n                                if (typeof sound._node.bufferSource.stop === \"undefined\") {\n                                    sound._node.bufferSource.noteOff(0);\n                                } else {\n                                    sound._node.bufferSource.stop(0);\n                                }\n                                // Clean up the buffer source.\n                                self._cleanBuffer(sound._node);\n                            }\n                        } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\n                            sound._node.currentTime = sound._start || 0;\n                            sound._node.pause();\n                            // If this is a live stream, stop download once the audio is stopped.\n                            if (sound._node.duration === Infinity) {\n                                self._clearSound(sound._node);\n                            }\n                        }\n                    }\n                    if (!internal) {\n                        self._emit(\"stop\", sound._id);\n                    }\n                }\n            }\n            return self;\n        },\n        /**\n     * Mute/unmute a single sound or all sounds in this Howl group.\n     * @param  {Boolean} muted Set to true to mute and false to unmute.\n     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).\n     * @return {Howl}\n     */ mute: function(muted, id) {\n            var self = this;\n            // If the sound hasn't loaded, add it to the load queue to mute when capable.\n            if (self._state !== \"loaded\" || self._playLock) {\n                self._queue.push({\n                    event: \"mute\",\n                    action: function() {\n                        self.mute(muted, id);\n                    }\n                });\n                return self;\n            }\n            // If applying mute/unmute to all sounds, update the group's value.\n            if (typeof id === \"undefined\") {\n                if (typeof muted === \"boolean\") {\n                    self._muted = muted;\n                } else {\n                    return self._muted;\n                }\n            }\n            // If no id is passed, get all ID's to be muted.\n            var ids = self._getSoundIds(id);\n            for(var i = 0; i < ids.length; i++){\n                // Get the sound.\n                var sound = self._soundById(ids[i]);\n                if (sound) {\n                    sound._muted = muted;\n                    // Cancel active fade and set the volume to the end value.\n                    if (sound._interval) {\n                        self._stopFade(sound._id);\n                    }\n                    if (self._webAudio && sound._node) {\n                        sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler1.ctx.currentTime);\n                    } else if (sound._node) {\n                        sound._node.muted = Howler1._muted ? true : muted;\n                    }\n                    self._emit(\"mute\", sound._id);\n                }\n            }\n            return self;\n        },\n        /**\n     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.\n     *   volume() -> Returns the group's volume value.\n     *   volume(id) -> Returns the sound id's current volume.\n     *   volume(vol) -> Sets the volume of all sounds in this Howl group.\n     *   volume(vol, id) -> Sets the volume of passed sound id.\n     * @return {Howl/Number} Returns self or current volume.\n     */ volume: function() {\n            var self = this;\n            var args = arguments;\n            var vol, id;\n            // Determine the values based on arguments.\n            if (args.length === 0) {\n                // Return the value of the groups' volume.\n                return self._volume;\n            } else if (args.length === 1 || args.length === 2 && typeof args[1] === \"undefined\") {\n                // First check if this is an ID, and if not, assume it is a new volume.\n                var ids = self._getSoundIds();\n                var index = ids.indexOf(args[0]);\n                if (index >= 0) {\n                    id = parseInt(args[0], 10);\n                } else {\n                    vol = parseFloat(args[0]);\n                }\n            } else if (args.length >= 2) {\n                vol = parseFloat(args[0]);\n                id = parseInt(args[1], 10);\n            }\n            // Update the volume or return the current volume.\n            var sound;\n            if (typeof vol !== \"undefined\" && vol >= 0 && vol <= 1) {\n                // If the sound hasn't loaded, add it to the load queue to change volume when capable.\n                if (self._state !== \"loaded\" || self._playLock) {\n                    self._queue.push({\n                        event: \"volume\",\n                        action: function() {\n                            self.volume.apply(self, args);\n                        }\n                    });\n                    return self;\n                }\n                // Set the group volume.\n                if (typeof id === \"undefined\") {\n                    self._volume = vol;\n                }\n                // Update one or all volumes.\n                id = self._getSoundIds(id);\n                for(var i = 0; i < id.length; i++){\n                    // Get the sound.\n                    sound = self._soundById(id[i]);\n                    if (sound) {\n                        sound._volume = vol;\n                        // Stop currently running fades.\n                        if (!args[2]) {\n                            self._stopFade(id[i]);\n                        }\n                        if (self._webAudio && sound._node && !sound._muted) {\n                            sound._node.gain.setValueAtTime(vol, Howler1.ctx.currentTime);\n                        } else if (sound._node && !sound._muted) {\n                            sound._node.volume = vol * Howler1.volume();\n                        }\n                        self._emit(\"volume\", sound._id);\n                    }\n                }\n            } else {\n                sound = id ? self._soundById(id) : self._sounds[0];\n                return sound ? sound._volume : 0;\n            }\n            return self;\n        },\n        /**\n     * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).\n     * @param  {Number} from The value to fade from (0.0 to 1.0).\n     * @param  {Number} to   The volume to fade to (0.0 to 1.0).\n     * @param  {Number} len  Time in milliseconds to fade.\n     * @param  {Number} id   The sound id (omit to fade all sounds).\n     * @return {Howl}\n     */ fade: function(from, to, len, id) {\n            var self = this;\n            // If the sound hasn't loaded, add it to the load queue to fade when capable.\n            if (self._state !== \"loaded\" || self._playLock) {\n                self._queue.push({\n                    event: \"fade\",\n                    action: function() {\n                        self.fade(from, to, len, id);\n                    }\n                });\n                return self;\n            }\n            // Make sure the to/from/len values are numbers.\n            from = Math.min(Math.max(0, parseFloat(from)), 1);\n            to = Math.min(Math.max(0, parseFloat(to)), 1);\n            len = parseFloat(len);\n            // Set the volume to the start position.\n            self.volume(from, id);\n            // Fade the volume of one or all sounds.\n            var ids = self._getSoundIds(id);\n            for(var i = 0; i < ids.length; i++){\n                // Get the sound.\n                var sound = self._soundById(ids[i]);\n                // Create a linear fade or fall back to timeouts with HTML5 Audio.\n                if (sound) {\n                    // Stop the previous fade if no sprite is being used (otherwise, volume handles this).\n                    if (!id) {\n                        self._stopFade(ids[i]);\n                    }\n                    // If we are using Web Audio, let the native methods do the actual fade.\n                    if (self._webAudio && !sound._muted) {\n                        var currentTime = Howler1.ctx.currentTime;\n                        var end = currentTime + len / 1000;\n                        sound._volume = from;\n                        sound._node.gain.setValueAtTime(from, currentTime);\n                        sound._node.gain.linearRampToValueAtTime(to, end);\n                    }\n                    self._startFadeInterval(sound, from, to, len, ids[i], typeof id === \"undefined\");\n                }\n            }\n            return self;\n        },\n        /**\n     * Starts the internal interval to fade a sound.\n     * @param  {Object} sound Reference to sound to fade.\n     * @param  {Number} from The value to fade from (0.0 to 1.0).\n     * @param  {Number} to   The volume to fade to (0.0 to 1.0).\n     * @param  {Number} len  Time in milliseconds to fade.\n     * @param  {Number} id   The sound id to fade.\n     * @param  {Boolean} isGroup   If true, set the volume on the group.\n     */ _startFadeInterval: function(sound, from, to, len, id, isGroup) {\n            var self = this;\n            var vol = from;\n            var diff = to - from;\n            var steps = Math.abs(diff / 0.01);\n            var stepLen = Math.max(4, steps > 0 ? len / steps : len);\n            var lastTick = Date.now();\n            // Store the value being faded to.\n            sound._fadeTo = to;\n            // Update the volume value on each interval tick.\n            sound._interval = setInterval(function() {\n                // Update the volume based on the time since the last tick.\n                var tick = (Date.now() - lastTick) / len;\n                lastTick = Date.now();\n                vol += diff * tick;\n                // Round to within 2 decimal points.\n                vol = Math.round(vol * 100) / 100;\n                // Make sure the volume is in the right bounds.\n                if (diff < 0) {\n                    vol = Math.max(to, vol);\n                } else {\n                    vol = Math.min(to, vol);\n                }\n                // Change the volume.\n                if (self._webAudio) {\n                    sound._volume = vol;\n                } else {\n                    self.volume(vol, sound._id, true);\n                }\n                // Set the group's volume.\n                if (isGroup) {\n                    self._volume = vol;\n                }\n                // When the fade is complete, stop it and fire event.\n                if (to < from && vol <= to || to > from && vol >= to) {\n                    clearInterval(sound._interval);\n                    sound._interval = null;\n                    sound._fadeTo = null;\n                    self.volume(to, sound._id);\n                    self._emit(\"fade\", sound._id);\n                }\n            }, stepLen);\n        },\n        /**\n     * Internal method that stops the currently playing fade when\n     * a new fade starts, volume is changed or the sound is stopped.\n     * @param  {Number} id The sound id.\n     * @return {Howl}\n     */ _stopFade: function(id) {\n            var self = this;\n            var sound = self._soundById(id);\n            if (sound && sound._interval) {\n                if (self._webAudio) {\n                    sound._node.gain.cancelScheduledValues(Howler1.ctx.currentTime);\n                }\n                clearInterval(sound._interval);\n                sound._interval = null;\n                self.volume(sound._fadeTo, id);\n                sound._fadeTo = null;\n                self._emit(\"fade\", id);\n            }\n            return self;\n        },\n        /**\n     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   loop() -> Returns the group's loop value.\n     *   loop(id) -> Returns the sound id's loop value.\n     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.\n     *   loop(loop, id) -> Sets the loop value of passed sound id.\n     * @return {Howl/Boolean} Returns self or current loop value.\n     */ loop: function() {\n            var self = this;\n            var args = arguments;\n            var loop, id, sound;\n            // Determine the values for loop and id.\n            if (args.length === 0) {\n                // Return the grou's loop value.\n                return self._loop;\n            } else if (args.length === 1) {\n                if (typeof args[0] === \"boolean\") {\n                    loop = args[0];\n                    self._loop = loop;\n                } else {\n                    // Return this sound's loop value.\n                    sound = self._soundById(parseInt(args[0], 10));\n                    return sound ? sound._loop : false;\n                }\n            } else if (args.length === 2) {\n                loop = args[0];\n                id = parseInt(args[1], 10);\n            }\n            // If no id is passed, get all ID's to be looped.\n            var ids = self._getSoundIds(id);\n            for(var i = 0; i < ids.length; i++){\n                sound = self._soundById(ids[i]);\n                if (sound) {\n                    sound._loop = loop;\n                    if (self._webAudio && sound._node && sound._node.bufferSource) {\n                        sound._node.bufferSource.loop = loop;\n                        if (loop) {\n                            sound._node.bufferSource.loopStart = sound._start || 0;\n                            sound._node.bufferSource.loopEnd = sound._stop;\n                            // If playing, restart playback to ensure looping updates.\n                            if (self.playing(ids[i])) {\n                                self.pause(ids[i], true);\n                                self.play(ids[i], true);\n                            }\n                        }\n                    }\n                }\n            }\n            return self;\n        },\n        /**\n     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   rate() -> Returns the first sound node's current playback rate.\n     *   rate(id) -> Returns the sound id's current playback rate.\n     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.\n     *   rate(rate, id) -> Sets the playback rate of passed sound id.\n     * @return {Howl/Number} Returns self or the current playback rate.\n     */ rate: function() {\n            var self = this;\n            var args = arguments;\n            var rate, id;\n            // Determine the values based on arguments.\n            if (args.length === 0) {\n                // We will simply return the current rate of the first node.\n                id = self._sounds[0]._id;\n            } else if (args.length === 1) {\n                // First check if this is an ID, and if not, assume it is a new rate value.\n                var ids = self._getSoundIds();\n                var index = ids.indexOf(args[0]);\n                if (index >= 0) {\n                    id = parseInt(args[0], 10);\n                } else {\n                    rate = parseFloat(args[0]);\n                }\n            } else if (args.length === 2) {\n                rate = parseFloat(args[0]);\n                id = parseInt(args[1], 10);\n            }\n            // Update the playback rate or return the current value.\n            var sound;\n            if (typeof rate === \"number\") {\n                // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.\n                if (self._state !== \"loaded\" || self._playLock) {\n                    self._queue.push({\n                        event: \"rate\",\n                        action: function() {\n                            self.rate.apply(self, args);\n                        }\n                    });\n                    return self;\n                }\n                // Set the group rate.\n                if (typeof id === \"undefined\") {\n                    self._rate = rate;\n                }\n                // Update one or all volumes.\n                id = self._getSoundIds(id);\n                for(var i = 0; i < id.length; i++){\n                    // Get the sound.\n                    sound = self._soundById(id[i]);\n                    if (sound) {\n                        // Keep track of our position when the rate changed and update the playback\n                        // start position so we can properly adjust the seek position for time elapsed.\n                        if (self.playing(id[i])) {\n                            sound._rateSeek = self.seek(id[i]);\n                            sound._playStart = self._webAudio ? Howler1.ctx.currentTime : sound._playStart;\n                        }\n                        sound._rate = rate;\n                        // Change the playback rate.\n                        if (self._webAudio && sound._node && sound._node.bufferSource) {\n                            sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler1.ctx.currentTime);\n                        } else if (sound._node) {\n                            sound._node.playbackRate = rate;\n                        }\n                        // Reset the timers.\n                        var seek = self.seek(id[i]);\n                        var duration = (self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000 - seek;\n                        var timeout = duration * 1000 / Math.abs(sound._rate);\n                        // Start a new end timer if sound is already playing.\n                        if (self._endTimers[id[i]] || !sound._paused) {\n                            self._clearTimer(id[i]);\n                            self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);\n                        }\n                        self._emit(\"rate\", sound._id);\n                    }\n                }\n            } else {\n                sound = self._soundById(id);\n                return sound ? sound._rate : self._rate;\n            }\n            return self;\n        },\n        /**\n     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   seek() -> Returns the first sound node's current seek position.\n     *   seek(id) -> Returns the sound id's current seek position.\n     *   seek(seek) -> Sets the seek position of the first sound node.\n     *   seek(seek, id) -> Sets the seek position of passed sound id.\n     * @return {Howl/Number} Returns self or the current seek position.\n     */ seek: function() {\n            var self = this;\n            var args = arguments;\n            var seek, id;\n            // Determine the values based on arguments.\n            if (args.length === 0) {\n                // We will simply return the current position of the first node.\n                if (self._sounds.length) {\n                    id = self._sounds[0]._id;\n                }\n            } else if (args.length === 1) {\n                // First check if this is an ID, and if not, assume it is a new seek position.\n                var ids = self._getSoundIds();\n                var index = ids.indexOf(args[0]);\n                if (index >= 0) {\n                    id = parseInt(args[0], 10);\n                } else if (self._sounds.length) {\n                    id = self._sounds[0]._id;\n                    seek = parseFloat(args[0]);\n                }\n            } else if (args.length === 2) {\n                seek = parseFloat(args[0]);\n                id = parseInt(args[1], 10);\n            }\n            // If there is no ID, bail out.\n            if (typeof id === \"undefined\") {\n                return 0;\n            }\n            // If the sound hasn't loaded, add it to the load queue to seek when capable.\n            if (typeof seek === \"number\" && (self._state !== \"loaded\" || self._playLock)) {\n                self._queue.push({\n                    event: \"seek\",\n                    action: function() {\n                        self.seek.apply(self, args);\n                    }\n                });\n                return self;\n            }\n            // Get the sound.\n            var sound = self._soundById(id);\n            if (sound) {\n                if (typeof seek === \"number\" && seek >= 0) {\n                    // Pause the sound and update position for restarting playback.\n                    var playing = self.playing(id);\n                    if (playing) {\n                        self.pause(id, true);\n                    }\n                    // Move the position of the track and cancel timer.\n                    sound._seek = seek;\n                    sound._ended = false;\n                    self._clearTimer(id);\n                    // Update the seek position for HTML5 Audio.\n                    if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) {\n                        sound._node.currentTime = seek;\n                    }\n                    // Seek and emit when ready.\n                    var seekAndEmit = function() {\n                        // Restart the playback if the sound was playing.\n                        if (playing) {\n                            self.play(id, true);\n                        }\n                        self._emit(\"seek\", id);\n                    };\n                    // Wait for the play lock to be unset before emitting (HTML5 Audio).\n                    if (playing && !self._webAudio) {\n                        var emitSeek = function() {\n                            if (!self._playLock) {\n                                seekAndEmit();\n                            } else {\n                                setTimeout(emitSeek, 0);\n                            }\n                        };\n                        setTimeout(emitSeek, 0);\n                    } else {\n                        seekAndEmit();\n                    }\n                } else {\n                    if (self._webAudio) {\n                        var realTime = self.playing(id) ? Howler1.ctx.currentTime - sound._playStart : 0;\n                        var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;\n                        return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));\n                    } else {\n                        return sound._node.currentTime;\n                    }\n                }\n            }\n            return self;\n        },\n        /**\n     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.\n     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.\n     * @return {Boolean} True if playing and false if not.\n     */ playing: function(id) {\n            var self = this;\n            // Check the passed sound ID (if any).\n            if (typeof id === \"number\") {\n                var sound = self._soundById(id);\n                return sound ? !sound._paused : false;\n            }\n            // Otherwise, loop through all sounds and check if any are playing.\n            for(var i = 0; i < self._sounds.length; i++){\n                if (!self._sounds[i]._paused) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n     * Get the duration of this sound. Passing a sound id will return the sprite duration.\n     * @param  {Number} id The sound id to check. If none is passed, return full source duration.\n     * @return {Number} Audio duration in seconds.\n     */ duration: function(id) {\n            var self = this;\n            var duration = self._duration;\n            // If we pass an ID, get the sound and return the sprite length.\n            var sound = self._soundById(id);\n            if (sound) {\n                duration = self._sprite[sound._sprite][1] / 1000;\n            }\n            return duration;\n        },\n        /**\n     * Returns the current loaded state of this Howl.\n     * @return {String} 'unloaded', 'loading', 'loaded'\n     */ state: function() {\n            return this._state;\n        },\n        /**\n     * Unload and destroy the current Howl object.\n     * This will immediately stop all sound instances attached to this group.\n     */ unload: function() {\n            var self = this;\n            // Stop playing any active sounds.\n            var sounds = self._sounds;\n            for(var i = 0; i < sounds.length; i++){\n                // Stop the sound if it is currently playing.\n                if (!sounds[i]._paused) {\n                    self.stop(sounds[i]._id);\n                }\n                // Remove the source or disconnect.\n                if (!self._webAudio) {\n                    // Set the source to 0-second silence to stop any downloading (except in IE).\n                    self._clearSound(sounds[i]._node);\n                    // Remove any event listeners.\n                    sounds[i]._node.removeEventListener(\"error\", sounds[i]._errorFn, false);\n                    sounds[i]._node.removeEventListener(Howler1._canPlayEvent, sounds[i]._loadFn, false);\n                    sounds[i]._node.removeEventListener(\"ended\", sounds[i]._endFn, false);\n                    // Release the Audio object back to the pool.\n                    Howler1._releaseHtml5Audio(sounds[i]._node);\n                }\n                // Empty out all of the nodes.\n                delete sounds[i]._node;\n                // Make sure all timers are cleared out.\n                self._clearTimer(sounds[i]._id);\n            }\n            // Remove the references in the global Howler object.\n            var index = Howler1._howls.indexOf(self);\n            if (index >= 0) {\n                Howler1._howls.splice(index, 1);\n            }\n            // Delete this sound from the cache (if no other Howl is using it).\n            var remCache = true;\n            for(i = 0; i < Howler1._howls.length; i++){\n                if (Howler1._howls[i]._src === self._src || self._src.indexOf(Howler1._howls[i]._src) >= 0) {\n                    remCache = false;\n                    break;\n                }\n            }\n            if (cache && remCache) {\n                delete cache[self._src];\n            }\n            // Clear global errors.\n            Howler1.noAudio = false;\n            // Clear out `self`.\n            self._state = \"unloaded\";\n            self._sounds = [];\n            self = null;\n            return null;\n        },\n        /**\n     * Listen to a custom event.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to call.\n     * @param  {Number}   id    (optional) Only listen to events for this sound.\n     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.\n     * @return {Howl}\n     */ on: function(event, fn, id, once) {\n            var self = this;\n            var events = self[\"_on\" + event];\n            if (typeof fn === \"function\") {\n                events.push(once ? {\n                    id: id,\n                    fn: fn,\n                    once: once\n                } : {\n                    id: id,\n                    fn: fn\n                });\n            }\n            return self;\n        },\n        /**\n     * Remove a custom event. Call without parameters to remove all events.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to remove. Leave empty to remove all.\n     * @param  {Number}   id    (optional) Only remove events for this sound.\n     * @return {Howl}\n     */ off: function(event, fn, id) {\n            var self = this;\n            var events = self[\"_on\" + event];\n            var i = 0;\n            // Allow passing just an event and ID.\n            if (typeof fn === \"number\") {\n                id = fn;\n                fn = null;\n            }\n            if (fn || id) {\n                // Loop through event store and remove the passed function.\n                for(i = 0; i < events.length; i++){\n                    var isId = id === events[i].id;\n                    if (fn === events[i].fn && isId || !fn && isId) {\n                        events.splice(i, 1);\n                        break;\n                    }\n                }\n            } else if (event) {\n                // Clear out all events of this type.\n                self[\"_on\" + event] = [];\n            } else {\n                // Clear out all events of every type.\n                var keys = Object.keys(self);\n                for(i = 0; i < keys.length; i++){\n                    if (keys[i].indexOf(\"_on\") === 0 && Array.isArray(self[keys[i]])) {\n                        self[keys[i]] = [];\n                    }\n                }\n            }\n            return self;\n        },\n        /**\n     * Listen to a custom event and remove it once fired.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to call.\n     * @param  {Number}   id    (optional) Only listen to events for this sound.\n     * @return {Howl}\n     */ once: function(event, fn, id) {\n            var self = this;\n            // Setup the event listener.\n            self.on(event, fn, id, 1);\n            return self;\n        },\n        /**\n     * Emit all events of a specific type and pass the sound id.\n     * @param  {String} event Event name.\n     * @param  {Number} id    Sound ID.\n     * @param  {Number} msg   Message to go with event.\n     * @return {Howl}\n     */ _emit: function(event, id, msg) {\n            var self = this;\n            var events = self[\"_on\" + event];\n            // Loop through event store and fire all functions.\n            for(var i = events.length - 1; i >= 0; i--){\n                // Only fire the listener if the correct ID is used.\n                if (!events[i].id || events[i].id === id || event === \"load\") {\n                    setTimeout((function(fn) {\n                        fn.call(this, id, msg);\n                    }).bind(self, events[i].fn), 0);\n                    // If this event was setup with `once`, remove it.\n                    if (events[i].once) {\n                        self.off(event, events[i].fn, events[i].id);\n                    }\n                }\n            }\n            // Pass the event type into load queue so that it can continue stepping.\n            self._loadQueue(event);\n            return self;\n        },\n        /**\n     * Queue of actions initiated before the sound has loaded.\n     * These will be called in sequence, with the next only firing\n     * after the previous has finished executing (even if async like play).\n     * @return {Howl}\n     */ _loadQueue: function(event) {\n            var self = this;\n            if (self._queue.length > 0) {\n                var task = self._queue[0];\n                // Remove this task if a matching event was passed.\n                if (task.event === event) {\n                    self._queue.shift();\n                    self._loadQueue();\n                }\n                // Run the task if no event type is passed.\n                if (!event) {\n                    task.action();\n                }\n            }\n            return self;\n        },\n        /**\n     * Fired when playback ends at the end of the duration.\n     * @param  {Sound} sound The sound object to work with.\n     * @return {Howl}\n     */ _ended: function(sound) {\n            var self = this;\n            var sprite = sound._sprite;\n            // If we are using IE and there was network latency we may be clipping\n            // audio before it completes playing. Lets check the node to make sure it\n            // believes it has completed, before ending the playback.\n            if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {\n                setTimeout(self._ended.bind(self, sound), 100);\n                return self;\n            }\n            // Should this sound loop?\n            var loop = !!(sound._loop || self._sprite[sprite][2]);\n            // Fire the ended event.\n            self._emit(\"end\", sound._id);\n            // Restart the playback for HTML5 Audio loop.\n            if (!self._webAudio && loop) {\n                self.stop(sound._id, true).play(sound._id);\n            }\n            // Restart this timer if on a Web Audio loop.\n            if (self._webAudio && loop) {\n                self._emit(\"play\", sound._id);\n                sound._seek = sound._start || 0;\n                sound._rateSeek = 0;\n                sound._playStart = Howler1.ctx.currentTime;\n                var timeout = (sound._stop - sound._start) * 1000 / Math.abs(sound._rate);\n                self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n            }\n            // Mark the node as paused.\n            if (self._webAudio && !loop) {\n                sound._paused = true;\n                sound._ended = true;\n                sound._seek = sound._start || 0;\n                sound._rateSeek = 0;\n                self._clearTimer(sound._id);\n                // Clean up the buffer source.\n                self._cleanBuffer(sound._node);\n                // Attempt to auto-suspend AudioContext if no sounds are still playing.\n                Howler1._autoSuspend();\n            }\n            // When using a sprite, end the track.\n            if (!self._webAudio && !loop) {\n                self.stop(sound._id, true);\n            }\n            return self;\n        },\n        /**\n     * Clear the end timer for a sound playback.\n     * @param  {Number} id The sound ID.\n     * @return {Howl}\n     */ _clearTimer: function(id) {\n            var self = this;\n            if (self._endTimers[id]) {\n                // Clear the timeout or remove the ended listener.\n                if (typeof self._endTimers[id] !== \"function\") {\n                    clearTimeout(self._endTimers[id]);\n                } else {\n                    var sound = self._soundById(id);\n                    if (sound && sound._node) {\n                        sound._node.removeEventListener(\"ended\", self._endTimers[id], false);\n                    }\n                }\n                delete self._endTimers[id];\n            }\n            return self;\n        },\n        /**\n     * Return the sound identified by this ID, or return null.\n     * @param  {Number} id Sound ID\n     * @return {Object}    Sound object or null.\n     */ _soundById: function(id) {\n            var self = this;\n            // Loop through all sounds and find the one with this ID.\n            for(var i = 0; i < self._sounds.length; i++){\n                if (id === self._sounds[i]._id) {\n                    return self._sounds[i];\n                }\n            }\n            return null;\n        },\n        /**\n     * Return an inactive sound from the pool or create a new one.\n     * @return {Sound} Sound playback object.\n     */ _inactiveSound: function() {\n            var self = this;\n            self._drain();\n            // Find the first inactive node to recycle.\n            for(var i = 0; i < self._sounds.length; i++){\n                if (self._sounds[i]._ended) {\n                    return self._sounds[i].reset();\n                }\n            }\n            // If no inactive node was found, create a new one.\n            return new Sound1(self);\n        },\n        /**\n     * Drain excess inactive sounds from the pool.\n     */ _drain: function() {\n            var self = this;\n            var limit = self._pool;\n            var cnt = 0;\n            var i = 0;\n            // If there are less sounds than the max pool size, we are done.\n            if (self._sounds.length < limit) {\n                return;\n            }\n            // Count the number of inactive sounds.\n            for(i = 0; i < self._sounds.length; i++){\n                if (self._sounds[i]._ended) {\n                    cnt++;\n                }\n            }\n            // Remove excess inactive sounds, going in reverse order.\n            for(i = self._sounds.length - 1; i >= 0; i--){\n                if (cnt <= limit) {\n                    return;\n                }\n                if (self._sounds[i]._ended) {\n                    // Disconnect the audio source when using Web Audio.\n                    if (self._webAudio && self._sounds[i]._node) {\n                        self._sounds[i]._node.disconnect(0);\n                    }\n                    // Remove sounds until we have the pool size.\n                    self._sounds.splice(i, 1);\n                    cnt--;\n                }\n            }\n        },\n        /**\n     * Get all ID's from the sounds pool.\n     * @param  {Number} id Only return one ID if one is passed.\n     * @return {Array}    Array of IDs.\n     */ _getSoundIds: function(id) {\n            var self = this;\n            if (typeof id === \"undefined\") {\n                var ids = [];\n                for(var i = 0; i < self._sounds.length; i++){\n                    ids.push(self._sounds[i]._id);\n                }\n                return ids;\n            } else {\n                return [\n                    id\n                ];\n            }\n        },\n        /**\n     * Load the sound back into the buffer source.\n     * @param  {Sound} sound The sound object to work with.\n     * @return {Howl}\n     */ _refreshBuffer: function(sound) {\n            var self = this;\n            // Setup the buffer source for playback.\n            sound._node.bufferSource = Howler1.ctx.createBufferSource();\n            sound._node.bufferSource.buffer = cache[self._src];\n            // Connect to the correct node.\n            if (sound._panner) {\n                sound._node.bufferSource.connect(sound._panner);\n            } else {\n                sound._node.bufferSource.connect(sound._node);\n            }\n            // Setup looping and playback rate.\n            sound._node.bufferSource.loop = sound._loop;\n            if (sound._loop) {\n                sound._node.bufferSource.loopStart = sound._start || 0;\n                sound._node.bufferSource.loopEnd = sound._stop || 0;\n            }\n            sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler1.ctx.currentTime);\n            return self;\n        },\n        /**\n     * Prevent memory leaks by cleaning up the buffer source after playback.\n     * @param  {Object} node Sound's audio node containing the buffer source.\n     * @return {Howl}\n     */ _cleanBuffer: function(node) {\n            var self = this;\n            var isIOS = Howler1._navigator && Howler1._navigator.vendor.indexOf(\"Apple\") >= 0;\n            if (!node.bufferSource) {\n                return self;\n            }\n            if (Howler1._scratchBuffer && node.bufferSource) {\n                node.bufferSource.onended = null;\n                node.bufferSource.disconnect(0);\n                if (isIOS) {\n                    try {\n                        node.bufferSource.buffer = Howler1._scratchBuffer;\n                    } catch (e) {}\n                }\n            }\n            node.bufferSource = null;\n            return self;\n        },\n        /**\n     * Set the source to a 0-second silence to stop any downloading (except in IE).\n     * @param  {Object} node Audio node to clear.\n     */ _clearSound: function(node) {\n            var checkIE = /MSIE |Trident\\//.test(Howler1._navigator && Howler1._navigator.userAgent);\n            if (!checkIE) {\n                node.src = \"data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA\";\n            }\n        }\n    };\n    /** Single Sound Methods **/ /***************************************************************************/ /**\n   * Setup the sound object, which each node attached to a Howl group is contained in.\n   * @param {Object} howl The Howl parent group.\n   */ var Sound1 = function(howl) {\n        this._parent = howl;\n        this.init();\n    };\n    Sound1.prototype = {\n        /**\n     * Initialize a new Sound object.\n     * @return {Sound}\n     */ init: function() {\n            var self = this;\n            var parent = self._parent;\n            // Setup the default parameters.\n            self._muted = parent._muted;\n            self._loop = parent._loop;\n            self._volume = parent._volume;\n            self._rate = parent._rate;\n            self._seek = 0;\n            self._paused = true;\n            self._ended = true;\n            self._sprite = \"__default\";\n            // Generate a unique ID for this sound.\n            self._id = ++Howler1._counter;\n            // Add itself to the parent's pool.\n            parent._sounds.push(self);\n            // Create the new node.\n            self.create();\n            return self;\n        },\n        /**\n     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.\n     * @return {Sound}\n     */ create: function() {\n            var self = this;\n            var parent = self._parent;\n            var volume = Howler1._muted || self._muted || self._parent._muted ? 0 : self._volume;\n            if (parent._webAudio) {\n                // Create the gain node for controlling volume (the source will connect to this).\n                self._node = typeof Howler1.ctx.createGain === \"undefined\" ? Howler1.ctx.createGainNode() : Howler1.ctx.createGain();\n                self._node.gain.setValueAtTime(volume, Howler1.ctx.currentTime);\n                self._node.paused = true;\n                self._node.connect(Howler1.masterGain);\n            } else if (!Howler1.noAudio) {\n                // Get an unlocked Audio object from the pool.\n                self._node = Howler1._obtainHtml5Audio();\n                // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).\n                self._errorFn = self._errorListener.bind(self);\n                self._node.addEventListener(\"error\", self._errorFn, false);\n                // Listen for 'canplaythrough' event to let us know the sound is ready.\n                self._loadFn = self._loadListener.bind(self);\n                self._node.addEventListener(Howler1._canPlayEvent, self._loadFn, false);\n                // Listen for the 'ended' event on the sound to account for edge-case where\n                // a finite sound has a duration of Infinity.\n                self._endFn = self._endListener.bind(self);\n                self._node.addEventListener(\"ended\", self._endFn, false);\n                // Setup the new audio node.\n                self._node.src = parent._src;\n                self._node.preload = parent._preload === true ? \"auto\" : parent._preload;\n                self._node.volume = volume * Howler1.volume();\n                // Begin loading the source.\n                self._node.load();\n            }\n            return self;\n        },\n        /**\n     * Reset the parameters of this sound to the original state (for recycle).\n     * @return {Sound}\n     */ reset: function() {\n            var self = this;\n            var parent = self._parent;\n            // Reset all of the parameters of this sound.\n            self._muted = parent._muted;\n            self._loop = parent._loop;\n            self._volume = parent._volume;\n            self._rate = parent._rate;\n            self._seek = 0;\n            self._rateSeek = 0;\n            self._paused = true;\n            self._ended = true;\n            self._sprite = \"__default\";\n            // Generate a new ID so that it isn't confused with the previous sound.\n            self._id = ++Howler1._counter;\n            return self;\n        },\n        /**\n     * HTML5 Audio error listener callback.\n     */ _errorListener: function() {\n            var self = this;\n            // Fire an error event and pass back the code.\n            self._parent._emit(\"loaderror\", self._id, self._node.error ? self._node.error.code : 0);\n            // Clear the event listener.\n            self._node.removeEventListener(\"error\", self._errorFn, false);\n        },\n        /**\n     * HTML5 Audio canplaythrough listener callback.\n     */ _loadListener: function() {\n            var self = this;\n            var parent = self._parent;\n            // Round up the duration to account for the lower precision in HTML5 Audio.\n            parent._duration = Math.ceil(self._node.duration * 10) / 10;\n            // Setup a sprite if none is defined.\n            if (Object.keys(parent._sprite).length === 0) {\n                parent._sprite = {\n                    __default: [\n                        0,\n                        parent._duration * 1000\n                    ]\n                };\n            }\n            if (parent._state !== \"loaded\") {\n                parent._state = \"loaded\";\n                parent._emit(\"load\");\n                parent._loadQueue();\n            }\n            // Clear the event listener.\n            self._node.removeEventListener(Howler1._canPlayEvent, self._loadFn, false);\n        },\n        /**\n     * HTML5 Audio ended listener callback.\n     */ _endListener: function() {\n            var self = this;\n            var parent = self._parent;\n            // Only handle the `ended`` event if the duration is Infinity.\n            if (parent._duration === Infinity) {\n                // Update the parent duration to match the real audio duration.\n                // Round up the duration to account for the lower precision in HTML5 Audio.\n                parent._duration = Math.ceil(self._node.duration * 10) / 10;\n                // Update the sprite that corresponds to the real duration.\n                if (parent._sprite.__default[1] === Infinity) {\n                    parent._sprite.__default[1] = parent._duration * 1000;\n                }\n                // Run the regular ended method.\n                parent._ended(self);\n            }\n            // Clear the event listener since the duration is now correct.\n            self._node.removeEventListener(\"ended\", self._endFn, false);\n        }\n    };\n    /** Helper Methods **/ /***************************************************************************/ var cache = {};\n    /**\n   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).\n   * @param  {Howl} self\n   */ var loadBuffer = function(self) {\n        var url = self._src;\n        // Check if the buffer has already been cached and use it instead.\n        if (cache[url]) {\n            // Set the duration from the cache.\n            self._duration = cache[url].duration;\n            // Load the sound into this Howl.\n            loadSound(self);\n            return;\n        }\n        if (/^data:[^;]+;base64,/.test(url)) {\n            // Decode the base64 data URI without XHR, since some browsers don't support it.\n            var data = atob(url.split(\",\")[1]);\n            var dataView = new Uint8Array(data.length);\n            for(var i = 0; i < data.length; ++i){\n                dataView[i] = data.charCodeAt(i);\n            }\n            decodeAudioData(dataView.buffer, self);\n        } else {\n            // Load the buffer from the URL.\n            var xhr = new XMLHttpRequest();\n            xhr.open(self._xhr.method, url, true);\n            xhr.withCredentials = self._xhr.withCredentials;\n            xhr.responseType = \"arraybuffer\";\n            // Apply any custom headers to the request.\n            if (self._xhr.headers) {\n                Object.keys(self._xhr.headers).forEach(function(key) {\n                    xhr.setRequestHeader(key, self._xhr.headers[key]);\n                });\n            }\n            xhr.onload = function() {\n                // Make sure we get a successful response back.\n                var code = (xhr.status + \"\")[0];\n                if (code !== \"0\" && code !== \"2\" && code !== \"3\") {\n                    self._emit(\"loaderror\", null, \"Failed loading audio file with status: \" + xhr.status + \".\");\n                    return;\n                }\n                decodeAudioData(xhr.response, self);\n            };\n            xhr.onerror = function() {\n                // If there is an error, switch to HTML5 Audio.\n                if (self._webAudio) {\n                    self._html5 = true;\n                    self._webAudio = false;\n                    self._sounds = [];\n                    delete cache[url];\n                    self.load();\n                }\n            };\n            safeXhrSend(xhr);\n        }\n    };\n    /**\n   * Send the XHR request wrapped in a try/catch.\n   * @param  {Object} xhr XHR to send.\n   */ var safeXhrSend = function(xhr) {\n        try {\n            xhr.send();\n        } catch (e) {\n            xhr.onerror();\n        }\n    };\n    /**\n   * Decode audio data from an array buffer.\n   * @param  {ArrayBuffer} arraybuffer The audio data.\n   * @param  {Howl}        self\n   */ var decodeAudioData = function(arraybuffer, self) {\n        // Fire a load error if something broke.\n        var error = function() {\n            self._emit(\"loaderror\", null, \"Decoding audio data failed.\");\n        };\n        // Load the sound on success.\n        var success = function(buffer) {\n            if (buffer && self._sounds.length > 0) {\n                cache[self._src] = buffer;\n                loadSound(self, buffer);\n            } else {\n                error();\n            }\n        };\n        // Decode the buffer into an audio source.\n        if (typeof Promise !== \"undefined\" && Howler1.ctx.decodeAudioData.length === 1) {\n            Howler1.ctx.decodeAudioData(arraybuffer).then(success).catch(error);\n        } else {\n            Howler1.ctx.decodeAudioData(arraybuffer, success, error);\n        }\n    };\n    /**\n   * Sound is now loaded, so finish setting everything up and fire the loaded event.\n   * @param  {Howl} self\n   * @param  {Object} buffer The decoded buffer sound source.\n   */ var loadSound = function(self, buffer) {\n        // Set the duration.\n        if (buffer && !self._duration) {\n            self._duration = buffer.duration;\n        }\n        // Setup a sprite if none is defined.\n        if (Object.keys(self._sprite).length === 0) {\n            self._sprite = {\n                __default: [\n                    0,\n                    self._duration * 1000\n                ]\n            };\n        }\n        // Fire the loaded event.\n        if (self._state !== \"loaded\") {\n            self._state = \"loaded\";\n            self._emit(\"load\");\n            self._loadQueue();\n        }\n    };\n    /**\n   * Setup the audio context when available, or switch to HTML5 Audio mode.\n   */ var setupAudioContext = function() {\n        // If we have already detected that Web Audio isn't supported, don't run this step again.\n        if (!Howler1.usingWebAudio) {\n            return;\n        }\n        // Check if we are using Web Audio and setup the AudioContext if we are.\n        try {\n            if (typeof AudioContext !== \"undefined\") {\n                Howler1.ctx = new AudioContext();\n            } else if (typeof webkitAudioContext !== \"undefined\") {\n                Howler1.ctx = new webkitAudioContext();\n            } else {\n                Howler1.usingWebAudio = false;\n            }\n        } catch (e) {\n            Howler1.usingWebAudio = false;\n        }\n        // If the audio context creation still failed, set using web audio to false.\n        if (!Howler1.ctx) {\n            Howler1.usingWebAudio = false;\n        }\n        // Check if a webview is being used on iOS8 or earlier (rather than the browser).\n        // If it is, disable Web Audio as it causes crashing.\n        var iOS = /iP(hone|od|ad)/.test(Howler1._navigator && Howler1._navigator.platform);\n        var appVersion = Howler1._navigator && Howler1._navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n        var version = appVersion ? parseInt(appVersion[1], 10) : null;\n        if (iOS && version && version < 9) {\n            var safari = /safari/.test(Howler1._navigator && Howler1._navigator.userAgent.toLowerCase());\n            if (Howler1._navigator && !safari) {\n                Howler1.usingWebAudio = false;\n            }\n        }\n        // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).\n        if (Howler1.usingWebAudio) {\n            Howler1.masterGain = typeof Howler1.ctx.createGain === \"undefined\" ? Howler1.ctx.createGainNode() : Howler1.ctx.createGain();\n            Howler1.masterGain.gain.setValueAtTime(Howler1._muted ? 0 : Howler1._volume, Howler1.ctx.currentTime);\n            Howler1.masterGain.connect(Howler1.ctx.destination);\n        }\n        // Re-run the setup on Howler.\n        Howler1._setup();\n    };\n    // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return {\n                Howler: Howler1,\n                Howl: Howl1\n            };\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n    // Add support for CommonJS libraries such as browserify.\n    if (true) {\n        exports.Howler = Howler1;\n        exports.Howl = Howl1;\n    }\n    // Add to global in Node.js (for testing, etc).\n    if (typeof __webpack_require__.g !== \"undefined\") {\n        __webpack_require__.g.HowlerGlobal = HowlerGlobal1;\n        __webpack_require__.g.Howler = Howler1;\n        __webpack_require__.g.Howl = Howl1;\n        __webpack_require__.g.Sound = Sound1;\n    } else if (true) {\n        window.HowlerGlobal = HowlerGlobal1;\n        window.Howler = Howler1;\n        window.Howl = Howl1;\n        window.Sound = Sound1;\n    }\n})();\n/*!\n *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.\n *  \n *  howler.js v2.2.4\n *  howlerjs.com\n *\n *  (c) 2013-2020, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */ (function() {\n    \"use strict\";\n    // Setup default properties.\n    HowlerGlobal.prototype._pos = [\n        0,\n        0,\n        0\n    ];\n    HowlerGlobal.prototype._orientation = [\n        0,\n        0,\n        -1,\n        0,\n        1,\n        0\n    ];\n    /** Global Methods **/ /***************************************************************************/ /**\n   * Helper method to update the stereo panning position of all current Howls.\n   * Future Howls will not use this value unless explicitly set.\n   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.\n   * @return {Howler/Number}     Self or current stereo panning value.\n   */ HowlerGlobal.prototype.stereo = function(pan) {\n        var self = this;\n        // Stop right here if not using Web Audio.\n        if (!self.ctx || !self.ctx.listener) {\n            return self;\n        }\n        // Loop through all Howls and update their stereo panning.\n        for(var i = self._howls.length - 1; i >= 0; i--){\n            self._howls[i].stereo(pan);\n        }\n        return self;\n    };\n    /**\n   * Get/set the position of the listener in 3D cartesian space. Sounds using\n   * 3D position will be relative to the listener's position.\n   * @param  {Number} x The x-position of the listener.\n   * @param  {Number} y The y-position of the listener.\n   * @param  {Number} z The z-position of the listener.\n   * @return {Howler/Array}   Self or current listener position.\n   */ HowlerGlobal.prototype.pos = function(x, y, z) {\n        var self = this;\n        // Stop right here if not using Web Audio.\n        if (!self.ctx || !self.ctx.listener) {\n            return self;\n        }\n        // Set the defaults for optional 'y' & 'z'.\n        y = typeof y !== \"number\" ? self._pos[1] : y;\n        z = typeof z !== \"number\" ? self._pos[2] : z;\n        if (typeof x === \"number\") {\n            self._pos = [\n                x,\n                y,\n                z\n            ];\n            if (typeof self.ctx.listener.positionX !== \"undefined\") {\n                self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);\n                self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);\n                self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);\n            } else {\n                self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);\n            }\n        } else {\n            return self._pos;\n        }\n        return self;\n    };\n    /**\n   * Get/set the direction the listener is pointing in the 3D cartesian space.\n   * A front and up vector must be provided. The front is the direction the\n   * face of the listener is pointing, and up is the direction the top of the\n   * listener is pointing. Thus, these values are expected to be at right angles\n   * from each other.\n   * @param  {Number} x   The x-orientation of the listener.\n   * @param  {Number} y   The y-orientation of the listener.\n   * @param  {Number} z   The z-orientation of the listener.\n   * @param  {Number} xUp The x-orientation of the top of the listener.\n   * @param  {Number} yUp The y-orientation of the top of the listener.\n   * @param  {Number} zUp The z-orientation of the top of the listener.\n   * @return {Howler/Array}     Returns self or the current orientation vectors.\n   */ HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {\n        var self = this;\n        // Stop right here if not using Web Audio.\n        if (!self.ctx || !self.ctx.listener) {\n            return self;\n        }\n        // Set the defaults for optional 'y' & 'z'.\n        var or = self._orientation;\n        y = typeof y !== \"number\" ? or[1] : y;\n        z = typeof z !== \"number\" ? or[2] : z;\n        xUp = typeof xUp !== \"number\" ? or[3] : xUp;\n        yUp = typeof yUp !== \"number\" ? or[4] : yUp;\n        zUp = typeof zUp !== \"number\" ? or[5] : zUp;\n        if (typeof x === \"number\") {\n            self._orientation = [\n                x,\n                y,\n                z,\n                xUp,\n                yUp,\n                zUp\n            ];\n            if (typeof self.ctx.listener.forwardX !== \"undefined\") {\n                self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);\n                self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);\n                self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);\n                self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);\n                self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);\n                self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);\n            } else {\n                self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);\n            }\n        } else {\n            return or;\n        }\n        return self;\n    };\n    /** Group Methods **/ /***************************************************************************/ /**\n   * Add new properties to the core init.\n   * @param  {Function} _super Core init method.\n   * @return {Howl}\n   */ Howl.prototype.init = function(_super) {\n        return function(o) {\n            var self = this;\n            // Setup user-defined default properties.\n            self._orientation = o.orientation || [\n                1,\n                0,\n                0\n            ];\n            self._stereo = o.stereo || null;\n            self._pos = o.pos || null;\n            self._pannerAttr = {\n                coneInnerAngle: typeof o.coneInnerAngle !== \"undefined\" ? o.coneInnerAngle : 360,\n                coneOuterAngle: typeof o.coneOuterAngle !== \"undefined\" ? o.coneOuterAngle : 360,\n                coneOuterGain: typeof o.coneOuterGain !== \"undefined\" ? o.coneOuterGain : 0,\n                distanceModel: typeof o.distanceModel !== \"undefined\" ? o.distanceModel : \"inverse\",\n                maxDistance: typeof o.maxDistance !== \"undefined\" ? o.maxDistance : 10000,\n                panningModel: typeof o.panningModel !== \"undefined\" ? o.panningModel : \"HRTF\",\n                refDistance: typeof o.refDistance !== \"undefined\" ? o.refDistance : 1,\n                rolloffFactor: typeof o.rolloffFactor !== \"undefined\" ? o.rolloffFactor : 1\n            };\n            // Setup event listeners.\n            self._onstereo = o.onstereo ? [\n                {\n                    fn: o.onstereo\n                }\n            ] : [];\n            self._onpos = o.onpos ? [\n                {\n                    fn: o.onpos\n                }\n            ] : [];\n            self._onorientation = o.onorientation ? [\n                {\n                    fn: o.onorientation\n                }\n            ] : [];\n            // Complete initilization with howler.js core's init function.\n            return _super.call(this, o);\n        };\n    }(Howl.prototype.init);\n    /**\n   * Get/set the stereo panning of the audio source for this sound or all in the group.\n   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Number}    Returns self or the current stereo panning value.\n   */ Howl.prototype.stereo = function(pan, id) {\n        var self = this;\n        // Stop right here if not using Web Audio.\n        if (!self._webAudio) {\n            return self;\n        }\n        // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.\n        if (self._state !== \"loaded\") {\n            self._queue.push({\n                event: \"stereo\",\n                action: function() {\n                    self.stereo(pan, id);\n                }\n            });\n            return self;\n        }\n        // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.\n        var pannerType = typeof Howler.ctx.createStereoPanner === \"undefined\" ? \"spatial\" : \"stereo\";\n        // Setup the group's stereo panning if no ID is passed.\n        if (typeof id === \"undefined\") {\n            // Return the group's stereo panning if no parameters are passed.\n            if (typeof pan === \"number\") {\n                self._stereo = pan;\n                self._pos = [\n                    pan,\n                    0,\n                    0\n                ];\n            } else {\n                return self._stereo;\n            }\n        }\n        // Change the streo panning of one or all sounds in group.\n        var ids = self._getSoundIds(id);\n        for(var i = 0; i < ids.length; i++){\n            // Get the sound.\n            var sound = self._soundById(ids[i]);\n            if (sound) {\n                if (typeof pan === \"number\") {\n                    sound._stereo = pan;\n                    sound._pos = [\n                        pan,\n                        0,\n                        0\n                    ];\n                    if (sound._node) {\n                        // If we are falling back, make sure the panningModel is equalpower.\n                        sound._pannerAttr.panningModel = \"equalpower\";\n                        // Check if there is a panner setup and create a new one if not.\n                        if (!sound._panner || !sound._panner.pan) {\n                            setupPanner(sound, pannerType);\n                        }\n                        if (pannerType === \"spatial\") {\n                            if (typeof sound._panner.positionX !== \"undefined\") {\n                                sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);\n                                sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);\n                                sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);\n                            } else {\n                                sound._panner.setPosition(pan, 0, 0);\n                            }\n                        } else {\n                            sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);\n                        }\n                    }\n                    self._emit(\"stereo\", sound._id);\n                } else {\n                    return sound._stereo;\n                }\n            }\n        }\n        return self;\n    };\n    /**\n   * Get/set the 3D spatial position of the audio source for this sound or group relative to the global listener.\n   * @param  {Number} x  The x-position of the audio source.\n   * @param  {Number} y  The y-position of the audio source.\n   * @param  {Number} z  The z-position of the audio source.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].\n   */ Howl.prototype.pos = function(x, y, z, id) {\n        var self = this;\n        // Stop right here if not using Web Audio.\n        if (!self._webAudio) {\n            return self;\n        }\n        // If the sound hasn't loaded, add it to the load queue to change position when capable.\n        if (self._state !== \"loaded\") {\n            self._queue.push({\n                event: \"pos\",\n                action: function() {\n                    self.pos(x, y, z, id);\n                }\n            });\n            return self;\n        }\n        // Set the defaults for optional 'y' & 'z'.\n        y = typeof y !== \"number\" ? 0 : y;\n        z = typeof z !== \"number\" ? -0.5 : z;\n        // Setup the group's spatial position if no ID is passed.\n        if (typeof id === \"undefined\") {\n            // Return the group's spatial position if no parameters are passed.\n            if (typeof x === \"number\") {\n                self._pos = [\n                    x,\n                    y,\n                    z\n                ];\n            } else {\n                return self._pos;\n            }\n        }\n        // Change the spatial position of one or all sounds in group.\n        var ids = self._getSoundIds(id);\n        for(var i = 0; i < ids.length; i++){\n            // Get the sound.\n            var sound = self._soundById(ids[i]);\n            if (sound) {\n                if (typeof x === \"number\") {\n                    sound._pos = [\n                        x,\n                        y,\n                        z\n                    ];\n                    if (sound._node) {\n                        // Check if there is a panner setup and create a new one if not.\n                        if (!sound._panner || sound._panner.pan) {\n                            setupPanner(sound, \"spatial\");\n                        }\n                        if (typeof sound._panner.positionX !== \"undefined\") {\n                            sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);\n                            sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);\n                            sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);\n                        } else {\n                            sound._panner.setPosition(x, y, z);\n                        }\n                    }\n                    self._emit(\"pos\", sound._id);\n                } else {\n                    return sound._pos;\n                }\n            }\n        }\n        return self;\n    };\n    /**\n   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate\n   * space. Depending on how direction the sound is, based on the `cone` attributes,\n   * a sound pointing away from the listener can be quiet or silent.\n   * @param  {Number} x  The x-orientation of the source.\n   * @param  {Number} y  The y-orientation of the source.\n   * @param  {Number} z  The z-orientation of the source.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].\n   */ Howl.prototype.orientation = function(x, y, z, id) {\n        var self = this;\n        // Stop right here if not using Web Audio.\n        if (!self._webAudio) {\n            return self;\n        }\n        // If the sound hasn't loaded, add it to the load queue to change orientation when capable.\n        if (self._state !== \"loaded\") {\n            self._queue.push({\n                event: \"orientation\",\n                action: function() {\n                    self.orientation(x, y, z, id);\n                }\n            });\n            return self;\n        }\n        // Set the defaults for optional 'y' & 'z'.\n        y = typeof y !== \"number\" ? self._orientation[1] : y;\n        z = typeof z !== \"number\" ? self._orientation[2] : z;\n        // Setup the group's spatial orientation if no ID is passed.\n        if (typeof id === \"undefined\") {\n            // Return the group's spatial orientation if no parameters are passed.\n            if (typeof x === \"number\") {\n                self._orientation = [\n                    x,\n                    y,\n                    z\n                ];\n            } else {\n                return self._orientation;\n            }\n        }\n        // Change the spatial orientation of one or all sounds in group.\n        var ids = self._getSoundIds(id);\n        for(var i = 0; i < ids.length; i++){\n            // Get the sound.\n            var sound = self._soundById(ids[i]);\n            if (sound) {\n                if (typeof x === \"number\") {\n                    sound._orientation = [\n                        x,\n                        y,\n                        z\n                    ];\n                    if (sound._node) {\n                        // Check if there is a panner setup and create a new one if not.\n                        if (!sound._panner) {\n                            // Make sure we have a position to setup the node with.\n                            if (!sound._pos) {\n                                sound._pos = self._pos || [\n                                    0,\n                                    0,\n                                    -0.5\n                                ];\n                            }\n                            setupPanner(sound, \"spatial\");\n                        }\n                        if (typeof sound._panner.orientationX !== \"undefined\") {\n                            sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);\n                            sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);\n                            sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);\n                        } else {\n                            sound._panner.setOrientation(x, y, z);\n                        }\n                    }\n                    self._emit(\"orientation\", sound._id);\n                } else {\n                    return sound._orientation;\n                }\n            }\n        }\n        return self;\n    };\n    /**\n   * Get/set the panner node's attributes for a sound or group of sounds.\n   * This method can optionall take 0, 1 or 2 arguments.\n   *   pannerAttr() -> Returns the group's values.\n   *   pannerAttr(id) -> Returns the sound id's values.\n   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.\n   *   pannerAttr(o, id) -> Set's the values of passed sound id.\n   *\n   *   Attributes:\n   *     coneInnerAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,\n   *                      inside of which there will be no volume reduction.\n   *     coneOuterAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,\n   *                      outside of which the volume will be reduced to a constant value of `coneOuterGain`.\n   *     coneOuterGain - (0 by default) A parameter for directional audio sources, this is the gain outside of the\n   *                     `coneOuterAngle`. It is a linear value in the range `[0, 1]`.\n   *     distanceModel - ('inverse' by default) Determines algorithm used to reduce volume as audio moves away from\n   *                     listener. Can be `linear`, `inverse` or `exponential.\n   *     maxDistance - (10000 by default) The maximum distance between source and listener, after which the volume\n   *                   will not be reduced any further.\n   *     refDistance - (1 by default) A reference distance for reducing volume as source moves further from the listener.\n   *                   This is simply a variable of the distance model and has a different effect depending on which model\n   *                   is used and the scale of your coordinates. Generally, volume will be equal to 1 at this distance.\n   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener. This is simply a\n   *                     variable of the distance model and can be in the range of `[0, 1]` with `linear` and `[0, ∞]`\n   *                     with `inverse` and `exponential`.\n   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.\n   *                     Can be `HRTF` or `equalpower`.\n   *\n   * @return {Howl/Object} Returns self or current panner attributes.\n   */ Howl.prototype.pannerAttr = function() {\n        var self = this;\n        var args = arguments;\n        var o, id, sound;\n        // Stop right here if not using Web Audio.\n        if (!self._webAudio) {\n            return self;\n        }\n        // Determine the values based on arguments.\n        if (args.length === 0) {\n            // Return the group's panner attribute values.\n            return self._pannerAttr;\n        } else if (args.length === 1) {\n            if (typeof args[0] === \"object\") {\n                o = args[0];\n                // Set the grou's panner attribute values.\n                if (typeof id === \"undefined\") {\n                    if (!o.pannerAttr) {\n                        o.pannerAttr = {\n                            coneInnerAngle: o.coneInnerAngle,\n                            coneOuterAngle: o.coneOuterAngle,\n                            coneOuterGain: o.coneOuterGain,\n                            distanceModel: o.distanceModel,\n                            maxDistance: o.maxDistance,\n                            refDistance: o.refDistance,\n                            rolloffFactor: o.rolloffFactor,\n                            panningModel: o.panningModel\n                        };\n                    }\n                    self._pannerAttr = {\n                        coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== \"undefined\" ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,\n                        coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== \"undefined\" ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,\n                        coneOuterGain: typeof o.pannerAttr.coneOuterGain !== \"undefined\" ? o.pannerAttr.coneOuterGain : self._coneOuterGain,\n                        distanceModel: typeof o.pannerAttr.distanceModel !== \"undefined\" ? o.pannerAttr.distanceModel : self._distanceModel,\n                        maxDistance: typeof o.pannerAttr.maxDistance !== \"undefined\" ? o.pannerAttr.maxDistance : self._maxDistance,\n                        refDistance: typeof o.pannerAttr.refDistance !== \"undefined\" ? o.pannerAttr.refDistance : self._refDistance,\n                        rolloffFactor: typeof o.pannerAttr.rolloffFactor !== \"undefined\" ? o.pannerAttr.rolloffFactor : self._rolloffFactor,\n                        panningModel: typeof o.pannerAttr.panningModel !== \"undefined\" ? o.pannerAttr.panningModel : self._panningModel\n                    };\n                }\n            } else {\n                // Return this sound's panner attribute values.\n                sound = self._soundById(parseInt(args[0], 10));\n                return sound ? sound._pannerAttr : self._pannerAttr;\n            }\n        } else if (args.length === 2) {\n            o = args[0];\n            id = parseInt(args[1], 10);\n        }\n        // Update the values of the specified sounds.\n        var ids = self._getSoundIds(id);\n        for(var i = 0; i < ids.length; i++){\n            sound = self._soundById(ids[i]);\n            if (sound) {\n                // Merge the new values into the sound.\n                var pa = sound._pannerAttr;\n                pa = {\n                    coneInnerAngle: typeof o.coneInnerAngle !== \"undefined\" ? o.coneInnerAngle : pa.coneInnerAngle,\n                    coneOuterAngle: typeof o.coneOuterAngle !== \"undefined\" ? o.coneOuterAngle : pa.coneOuterAngle,\n                    coneOuterGain: typeof o.coneOuterGain !== \"undefined\" ? o.coneOuterGain : pa.coneOuterGain,\n                    distanceModel: typeof o.distanceModel !== \"undefined\" ? o.distanceModel : pa.distanceModel,\n                    maxDistance: typeof o.maxDistance !== \"undefined\" ? o.maxDistance : pa.maxDistance,\n                    refDistance: typeof o.refDistance !== \"undefined\" ? o.refDistance : pa.refDistance,\n                    rolloffFactor: typeof o.rolloffFactor !== \"undefined\" ? o.rolloffFactor : pa.rolloffFactor,\n                    panningModel: typeof o.panningModel !== \"undefined\" ? o.panningModel : pa.panningModel\n                };\n                // Create a new panner node if one doesn't already exist.\n                var panner = sound._panner;\n                if (!panner) {\n                    // Make sure we have a position to setup the node with.\n                    if (!sound._pos) {\n                        sound._pos = self._pos || [\n                            0,\n                            0,\n                            -0.5\n                        ];\n                    }\n                    // Create a new panner node.\n                    setupPanner(sound, \"spatial\");\n                    panner = sound._panner;\n                }\n                // Update the panner values or create a new panner if none exists.\n                panner.coneInnerAngle = pa.coneInnerAngle;\n                panner.coneOuterAngle = pa.coneOuterAngle;\n                panner.coneOuterGain = pa.coneOuterGain;\n                panner.distanceModel = pa.distanceModel;\n                panner.maxDistance = pa.maxDistance;\n                panner.refDistance = pa.refDistance;\n                panner.rolloffFactor = pa.rolloffFactor;\n                panner.panningModel = pa.panningModel;\n            }\n        }\n        return self;\n    };\n    /** Single Sound Methods **/ /***************************************************************************/ /**\n   * Add new properties to the core Sound init.\n   * @param  {Function} _super Core Sound init method.\n   * @return {Sound}\n   */ Sound.prototype.init = function(_super) {\n        return function() {\n            var self = this;\n            var parent = self._parent;\n            // Setup user-defined default properties.\n            self._orientation = parent._orientation;\n            self._stereo = parent._stereo;\n            self._pos = parent._pos;\n            self._pannerAttr = parent._pannerAttr;\n            // Complete initilization with howler.js core Sound's init function.\n            _super.call(this);\n            // If a stereo or position was specified, set it up.\n            if (self._stereo) {\n                parent.stereo(self._stereo);\n            } else if (self._pos) {\n                parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);\n            }\n        };\n    }(Sound.prototype.init);\n    /**\n   * Override the Sound.reset method to clean up properties from the spatial plugin.\n   * @param  {Function} _super Sound reset method.\n   * @return {Sound}\n   */ Sound.prototype.reset = function(_super) {\n        return function() {\n            var self = this;\n            var parent = self._parent;\n            // Reset all spatial plugin properties on this sound.\n            self._orientation = parent._orientation;\n            self._stereo = parent._stereo;\n            self._pos = parent._pos;\n            self._pannerAttr = parent._pannerAttr;\n            // If a stereo or position was specified, set it up.\n            if (self._stereo) {\n                parent.stereo(self._stereo);\n            } else if (self._pos) {\n                parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);\n            } else if (self._panner) {\n                // Disconnect the panner.\n                self._panner.disconnect(0);\n                self._panner = undefined;\n                parent._refreshBuffer(self);\n            }\n            // Complete resetting of the sound.\n            return _super.call(this);\n        };\n    }(Sound.prototype.reset);\n    /** Helper Methods **/ /***************************************************************************/ /**\n   * Create a new panner node and save it on the sound.\n   * @param  {Sound} sound Specific sound to setup panning on.\n   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.\n   */ var setupPanner = function(sound, type) {\n        type = type || \"spatial\";\n        // Create the new panner node.\n        if (type === \"spatial\") {\n            sound._panner = Howler.ctx.createPanner();\n            sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;\n            sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;\n            sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;\n            sound._panner.distanceModel = sound._pannerAttr.distanceModel;\n            sound._panner.maxDistance = sound._pannerAttr.maxDistance;\n            sound._panner.refDistance = sound._pannerAttr.refDistance;\n            sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;\n            sound._panner.panningModel = sound._pannerAttr.panningModel;\n            if (typeof sound._panner.positionX !== \"undefined\") {\n                sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);\n                sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);\n                sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);\n            } else {\n                sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);\n            }\n            if (typeof sound._panner.orientationX !== \"undefined\") {\n                sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);\n                sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);\n                sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);\n            } else {\n                sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);\n            }\n        } else {\n            sound._panner = Howler.ctx.createStereoPanner();\n            sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);\n        }\n        sound._panner.connect(sound._node);\n        // Update the connections.\n        if (!sound._paused) {\n            sound._parent.pause(sound._id, true).play(sound._id, true);\n        }\n    };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ob3dsZXIvZGlzdC9ob3dsZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0NBUUMsR0FFQTtJQUVDO0lBRUEsb0JBQW9CLEdBQ3BCLDJFQUEyRSxHQUUzRTs7O0dBR0MsR0FDRCxJQUFJQSxnQkFBZTtRQUNqQixJQUFJLENBQUNDLElBQUk7SUFDWDtJQUNBRCxjQUFhRSxTQUFTLEdBQUc7UUFDdkI7OztLQUdDLEdBQ0RELE1BQU07WUFDSixJQUFJRSxPQUFPLElBQUksSUFBSUM7WUFFbkIsOEJBQThCO1lBQzlCRCxLQUFLRSxRQUFRLEdBQUc7WUFFaEIsd0NBQXdDO1lBQ3hDRixLQUFLRyxlQUFlLEdBQUcsRUFBRTtZQUN6QkgsS0FBS0ksYUFBYSxHQUFHO1lBRXJCLHVCQUF1QjtZQUN2QkosS0FBS0ssT0FBTyxHQUFHLENBQUM7WUFDaEJMLEtBQUtNLE1BQU0sR0FBRyxFQUFFO1lBQ2hCTixLQUFLTyxNQUFNLEdBQUc7WUFDZFAsS0FBS1EsT0FBTyxHQUFHO1lBQ2ZSLEtBQUtTLGFBQWEsR0FBRztZQUNyQlQsS0FBS1UsVUFBVSxHQUFHLEtBQW1CLElBQWVDLE9BQU9DLFNBQVMsR0FBSUQsT0FBT0MsU0FBUyxHQUFHO1lBRTNGLHFCQUFxQjtZQUNyQlosS0FBS2EsVUFBVSxHQUFHO1lBQ2xCYixLQUFLYyxPQUFPLEdBQUc7WUFDZmQsS0FBS2UsYUFBYSxHQUFHO1lBQ3JCZixLQUFLZ0IsV0FBVyxHQUFHO1lBQ25CaEIsS0FBS2lCLEdBQUcsR0FBRztZQUVYLG1EQUFtRDtZQUNuRGpCLEtBQUtrQixVQUFVLEdBQUc7WUFFbEIsc0RBQXNEO1lBQ3REbEIsS0FBS21CLE1BQU07WUFFWCxPQUFPbkI7UUFDVDtRQUVBOzs7O0tBSUMsR0FDRG9CLFFBQVEsU0FBU0MsR0FBRztZQUNsQixJQUFJckIsT0FBTyxJQUFJLElBQUlDO1lBQ25Cb0IsTUFBTUMsV0FBV0Q7WUFFakIsK0RBQStEO1lBQy9ELElB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QVc7WUFDekYsT0FBTztnQkFDTE8sTUFBTXdRLE9BQU8sQ0FBQ3VFLGNBQWMsQ0FBQy9VLE1BQU13VCxZQUFZLENBQUMsRUFBRSxFQUFFeFQsTUFBTXdULFlBQVksQ0FBQyxFQUFFLEVBQUV4VCxNQUFNd1QsWUFBWSxDQUFDLEVBQUU7WUFDbEc7UUFDRixPQUFPO1lBQ0x4VCxNQUFNd1EsT0FBTyxHQUFHeFMsT0FBT2dCLEdBQUcsQ0FBQ2tYLGtCQUFrQjtZQUM3Q2xXLE1BQU13USxPQUFPLENBQUNrRCxHQUFHLENBQUNsVSxjQUFjLENBQUNRLE1BQU1pVixPQUFPLEVBQUVqWCxPQUFPZ0IsR0FBRyxDQUFDUyxXQUFXO1FBQ3hFO1FBRUFPLE1BQU13USxPQUFPLENBQUN6TSxPQUFPLENBQUMvRCxNQUFNRSxLQUFLO1FBRWpDLDBCQUEwQjtRQUMxQixJQUFJLENBQUNGLE1BQU11RixPQUFPLEVBQUU7WUFDbEJ2RixNQUFNNlEsT0FBTyxDQUFDckUsS0FBSyxDQUFDeE0sTUFBTXdLLEdBQUcsRUFBRSxNQUFNM0YsSUFBSSxDQUFDN0UsTUFBTXdLLEdBQUcsRUFBRTtRQUN2RDtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2hvd2xlci9kaXN0L2hvd2xlci5qcz8zZmI2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogIGhvd2xlci5qcyB2Mi4yLjRcbiAqICBob3dsZXJqcy5jb21cbiAqXG4gKiAgKGMpIDIwMTMtMjAyMCwgSmFtZXMgU2ltcHNvbiBvZiBHb2xkRmlyZSBTdHVkaW9zXG4gKiAgZ29sZGZpcmVzdHVkaW9zLmNvbVxuICpcbiAqICBNSVQgTGljZW5zZVxuICovXG5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqIEdsb2JhbCBNZXRob2RzICoqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGdsb2JhbCBjb250cm9sbGVyLiBBbGwgY29udGFpbmVkIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgYXBwbHlcbiAgICogdG8gYWxsIHNvdW5kcyB0aGF0IGFyZSBjdXJyZW50bHkgcGxheWluZyBvciB3aWxsIGJlIGluIHRoZSBmdXR1cmUuXG4gICAqL1xuICB2YXIgSG93bGVyR2xvYmFsID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbml0KCk7XG4gIH07XG4gIEhvd2xlckdsb2JhbC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgZ2xvYmFsIEhvd2xlciBvYmplY3QuXG4gICAgICogQHJldHVybiB7SG93bGVyfVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcblxuICAgICAgLy8gQ3JlYXRlIGEgZ2xvYmFsIElEIGNvdW50ZXIuXG4gICAgICBzZWxmLl9jb3VudGVyID0gMTAwMDtcblxuICAgICAgLy8gUG9vbCBvZiB1bmxvY2tlZCBIVE1MNSBBdWRpbyBvYmplY3RzLlxuICAgICAgc2VsZi5faHRtbDVBdWRpb1Bvb2wgPSBbXTtcbiAgICAgIHNlbGYuaHRtbDVQb29sU2l6ZSA9IDEwO1xuXG4gICAgICAvLyBJbnRlcm5hbCBwcm9wZXJ0aWVzLlxuICAgICAgc2VsZi5fY29kZWNzID0ge307XG4gICAgICBzZWxmLl9ob3dscyA9IFtdO1xuICAgICAgc2VsZi5fbXV0ZWQgPSBmYWxzZTtcbiAgICAgIHNlbGYuX3ZvbHVtZSA9IDE7XG4gICAgICBzZWxmLl9jYW5QbGF5RXZlbnQgPSAnY2FucGxheXRocm91Z2gnO1xuICAgICAgc2VsZi5fbmF2aWdhdG9yID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5uYXZpZ2F0b3IpID8gd2luZG93Lm5hdmlnYXRvciA6IG51bGw7XG5cbiAgICAgIC8vIFB1YmxpYyBwcm9wZXJ0aWVzLlxuICAgICAgc2VsZi5tYXN0ZXJHYWluID0gbnVsbDtcbiAgICAgIHNlbGYubm9BdWRpbyA9IGZhbHNlO1xuICAgICAgc2VsZi51c2luZ1dlYkF1ZGlvID0gdHJ1ZTtcbiAgICAgIHNlbGYuYXV0b1N1c3BlbmQgPSB0cnVlO1xuICAgICAgc2VsZi5jdHggPSBudWxsO1xuXG4gICAgICAvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGUgYXV0byBhdWRpbyB1bmxvY2tlci5cbiAgICAgIHNlbGYuYXV0b1VubG9jayA9IHRydWU7XG5cbiAgICAgIC8vIFNldHVwIHRoZSB2YXJpb3VzIHN0YXRlIHZhbHVlcyBmb3IgZ2xvYmFsIHRyYWNraW5nLlxuICAgICAgc2VsZi5fc2V0dXAoKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldC9zZXQgdGhlIGdsb2JhbCB2b2x1bWUgZm9yIGFsbCBzb3VuZHMuXG4gICAgICogQHBhcmFtICB7RmxvYXR9IHZvbCBWb2x1bWUgZnJvbSAwLjAgdG8gMS4wLlxuICAgICAqIEByZXR1cm4ge0hvd2xlci9GbG9hdH0gICAgIFJldHVybnMgc2VsZiBvciBjdXJyZW50IHZvbHVtZS5cbiAgICAgKi9cbiAgICB2b2x1bWU6IGZ1bmN0aW9uKHZvbCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcbiAgICAgIHZvbCA9IHBhcnNlRmxvYXQodm9sKTtcblxuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbiBBdWRpb0NvbnRleHQgY3JlYXRlZCB5ZXQsIHJ1biB0aGUgc2V0dXAuXG4gICAgICBpZiAoIXNlbGYuY3R4KSB7XG4gICAgICAgIHNldHVwQXVkaW9Db250ZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygdm9sICE9PSAndW5kZWZpbmVkJyAmJiB2b2wgPj0gMCAmJiB2b2wgPD0gMSkge1xuICAgICAgICBzZWxmLl92b2x1bWUgPSB2b2w7XG5cbiAgICAgICAgLy8gRG9uJ3QgdXBkYXRlIGFueSBvZiB0aGUgbm9kZXMgaWYgd2UgYXJlIG11dGVkLlxuICAgICAgICBpZiAoc2VsZi5fbXV0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdoZW4gdXNpbmcgV2ViIEF1ZGlvLCB3ZSBqdXN0IG5lZWQgdG8gYWRqdXN0IHRoZSBtYXN0ZXIgZ2Fpbi5cbiAgICAgICAgaWYgKHNlbGYudXNpbmdXZWJBdWRpbykge1xuICAgICAgICAgIHNlbGYubWFzdGVyR2Fpbi5nYWluLnNldFZhbHVlQXRUaW1lKHZvbCwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggYW5kIGNoYW5nZSB2b2x1bWUgZm9yIGFsbCBIVE1MNSBhdWRpbyBub2Rlcy5cbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX2hvd2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFzZWxmLl9ob3dsc1tpXS5fd2ViQXVkaW8pIHtcbiAgICAgICAgICAgIC8vIEdldCBhbGwgb2YgdGhlIHNvdW5kcyBpbiB0aGlzIEhvd2wgZ3JvdXAuXG4gICAgICAgICAgICB2YXIgaWRzID0gc2VsZi5faG93bHNbaV0uX2dldFNvdW5kSWRzKCk7XG5cbiAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgc291bmRzIGFuZCBjaGFuZ2UgdGhlIHZvbHVtZXMuXG4gICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8aWRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBzb3VuZCA9IHNlbGYuX2hvd2xzW2ldLl9zb3VuZEJ5SWQoaWRzW2pdKTtcblxuICAgICAgICAgICAgICBpZiAoc291bmQgJiYgc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgICAgICBzb3VuZC5fbm9kZS52b2x1bWUgPSBzb3VuZC5fdm9sdW1lICogdm9sO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLl92b2x1bWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBtdXRpbmcgYW5kIHVubXV0aW5nIGdsb2JhbGx5LlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IG11dGVkIElzIG11dGVkIG9yIG5vdC5cbiAgICAgKi9cbiAgICBtdXRlOiBmdW5jdGlvbihtdXRlZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcblxuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbiBBdWRpb0NvbnRleHQgY3JlYXRlZCB5ZXQsIHJ1biB0aGUgc2V0dXAuXG4gICAgICBpZiAoIXNlbGYuY3R4KSB7XG4gICAgICAgIHNldHVwQXVkaW9Db250ZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuX211dGVkID0gbXV0ZWQ7XG5cbiAgICAgIC8vIFdpdGggV2ViIEF1ZGlvLCB3ZSBqdXN0IG5lZWQgdG8gbXV0ZSB0aGUgbWFzdGVyIGdhaW4uXG4gICAgICBpZiAoc2VsZi51c2luZ1dlYkF1ZGlvKSB7XG4gICAgICAgIHNlbGYubWFzdGVyR2Fpbi5nYWluLnNldFZhbHVlQXRUaW1lKG11dGVkID8gMCA6IHNlbGYuX3ZvbHVtZSwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIExvb3AgdGhyb3VnaCBhbmQgbXV0ZSBhbGwgSFRNTDUgQXVkaW8gbm9kZXMuXG4gICAgICBmb3IgKHZhciBpPTA7IGk8c2VsZi5faG93bHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFzZWxmLl9ob3dsc1tpXS5fd2ViQXVkaW8pIHtcbiAgICAgICAgICAvLyBHZXQgYWxsIG9mIHRoZSBzb3VuZHMgaW4gdGhpcyBIb3dsIGdyb3VwLlxuICAgICAgICAgIHZhciBpZHMgPSBzZWxmLl9ob3dsc1tpXS5fZ2V0U291bmRJZHMoKTtcblxuICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgc291bmRzIGFuZCBtYXJrIHRoZSBhdWRpbyBub2RlIGFzIG11dGVkLlxuICAgICAgICAgIGZvciAodmFyIGo9MDsgajxpZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBzb3VuZCA9IHNlbGYuX2hvd2xzW2ldLl9zb3VuZEJ5SWQoaWRzW2pdKTtcblxuICAgICAgICAgICAgaWYgKHNvdW5kICYmIHNvdW5kLl9ub2RlKSB7XG4gICAgICAgICAgICAgIHNvdW5kLl9ub2RlLm11dGVkID0gKG11dGVkKSA/IHRydWUgOiBzb3VuZC5fbXV0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgc3RvcHBpbmcgYWxsIHNvdW5kcyBnbG9iYWxseS5cbiAgICAgKi9cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyB8fCBIb3dsZXI7XG5cbiAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgSG93bHMgYW5kIHN0b3AgdGhlbS5cbiAgICAgIGZvciAodmFyIGk9MDsgaTxzZWxmLl9ob3dscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLl9ob3dsc1tpXS5zdG9wKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbmxvYWQgYW5kIGRlc3Ryb3kgYWxsIGN1cnJlbnRseSBsb2FkZWQgSG93bCBvYmplY3RzLlxuICAgICAqIEByZXR1cm4ge0hvd2xlcn1cbiAgICAgKi9cbiAgICB1bmxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcblxuICAgICAgZm9yICh2YXIgaT1zZWxmLl9ob3dscy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgIHNlbGYuX2hvd2xzW2ldLnVubG9hZCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgQXVkaW9Db250ZXh0IHRvIG1ha2Ugc3VyZSBpdCBpcyBmdWxseSByZXNldC5cbiAgICAgIGlmIChzZWxmLnVzaW5nV2ViQXVkaW8gJiYgc2VsZi5jdHggJiYgdHlwZW9mIHNlbGYuY3R4LmNsb3NlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzZWxmLmN0eC5jbG9zZSgpO1xuICAgICAgICBzZWxmLmN0eCA9IG51bGw7XG4gICAgICAgIHNldHVwQXVkaW9Db250ZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBmb3IgY29kZWMgc3VwcG9ydCBvZiBzcGVjaWZpYyBleHRlbnNpb24uXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBleHQgQXVkaW8gZmlsZSBleHRlbnRpb24uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBjb2RlY3M6IGZ1bmN0aW9uKGV4dCkge1xuICAgICAgcmV0dXJuICh0aGlzIHx8IEhvd2xlcikuX2NvZGVjc1tleHQucmVwbGFjZSgvXngtLywgJycpXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0dXAgdmFyaW91cyBzdGF0ZSB2YWx1ZXMgZm9yIGdsb2JhbCB0cmFja2luZy5cbiAgICAgKiBAcmV0dXJuIHtIb3dsZXJ9XG4gICAgICovXG4gICAgX3NldHVwOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyB8fCBIb3dsZXI7XG5cbiAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBzdXNwZW5kL3Jlc3VtZSBzdGF0ZSBvZiB0aGUgQXVkaW9Db250ZXh0LlxuICAgICAgc2VsZi5zdGF0ZSA9IHNlbGYuY3R4ID8gc2VsZi5jdHguc3RhdGUgfHwgJ3N1c3BlbmRlZCcgOiAnc3VzcGVuZGVkJztcblxuICAgICAgLy8gQXV0b21hdGljYWxseSBiZWdpbiB0aGUgMzAtc2Vjb25kIHN1c3BlbmQgcHJvY2Vzc1xuICAgICAgc2VsZi5fYXV0b1N1c3BlbmQoKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgYXVkaW8gaXMgYXZhaWxhYmxlLlxuICAgICAgaWYgKCFzZWxmLnVzaW5nV2ViQXVkaW8pIHtcbiAgICAgICAgLy8gTm8gYXVkaW8gaXMgYXZhaWxhYmxlIG9uIHRoaXMgc3lzdGVtIGlmIG5vQXVkaW8gaXMgc2V0IHRvIHRydWUuXG4gICAgICAgIGlmICh0eXBlb2YgQXVkaW8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB0ZXN0ID0gbmV3IEF1ZGlvKCk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjYW5wbGF5dGhyb3VnaCBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRlc3Qub25jYW5wbGF5dGhyb3VnaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgc2VsZi5fY2FuUGxheUV2ZW50ID0gJ2NhbnBsYXknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgc2VsZi5ub0F1ZGlvID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5ub0F1ZGlvID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUZXN0IHRvIG1ha2Ugc3VyZSBhdWRpbyBpc24ndCBkaXNhYmxlZCBpbiBJbnRlcm5ldCBFeHBsb3Jlci5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB0ZXN0ID0gbmV3IEF1ZGlvKCk7XG4gICAgICAgIGlmICh0ZXN0Lm11dGVkKSB7XG4gICAgICAgICAgc2VsZi5ub0F1ZGlvID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgLy8gQ2hlY2sgZm9yIHN1cHBvcnRlZCBjb2RlY3MuXG4gICAgICBpZiAoIXNlbGYubm9BdWRpbykge1xuICAgICAgICBzZWxmLl9zZXR1cENvZGVjcygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgZm9yIGJyb3dzZXIgc3VwcG9ydCBmb3IgdmFyaW91cyBjb2RlY3MgYW5kIGNhY2hlIHRoZSByZXN1bHRzLlxuICAgICAqIEByZXR1cm4ge0hvd2xlcn1cbiAgICAgKi9cbiAgICBfc2V0dXBDb2RlY3M6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcbiAgICAgIHZhciBhdWRpb1Rlc3QgPSBudWxsO1xuXG4gICAgICAvLyBNdXN0IHdyYXAgaW4gYSB0cnkvY2F0Y2ggYmVjYXVzZSBJRTExIGluIHNlcnZlciBtb2RlIHRocm93cyBhbiBlcnJvci5cbiAgICAgIHRyeSB7XG4gICAgICAgIGF1ZGlvVGVzdCA9ICh0eXBlb2YgQXVkaW8gIT09ICd1bmRlZmluZWQnKSA/IG5ldyBBdWRpbygpIDogbnVsbDtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhdWRpb1Rlc3QgfHwgdHlwZW9mIGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIG1wZWdUZXN0ID0gYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9tcGVnOycpLnJlcGxhY2UoL15ubyQvLCAnJyk7XG5cbiAgICAgIC8vIE9wZXJhIHZlcnNpb24gPDMzIGhhcyBtaXhlZCBNUDMgc3VwcG9ydCwgc28gd2UgbmVlZCB0byBjaGVjayBmb3IgYW5kIGJsb2NrIGl0LlxuICAgICAgdmFyIHVhID0gc2VsZi5fbmF2aWdhdG9yID8gc2VsZi5fbmF2aWdhdG9yLnVzZXJBZ2VudCA6ICcnO1xuICAgICAgdmFyIGNoZWNrT3BlcmEgPSB1YS5tYXRjaCgvT1BSXFwvKFxcZCspL2cpO1xuICAgICAgdmFyIGlzT2xkT3BlcmEgPSAoY2hlY2tPcGVyYSAmJiBwYXJzZUludChjaGVja09wZXJhWzBdLnNwbGl0KCcvJylbMV0sIDEwKSA8IDMzKTtcbiAgICAgIHZhciBjaGVja1NhZmFyaSA9IHVhLmluZGV4T2YoJ1NhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTE7XG4gICAgICB2YXIgc2FmYXJpVmVyc2lvbiA9IHVhLm1hdGNoKC9WZXJzaW9uXFwvKC4qPykgLyk7XG4gICAgICB2YXIgaXNPbGRTYWZhcmkgPSAoY2hlY2tTYWZhcmkgJiYgc2FmYXJpVmVyc2lvbiAmJiBwYXJzZUludChzYWZhcmlWZXJzaW9uWzFdLCAxMCkgPCAxNSk7XG5cbiAgICAgIHNlbGYuX2NvZGVjcyA9IHtcbiAgICAgICAgbXAzOiAhISghaXNPbGRPcGVyYSAmJiAobXBlZ1Rlc3QgfHwgYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9tcDM7JykucmVwbGFjZSgvXm5vJC8sICcnKSkpLFxuICAgICAgICBtcGVnOiAhIW1wZWdUZXN0LFxuICAgICAgICBvcHVzOiAhIWF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vb2dnOyBjb2RlY3M9XCJvcHVzXCInKS5yZXBsYWNlKC9ebm8kLywgJycpLFxuICAgICAgICBvZ2c6ICEhYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9vZ2c7IGNvZGVjcz1cInZvcmJpc1wiJykucmVwbGFjZSgvXm5vJC8sICcnKSxcbiAgICAgICAgb2dhOiAhIWF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vb2dnOyBjb2RlY3M9XCJ2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJyksXG4gICAgICAgIHdhdjogISEoYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby93YXY7IGNvZGVjcz1cIjFcIicpIHx8IGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vd2F2JykpLnJlcGxhY2UoL15ubyQvLCAnJyksXG4gICAgICAgIGFhYzogISFhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL2FhYzsnKS5yZXBsYWNlKC9ebm8kLywgJycpLFxuICAgICAgICBjYWY6ICEhYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby94LWNhZjsnKS5yZXBsYWNlKC9ebm8kLywgJycpLFxuICAgICAgICBtNGE6ICEhKGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8veC1tNGE7JykgfHwgYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9tNGE7JykgfHwgYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9hYWM7JykpLnJlcGxhY2UoL15ubyQvLCAnJyksXG4gICAgICAgIG00YjogISEoYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby94LW00YjsnKSB8fCBhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL200YjsnKSB8fCBhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL2FhYzsnKSkucmVwbGFjZSgvXm5vJC8sICcnKSxcbiAgICAgICAgbXA0OiAhIShhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL3gtbXA0OycpIHx8IGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vbXA0OycpIHx8IGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vYWFjOycpKS5yZXBsYWNlKC9ebm8kLywgJycpLFxuICAgICAgICB3ZWJhOiAhISghaXNPbGRTYWZhcmkgJiYgYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby93ZWJtOyBjb2RlY3M9XCJ2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpLFxuICAgICAgICB3ZWJtOiAhISghaXNPbGRTYWZhcmkgJiYgYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby93ZWJtOyBjb2RlY3M9XCJ2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJykpLFxuICAgICAgICBkb2xieTogISFhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL21wNDsgY29kZWNzPVwiZWMtM1wiJykucmVwbGFjZSgvXm5vJC8sICcnKSxcbiAgICAgICAgZmxhYzogISEoYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby94LWZsYWM7JykgfHwgYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9mbGFjOycpKS5yZXBsYWNlKC9ebm8kLywgJycpXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU29tZSBicm93c2Vycy9kZXZpY2VzIHdpbGwgb25seSBhbGxvdyBhdWRpbyB0byBiZSBwbGF5ZWQgYWZ0ZXIgYSB1c2VyIGludGVyYWN0aW9uLlxuICAgICAqIEF0dGVtcHQgdG8gYXV0b21hdGljYWxseSB1bmxvY2sgYXVkaW8gb24gdGhlIGZpcnN0IHVzZXIgaW50ZXJhY3Rpb24uXG4gICAgICogQ29uY2VwdCBmcm9tOiBodHRwOi8vcGF1bGJha2F1cy5jb20vdHV0b3JpYWxzL2h0bWw1L3dlYi1hdWRpby1vbi1pb3MvXG4gICAgICogQHJldHVybiB7SG93bGVyfVxuICAgICAqL1xuICAgIF91bmxvY2tBdWRpbzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMgfHwgSG93bGVyO1xuXG4gICAgICAvLyBPbmx5IHJ1biB0aGlzIGlmIFdlYiBBdWRpbyBpcyBzdXBwb3J0ZWQgYW5kIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gdW5sb2NrZWQuXG4gICAgICBpZiAoc2VsZi5fYXVkaW9VbmxvY2tlZCB8fCAhc2VsZi5jdHgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZWxmLl9hdWRpb1VubG9ja2VkID0gZmFsc2U7XG4gICAgICBzZWxmLmF1dG9VbmxvY2sgPSBmYWxzZTtcblxuICAgICAgLy8gU29tZSBtb2JpbGUgZGV2aWNlcy9wbGF0Zm9ybXMgaGF2ZSBkaXN0b3J0aW9uIGlzc3VlcyB3aGVuIG9wZW5pbmcvY2xvc2luZyB0YWJzIGFuZC9vciB3ZWIgdmlld3MuXG4gICAgICAvLyBCdWdzIGluIHRoZSBicm93c2VyIChlc3BlY2lhbGx5IE1vYmlsZSBTYWZhcmkpIGNhbiBjYXVzZSB0aGUgc2FtcGxlUmF0ZSB0byBjaGFuZ2UgZnJvbSA0NDEwMCB0byA0ODAwMC5cbiAgICAgIC8vIEJ5IGNhbGxpbmcgSG93bGVyLnVubG9hZCgpLCB3ZSBjcmVhdGUgYSBuZXcgQXVkaW9Db250ZXh0IHdpdGggdGhlIGNvcnJlY3Qgc2FtcGxlUmF0ZS5cbiAgICAgIGlmICghc2VsZi5fbW9iaWxlVW5sb2FkZWQgJiYgc2VsZi5jdHguc2FtcGxlUmF0ZSAhPT0gNDQxMDApIHtcbiAgICAgICAgc2VsZi5fbW9iaWxlVW5sb2FkZWQgPSB0cnVlO1xuICAgICAgICBzZWxmLnVubG9hZCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBTY3JhdGNoIGJ1ZmZlciBmb3IgZW5hYmxpbmcgaU9TIHRvIGRpc3Bvc2Ugb2Ygd2ViIGF1ZGlvIGJ1ZmZlcnMgY29ycmVjdGx5LCBhcyBwZXI6XG4gICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI0MTE5Njg0XG4gICAgICBzZWxmLl9zY3JhdGNoQnVmZmVyID0gc2VsZi5jdHguY3JlYXRlQnVmZmVyKDEsIDEsIDIyMDUwKTtcblxuICAgICAgLy8gQ2FsbCB0aGlzIG1ldGhvZCBvbiB0b3VjaCBzdGFydCB0byBjcmVhdGUgYW5kIHBsYXkgYSBidWZmZXIsXG4gICAgICAvLyB0aGVuIGNoZWNrIGlmIHRoZSBhdWRpbyBhY3R1YWxseSBwbGF5ZWQgdG8gZGV0ZXJtaW5lIGlmXG4gICAgICAvLyBhdWRpbyBoYXMgbm93IGJlZW4gdW5sb2NrZWQgb24gaU9TLCBBbmRyb2lkLCBldGMuXG4gICAgICB2YXIgdW5sb2NrID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyBDcmVhdGUgYSBwb29sIG9mIHVubG9ja2VkIEhUTUw1IEF1ZGlvIG9iamVjdHMgdGhhdCBjYW5cbiAgICAgICAgLy8gYmUgdXNlZCBmb3IgcGxheWluZyBzb3VuZHMgd2l0aG91dCB1c2VyIGludGVyYWN0aW9uLiBIVE1MNVxuICAgICAgICAvLyBBdWRpbyBvYmplY3RzIG11c3QgYmUgaW5kaXZpZHVhbGx5IHVubG9ja2VkLCBhcyBvcHBvc2VkXG4gICAgICAgIC8vIHRvIHRoZSBXZWJBdWRpbyBBUEkgd2hpY2ggb25seSBuZWVkcyBhIHNpbmdsZSBhY3RpdmF0aW9uLlxuICAgICAgICAvLyBUaGlzIG11c3Qgb2NjdXIgYmVmb3JlIFdlYkF1ZGlvIHNldHVwIG9yIHRoZSBzb3VyY2Uub25lbmRlZFxuICAgICAgICAvLyBldmVudCB3aWxsIG5vdCBmaXJlLlxuICAgICAgICB3aGlsZSAoc2VsZi5faHRtbDVBdWRpb1Bvb2wubGVuZ3RoIDwgc2VsZi5odG1sNVBvb2xTaXplKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBhdWRpb05vZGUgPSBuZXcgQXVkaW8oKTtcblxuICAgICAgICAgICAgLy8gTWFyayB0aGlzIEF1ZGlvIG9iamVjdCBhcyB1bmxvY2tlZCB0byBlbnN1cmUgaXQgY2FuIGdldCByZXR1cm5lZFxuICAgICAgICAgICAgLy8gdG8gdGhlIHVubG9ja2VkIHBvb2wgd2hlbiByZWxlYXNlZC5cbiAgICAgICAgICAgIGF1ZGlvTm9kZS5fdW5sb2NrZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIGF1ZGlvIG5vZGUgdG8gdGhlIHBvb2wuXG4gICAgICAgICAgICBzZWxmLl9yZWxlYXNlSHRtbDVBdWRpbyhhdWRpb05vZGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHNlbGYubm9BdWRpbyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggYW55IGFzc2lnbmVkIGF1ZGlvIG5vZGVzIGFuZCB1bmxvY2sgdGhlbS5cbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX2hvd2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFzZWxmLl9ob3dsc1tpXS5fd2ViQXVkaW8pIHtcbiAgICAgICAgICAgIC8vIEdldCBhbGwgb2YgdGhlIHNvdW5kcyBpbiB0aGlzIEhvd2wgZ3JvdXAuXG4gICAgICAgICAgICB2YXIgaWRzID0gc2VsZi5faG93bHNbaV0uX2dldFNvdW5kSWRzKCk7XG5cbiAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgc291bmRzIGFuZCB1bmxvY2sgdGhlIGF1ZGlvIG5vZGVzLlxuICAgICAgICAgICAgZm9yICh2YXIgaj0wOyBqPGlkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgc291bmQgPSBzZWxmLl9ob3dsc1tpXS5fc291bmRCeUlkKGlkc1tqXSk7XG5cbiAgICAgICAgICAgICAgaWYgKHNvdW5kICYmIHNvdW5kLl9ub2RlICYmICFzb3VuZC5fbm9kZS5fdW5sb2NrZWQpIHtcbiAgICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5fdW5sb2NrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNvdW5kLl9ub2RlLmxvYWQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpeCBBbmRyb2lkIGNhbiBub3QgcGxheSBpbiBzdXNwZW5kIHN0YXRlLlxuICAgICAgICBzZWxmLl9hdXRvUmVzdW1lKCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGFuIGVtcHR5IGJ1ZmZlci5cbiAgICAgICAgdmFyIHNvdXJjZSA9IHNlbGYuY3R4LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgICAgICBzb3VyY2UuYnVmZmVyID0gc2VsZi5fc2NyYXRjaEJ1ZmZlcjtcbiAgICAgICAgc291cmNlLmNvbm5lY3Qoc2VsZi5jdHguZGVzdGluYXRpb24pO1xuXG4gICAgICAgIC8vIFBsYXkgdGhlIGVtcHR5IGJ1ZmZlci5cbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2Uuc3RhcnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgc291cmNlLm5vdGVPbigwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzb3VyY2Uuc3RhcnQoMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxsaW5nIHJlc3VtZSgpIG9uIGEgc3RhY2sgaW5pdGlhdGVkIGJ5IHVzZXIgZ2VzdHVyZSBpcyB3aGF0IGFjdHVhbGx5IHVubG9ja3MgdGhlIGF1ZGlvIG9uIEFuZHJvaWQgQ2hyb21lID49IDU1LlxuICAgICAgICBpZiAodHlwZW9mIHNlbGYuY3R4LnJlc3VtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHNlbGYuY3R4LnJlc3VtZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0dXAgYSB0aW1lb3V0IHRvIGNoZWNrIHRoYXQgd2UgYXJlIHVubG9ja2VkIG9uIHRoZSBuZXh0IGV2ZW50IGxvb3AuXG4gICAgICAgIHNvdXJjZS5vbmVuZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc291cmNlLmRpc2Nvbm5lY3QoMCk7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHVubG9ja2VkIHN0YXRlIGFuZCBwcmV2ZW50IHRoaXMgY2hlY2sgZnJvbSBoYXBwZW5pbmcgYWdhaW4uXG4gICAgICAgICAgc2VsZi5fYXVkaW9VbmxvY2tlZCA9IHRydWU7XG5cbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIHRvdWNoIHN0YXJ0IGxpc3RlbmVyLlxuICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB1bmxvY2ssIHRydWUpO1xuICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdW5sb2NrLCB0cnVlKTtcbiAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHVubG9jaywgdHJ1ZSk7XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHVubG9jaywgdHJ1ZSk7XG5cbiAgICAgICAgICAvLyBMZXQgYWxsIHNvdW5kcyBrbm93IHRoYXQgYXVkaW8gaGFzIGJlZW4gdW5sb2NrZWQuXG4gICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX2hvd2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzZWxmLl9ob3dsc1tpXS5fZW1pdCgndW5sb2NrJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgLy8gU2V0dXAgYSB0b3VjaCBzdGFydCBsaXN0ZW5lciB0byBhdHRlbXB0IGFuIHVubG9jayBpbi5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB1bmxvY2ssIHRydWUpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB1bmxvY2ssIHRydWUpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB1bmxvY2ssIHRydWUpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHVubG9jaywgdHJ1ZSk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYW4gdW5sb2NrZWQgSFRNTDUgQXVkaW8gb2JqZWN0IGZyb20gdGhlIHBvb2wuIElmIG5vbmUgYXJlIGxlZnQsXG4gICAgICogcmV0dXJuIGEgbmV3IEF1ZGlvIG9iamVjdCBhbmQgdGhyb3cgYSB3YXJuaW5nLlxuICAgICAqIEByZXR1cm4ge0F1ZGlvfSBIVE1MNSBBdWRpbyBvYmplY3QuXG4gICAgICovXG4gICAgX29idGFpbkh0bWw1QXVkaW86IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcblxuICAgICAgLy8gUmV0dXJuIHRoZSBuZXh0IG9iamVjdCBmcm9tIHRoZSBwb29sIGlmIG9uZSBleGlzdHMuXG4gICAgICBpZiAoc2VsZi5faHRtbDVBdWRpb1Bvb2wubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9odG1sNUF1ZGlvUG9vbC5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgLy8uQ2hlY2sgaWYgdGhlIGF1ZGlvIGlzIGxvY2tlZCBhbmQgdGhyb3cgYSB3YXJuaW5nLlxuICAgICAgdmFyIHRlc3RQbGF5ID0gbmV3IEF1ZGlvKCkucGxheSgpO1xuICAgICAgaWYgKHRlc3RQbGF5ICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiAodGVzdFBsYXkgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHR5cGVvZiB0ZXN0UGxheS50aGVuID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB0ZXN0UGxheS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0hUTUw1IEF1ZGlvIHBvb2wgZXhoYXVzdGVkLCByZXR1cm5pbmcgcG90ZW50aWFsbHkgbG9ja2VkIGF1ZGlvIG9iamVjdC4nKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQXVkaW8oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGFjdGl2YXRlZCBIVE1MNSBBdWRpbyBvYmplY3QgdG8gdGhlIHBvb2wuXG4gICAgICogQHJldHVybiB7SG93bGVyfVxuICAgICAqL1xuICAgIF9yZWxlYXNlSHRtbDVBdWRpbzogZnVuY3Rpb24oYXVkaW8pIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyB8fCBIb3dsZXI7XG5cbiAgICAgIC8vIERvbid0IGFkZCBhdWRpbyB0byB0aGUgcG9vbCBpZiB3ZSBkb24ndCBrbm93IGlmIGl0IGhhcyBiZWVuIHVubG9ja2VkLlxuICAgICAgaWYgKGF1ZGlvLl91bmxvY2tlZCkge1xuICAgICAgICBzZWxmLl9odG1sNUF1ZGlvUG9vbC5wdXNoKGF1ZGlvKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpY2FsbHkgc3VzcGVuZCB0aGUgV2ViIEF1ZGlvIEF1ZGlvQ29udGV4dCBhZnRlciBubyBzb3VuZCBoYXMgcGxheWVkIGZvciAzMCBzZWNvbmRzLlxuICAgICAqIFRoaXMgc2F2ZXMgcHJvY2Vzc2luZy9lbmVyZ3kgYW5kIGZpeGVzIHZhcmlvdXMgYnJvd3Nlci1zcGVjaWZpYyBidWdzIHdpdGggYXVkaW8gZ2V0dGluZyBzdHVjay5cbiAgICAgKiBAcmV0dXJuIHtIb3dsZXJ9XG4gICAgICovXG4gICAgX2F1dG9TdXNwZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKCFzZWxmLmF1dG9TdXNwZW5kIHx8ICFzZWxmLmN0eCB8fCB0eXBlb2Ygc2VsZi5jdHguc3VzcGVuZCA9PT0gJ3VuZGVmaW5lZCcgfHwgIUhvd2xlci51c2luZ1dlYkF1ZGlvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgYW55IHNvdW5kcyBhcmUgcGxheWluZy5cbiAgICAgIGZvciAodmFyIGk9MDsgaTxzZWxmLl9ob3dscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5faG93bHNbaV0uX3dlYkF1ZGlvKSB7XG4gICAgICAgICAgZm9yICh2YXIgaj0wOyBqPHNlbGYuX2hvd2xzW2ldLl9zb3VuZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5faG93bHNbaV0uX3NvdW5kc1tqXS5fcGF1c2VkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5fc3VzcGVuZFRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChzZWxmLl9zdXNwZW5kVGltZXIpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBubyBzb3VuZCBoYXMgcGxheWVkIGFmdGVyIDMwIHNlY29uZHMsIHN1c3BlbmQgdGhlIGNvbnRleHQuXG4gICAgICBzZWxmLl9zdXNwZW5kVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXNlbGYuYXV0b1N1c3BlbmQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLl9zdXNwZW5kVGltZXIgPSBudWxsO1xuICAgICAgICBzZWxmLnN0YXRlID0gJ3N1c3BlbmRpbmcnO1xuXG4gICAgICAgIC8vIEhhbmRsZSB1cGRhdGluZyB0aGUgc3RhdGUgb2YgdGhlIGF1ZGlvIGNvbnRleHQgYWZ0ZXIgc3VzcGVuZGluZy5cbiAgICAgICAgdmFyIGhhbmRsZVN1c3BlbnNpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLnN0YXRlID0gJ3N1c3BlbmRlZCc7XG5cbiAgICAgICAgICBpZiAoc2VsZi5fcmVzdW1lQWZ0ZXJTdXNwZW5kKSB7XG4gICAgICAgICAgICBkZWxldGUgc2VsZi5fcmVzdW1lQWZ0ZXJTdXNwZW5kO1xuICAgICAgICAgICAgc2VsZi5fYXV0b1Jlc3VtZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBFaXRoZXIgdGhlIHN0YXRlIGdldHMgc3VzcGVuZGVkIG9yIGl0IGlzIGludGVycnVwdGVkLlxuICAgICAgICAvLyBFaXRoZXIgd2F5LCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgc3RhdGUgdG8gc3VzcGVuZGVkLlxuICAgICAgICBzZWxmLmN0eC5zdXNwZW5kKCkudGhlbihoYW5kbGVTdXNwZW5zaW9uLCBoYW5kbGVTdXNwZW5zaW9uKTtcbiAgICAgIH0sIDMwMDAwKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpY2FsbHkgcmVzdW1lIHRoZSBXZWIgQXVkaW8gQXVkaW9Db250ZXh0IHdoZW4gYSBuZXcgc291bmQgaXMgcGxheWVkLlxuICAgICAqIEByZXR1cm4ge0hvd2xlcn1cbiAgICAgKi9cbiAgICBfYXV0b1Jlc3VtZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmICghc2VsZi5jdHggfHwgdHlwZW9mIHNlbGYuY3R4LnJlc3VtZSA9PT0gJ3VuZGVmaW5lZCcgfHwgIUhvd2xlci51c2luZ1dlYkF1ZGlvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09ICdydW5uaW5nJyAmJiBzZWxmLmN0eC5zdGF0ZSAhPT0gJ2ludGVycnVwdGVkJyAmJiBzZWxmLl9zdXNwZW5kVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3N1c3BlbmRUaW1lcik7XG4gICAgICAgIHNlbGYuX3N1c3BlbmRUaW1lciA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuc3RhdGUgPT09ICdzdXNwZW5kZWQnIHx8IHNlbGYuc3RhdGUgPT09ICdydW5uaW5nJyAmJiBzZWxmLmN0eC5zdGF0ZSA9PT0gJ2ludGVycnVwdGVkJykge1xuICAgICAgICBzZWxmLmN0eC5yZXN1bWUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYuc3RhdGUgPSAncnVubmluZyc7XG5cbiAgICAgICAgICAvLyBFbWl0IHRvIGFsbCBIb3dscyB0aGF0IHRoZSBhdWRpbyBoYXMgcmVzdW1lZC5cbiAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8c2VsZi5faG93bHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNlbGYuX2hvd2xzW2ldLl9lbWl0KCdyZXN1bWUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzZWxmLl9zdXNwZW5kVGltZXIpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoc2VsZi5fc3VzcGVuZFRpbWVyKTtcbiAgICAgICAgICBzZWxmLl9zdXNwZW5kVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuc3RhdGUgPT09ICdzdXNwZW5kaW5nJykge1xuICAgICAgICBzZWxmLl9yZXN1bWVBZnRlclN1c3BlbmQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIH07XG5cbiAgLy8gU2V0dXAgdGhlIGdsb2JhbCBhdWRpbyBjb250cm9sbGVyLlxuICB2YXIgSG93bGVyID0gbmV3IEhvd2xlckdsb2JhbCgpO1xuXG4gIC8qKiBHcm91cCBNZXRob2RzICoqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gYXVkaW8gZ3JvdXAgY29udHJvbGxlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IG8gUGFzc2VkIGluIHByb3BlcnRpZXMgZm9yIHRoaXMgZ3JvdXAuXG4gICAqL1xuICB2YXIgSG93bCA9IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBUaHJvdyBhbiBlcnJvciBpZiBubyBzb3VyY2UgaXMgcHJvdmlkZWQuXG4gICAgaWYgKCFvLnNyYyB8fCBvLnNyYy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FuIGFycmF5IG9mIHNvdXJjZSBmaWxlcyBtdXN0IGJlIHBhc3NlZCB3aXRoIGFueSBuZXcgSG93bC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZWxmLmluaXQobyk7XG4gIH07XG4gIEhvd2wucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYSBuZXcgSG93bCBncm91cCBvYmplY3QuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvIFBhc3NlZCBpbiBwcm9wZXJ0aWVzIGZvciB0aGlzIGdyb3VwLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24obykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFuIEF1ZGlvQ29udGV4dCBjcmVhdGVkIHlldCwgcnVuIHRoZSBzZXR1cC5cbiAgICAgIGlmICghSG93bGVyLmN0eCkge1xuICAgICAgICBzZXR1cEF1ZGlvQ29udGV4dCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXR1cCB1c2VyLWRlZmluZWQgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICAgICAgc2VsZi5fYXV0b3BsYXkgPSBvLmF1dG9wbGF5IHx8IGZhbHNlO1xuICAgICAgc2VsZi5fZm9ybWF0ID0gKHR5cGVvZiBvLmZvcm1hdCAhPT0gJ3N0cmluZycpID8gby5mb3JtYXQgOiBbby5mb3JtYXRdO1xuICAgICAgc2VsZi5faHRtbDUgPSBvLmh0bWw1IHx8IGZhbHNlO1xuICAgICAgc2VsZi5fbXV0ZWQgPSBvLm11dGUgfHwgZmFsc2U7XG4gICAgICBzZWxmLl9sb29wID0gby5sb29wIHx8IGZhbHNlO1xuICAgICAgc2VsZi5fcG9vbCA9IG8ucG9vbCB8fCA1O1xuICAgICAgc2VsZi5fcHJlbG9hZCA9ICh0eXBlb2Ygby5wcmVsb2FkID09PSAnYm9vbGVhbicgfHwgby5wcmVsb2FkID09PSAnbWV0YWRhdGEnKSA/IG8ucHJlbG9hZCA6IHRydWU7XG4gICAgICBzZWxmLl9yYXRlID0gby5yYXRlIHx8IDE7XG4gICAgICBzZWxmLl9zcHJpdGUgPSBvLnNwcml0ZSB8fCB7fTtcbiAgICAgIHNlbGYuX3NyYyA9ICh0eXBlb2Ygby5zcmMgIT09ICdzdHJpbmcnKSA/IG8uc3JjIDogW28uc3JjXTtcbiAgICAgIHNlbGYuX3ZvbHVtZSA9IG8udm9sdW1lICE9PSB1bmRlZmluZWQgPyBvLnZvbHVtZSA6IDE7XG4gICAgICBzZWxmLl94aHIgPSB7XG4gICAgICAgIG1ldGhvZDogby54aHIgJiYgby54aHIubWV0aG9kID8gby54aHIubWV0aG9kIDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IG8ueGhyICYmIG8ueGhyLmhlYWRlcnMgPyBvLnhoci5oZWFkZXJzIDogbnVsbCxcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBvLnhociAmJiBvLnhoci53aXRoQ3JlZGVudGlhbHMgPyBvLnhoci53aXRoQ3JlZGVudGlhbHMgOiBmYWxzZSxcbiAgICAgIH07XG5cbiAgICAgIC8vIFNldHVwIGFsbCBvdGhlciBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICBzZWxmLl9kdXJhdGlvbiA9IDA7XG4gICAgICBzZWxmLl9zdGF0ZSA9ICd1bmxvYWRlZCc7XG4gICAgICBzZWxmLl9zb3VuZHMgPSBbXTtcbiAgICAgIHNlbGYuX2VuZFRpbWVycyA9IHt9O1xuICAgICAgc2VsZi5fcXVldWUgPSBbXTtcbiAgICAgIHNlbGYuX3BsYXlMb2NrID0gZmFsc2U7XG5cbiAgICAgIC8vIFNldHVwIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgIHNlbGYuX29uZW5kID0gby5vbmVuZCA/IFt7Zm46IG8ub25lbmR9XSA6IFtdO1xuICAgICAgc2VsZi5fb25mYWRlID0gby5vbmZhZGUgPyBbe2ZuOiBvLm9uZmFkZX1dIDogW107XG4gICAgICBzZWxmLl9vbmxvYWQgPSBvLm9ubG9hZCA/IFt7Zm46IG8ub25sb2FkfV0gOiBbXTtcbiAgICAgIHNlbGYuX29ubG9hZGVycm9yID0gby5vbmxvYWRlcnJvciA/IFt7Zm46IG8ub25sb2FkZXJyb3J9XSA6IFtdO1xuICAgICAgc2VsZi5fb25wbGF5ZXJyb3IgPSBvLm9ucGxheWVycm9yID8gW3tmbjogby5vbnBsYXllcnJvcn1dIDogW107XG4gICAgICBzZWxmLl9vbnBhdXNlID0gby5vbnBhdXNlID8gW3tmbjogby5vbnBhdXNlfV0gOiBbXTtcbiAgICAgIHNlbGYuX29ucGxheSA9IG8ub25wbGF5ID8gW3tmbjogby5vbnBsYXl9XSA6IFtdO1xuICAgICAgc2VsZi5fb25zdG9wID0gby5vbnN0b3AgPyBbe2ZuOiBvLm9uc3RvcH1dIDogW107XG4gICAgICBzZWxmLl9vbm11dGUgPSBvLm9ubXV0ZSA/IFt7Zm46IG8ub25tdXRlfV0gOiBbXTtcbiAgICAgIHNlbGYuX29udm9sdW1lID0gby5vbnZvbHVtZSA/IFt7Zm46IG8ub252b2x1bWV9XSA6IFtdO1xuICAgICAgc2VsZi5fb25yYXRlID0gby5vbnJhdGUgPyBbe2ZuOiBvLm9ucmF0ZX1dIDogW107XG4gICAgICBzZWxmLl9vbnNlZWsgPSBvLm9uc2VlayA/IFt7Zm46IG8ub25zZWVrfV0gOiBbXTtcbiAgICAgIHNlbGYuX29udW5sb2NrID0gby5vbnVubG9jayA/IFt7Zm46IG8ub251bmxvY2t9XSA6IFtdO1xuICAgICAgc2VsZi5fb25yZXN1bWUgPSBbXTtcblxuICAgICAgLy8gV2ViIEF1ZGlvIG9yIEhUTUw1IEF1ZGlvP1xuICAgICAgc2VsZi5fd2ViQXVkaW8gPSBIb3dsZXIudXNpbmdXZWJBdWRpbyAmJiAhc2VsZi5faHRtbDU7XG5cbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgdHJ5IHRvIGVuYWJsZSBhdWRpby5cbiAgICAgIGlmICh0eXBlb2YgSG93bGVyLmN0eCAhPT0gJ3VuZGVmaW5lZCcgJiYgSG93bGVyLmN0eCAmJiBIb3dsZXIuYXV0b1VubG9jaykge1xuICAgICAgICBIb3dsZXIuX3VubG9ja0F1ZGlvKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhpcyBIb3dsIGdyb3VwIGluIHRoZSBnbG9iYWwgY29udHJvbGxlci5cbiAgICAgIEhvd2xlci5faG93bHMucHVzaChzZWxmKTtcblxuICAgICAgLy8gSWYgdGhleSBzZWxlY3RlZCBhdXRvcGxheSwgYWRkIGEgcGxheSBldmVudCB0byB0aGUgbG9hZCBxdWV1ZS5cbiAgICAgIGlmIChzZWxmLl9hdXRvcGxheSkge1xuICAgICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICBldmVudDogJ3BsYXknLFxuICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnBsYXkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBMb2FkIHRoZSBzb3VyY2UgZmlsZSB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAgICAgIGlmIChzZWxmLl9wcmVsb2FkICYmIHNlbGYuX3ByZWxvYWQgIT09ICdub25lJykge1xuICAgICAgICBzZWxmLmxvYWQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExvYWQgdGhlIGF1ZGlvIGZpbGUuXG4gICAgICogQHJldHVybiB7SG93bGVyfVxuICAgICAqL1xuICAgIGxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHVybCA9IG51bGw7XG5cbiAgICAgIC8vIElmIG5vIGF1ZGlvIGlzIGF2YWlsYWJsZSwgcXVpdCBpbW1lZGlhdGVseS5cbiAgICAgIGlmIChIb3dsZXIubm9BdWRpbykge1xuICAgICAgICBzZWxmLl9lbWl0KCdsb2FkZXJyb3InLCBudWxsLCAnTm8gYXVkaW8gc3VwcG9ydC4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIHN1cmUgb3VyIHNvdXJjZSBpcyBpbiBhbiBhcnJheS5cbiAgICAgIGlmICh0eXBlb2Ygc2VsZi5fc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICBzZWxmLl9zcmMgPSBbc2VsZi5fc3JjXTtcbiAgICAgIH1cblxuICAgICAgLy8gTG9vcCB0aHJvdWdoIHRoZSBzb3VyY2VzIGFuZCBwaWNrIHRoZSBmaXJzdCBvbmUgdGhhdCBpcyBjb21wYXRpYmxlLlxuICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX3NyYy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXh0LCBzdHI7XG5cbiAgICAgICAgaWYgKHNlbGYuX2Zvcm1hdCAmJiBzZWxmLl9mb3JtYXRbaV0pIHtcbiAgICAgICAgICAvLyBJZiBhbiBleHRlbnNpb24gd2FzIHNwZWNpZmllZCwgdXNlIHRoYXQgaW5zdGVhZC5cbiAgICAgICAgICBleHQgPSBzZWxmLl9mb3JtYXRbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBzb3VyY2UgaXMgYSBzdHJpbmcuXG4gICAgICAgICAgc3RyID0gc2VsZi5fc3JjW2ldO1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2VsZi5fZW1pdCgnbG9hZGVycm9yJywgbnVsbCwgJ05vbi1zdHJpbmcgZm91bmQgaW4gc2VsZWN0ZWQgYXVkaW8gc291cmNlcyAtIGlnbm9yaW5nLicpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRXh0cmFjdCB0aGUgZmlsZSBleHRlbnNpb24gZnJvbSB0aGUgVVJMIG9yIGJhc2U2NCBkYXRhIFVSSS5cbiAgICAgICAgICBleHQgPSAvXmRhdGE6YXVkaW9cXC8oW147LF0rKTsvaS5leGVjKHN0cik7XG4gICAgICAgICAgaWYgKCFleHQpIHtcbiAgICAgICAgICAgIGV4dCA9IC9cXC4oW14uXSspJC8uZXhlYyhzdHIuc3BsaXQoJz8nLCAxKVswXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGV4dCkge1xuICAgICAgICAgICAgZXh0ID0gZXh0WzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9nIGEgd2FybmluZyBpZiBubyBleHRlbnNpb24gd2FzIGZvdW5kLlxuICAgICAgICBpZiAoIWV4dCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignTm8gZmlsZSBleHRlbnNpb24gd2FzIGZvdW5kLiBDb25zaWRlciB1c2luZyB0aGUgXCJmb3JtYXRcIiBwcm9wZXJ0eSBvciBzcGVjaWZ5IGFuIGV4dGVuc2lvbi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgZXh0ZW5zaW9uIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgaWYgKGV4dCAmJiBIb3dsZXIuY29kZWNzKGV4dCkpIHtcbiAgICAgICAgICB1cmwgPSBzZWxmLl9zcmNbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgc2VsZi5fZW1pdCgnbG9hZGVycm9yJywgbnVsbCwgJ05vIGNvZGVjIHN1cHBvcnQgZm9yIHNlbGVjdGVkIGF1ZGlvIHNvdXJjZXMuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5fc3JjID0gdXJsO1xuICAgICAgc2VsZi5fc3RhdGUgPSAnbG9hZGluZyc7XG5cbiAgICAgIC8vIElmIHRoZSBob3N0aW5nIHBhZ2UgaXMgSFRUUFMgYW5kIHRoZSBzb3VyY2UgaXNuJ3QsXG4gICAgICAvLyBkcm9wIGRvd24gdG8gSFRNTDUgQXVkaW8gdG8gYXZvaWQgTWl4ZWQgQ29udGVudCBlcnJvcnMuXG4gICAgICBpZiAod2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JyAmJiB1cmwuc2xpY2UoMCwgNSkgPT09ICdodHRwOicpIHtcbiAgICAgICAgc2VsZi5faHRtbDUgPSB0cnVlO1xuICAgICAgICBzZWxmLl93ZWJBdWRpbyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgc291bmQgb2JqZWN0IGFuZCBhZGQgaXQgdG8gdGhlIHBvb2wuXG4gICAgICBuZXcgU291bmQoc2VsZik7XG5cbiAgICAgIC8vIExvYWQgYW5kIGRlY29kZSB0aGUgYXVkaW8gZGF0YSBmb3IgcGxheWJhY2suXG4gICAgICBpZiAoc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgICAgbG9hZEJ1ZmZlcihzZWxmKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBsYXkgYSBzb3VuZCBvciByZXN1bWUgcHJldmlvdXMgcGxheWJhY2suXG4gICAgICogQHBhcmFtICB7U3RyaW5nL051bWJlcn0gc3ByaXRlICAgU3ByaXRlIG5hbWUgZm9yIHNwcml0ZSBwbGF5YmFjayBvciBzb3VuZCBpZCB0byBjb250aW51ZSBwcmV2aW91cy5cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBpbnRlcm5hbCBJbnRlcm5hbCBVc2U6IHRydWUgcHJldmVudHMgZXZlbnQgZmlyaW5nLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgU291bmQgSUQuXG4gICAgICovXG4gICAgcGxheTogZnVuY3Rpb24oc3ByaXRlLCBpbnRlcm5hbCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGlkID0gbnVsbDtcblxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIGEgc3ByaXRlLCBzb3VuZCBpZCBvciBub3RoaW5nIHdhcyBwYXNzZWRcbiAgICAgIGlmICh0eXBlb2Ygc3ByaXRlID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZCA9IHNwcml0ZTtcbiAgICAgICAgc3ByaXRlID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwcml0ZSA9PT0gJ3N0cmluZycgJiYgc2VsZi5fc3RhdGUgPT09ICdsb2FkZWQnICYmICFzZWxmLl9zcHJpdGVbc3ByaXRlXSkge1xuICAgICAgICAvLyBJZiB0aGUgcGFzc2VkIHNwcml0ZSBkb2Vzbid0IGV4aXN0LCBkbyBub3RoaW5nLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwcml0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBkZWZhdWx0IHNvdW5kIHNwcml0ZSAocGxheXMgdGhlIGZ1bGwgYXVkaW8gbGVuZ3RoKS5cbiAgICAgICAgc3ByaXRlID0gJ19fZGVmYXVsdCc7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYSBzaW5nbGUgcGF1c2VkIHNvdW5kIHRoYXQgaXNuJ3QgZW5kZWQuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzLCBwbGF5IHRoYXQgc291bmQuIElmIG5vdCwgY29udGludWUgYXMgdXN1YWwuXG4gICAgICAgIGlmICghc2VsZi5fcGxheUxvY2spIHtcbiAgICAgICAgICB2YXIgbnVtID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8c2VsZi5fc291bmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fc291bmRzW2ldLl9wYXVzZWQgJiYgIXNlbGYuX3NvdW5kc1tpXS5fZW5kZWQpIHtcbiAgICAgICAgICAgICAgbnVtKys7XG4gICAgICAgICAgICAgIGlkID0gc2VsZi5fc291bmRzW2ldLl9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobnVtID09PSAxKSB7XG4gICAgICAgICAgICBzcHJpdGUgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0aGUgc2VsZWN0ZWQgbm9kZSwgb3IgZ2V0IG9uZSBmcm9tIHRoZSBwb29sLlxuICAgICAgdmFyIHNvdW5kID0gaWQgPyBzZWxmLl9zb3VuZEJ5SWQoaWQpIDogc2VsZi5faW5hY3RpdmVTb3VuZCgpO1xuXG4gICAgICAvLyBJZiB0aGUgc291bmQgZG9lc24ndCBleGlzdCwgZG8gbm90aGluZy5cbiAgICAgIGlmICghc291bmQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlbGVjdCB0aGUgc3ByaXRlIGRlZmluaXRpb24uXG4gICAgICBpZiAoaWQgJiYgIXNwcml0ZSkge1xuICAgICAgICBzcHJpdGUgPSBzb3VuZC5fc3ByaXRlIHx8ICdfX2RlZmF1bHQnO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCwgd2UgbXVzdCB3YWl0IHRvIGdldCB0aGUgYXVkaW8ncyBkdXJhdGlvbi5cbiAgICAgIC8vIFdlIGFsc28gbmVlZCB0byB3YWl0IHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBydW4gaW50byByYWNlIGNvbmRpdGlvbnMgd2l0aFxuICAgICAgLy8gdGhlIG9yZGVyIG9mIGZ1bmN0aW9uIGNhbGxzLlxuICAgICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJykge1xuICAgICAgICAvLyBTZXQgdGhlIHNwcml0ZSB2YWx1ZSBvbiB0aGlzIHNvdW5kLlxuICAgICAgICBzb3VuZC5fc3ByaXRlID0gc3ByaXRlO1xuXG4gICAgICAgIC8vIE1hcmsgdGhpcyBzb3VuZCBhcyBub3QgZW5kZWQgaW4gY2FzZSBhbm90aGVyIHNvdW5kIGlzIHBsYXllZCBiZWZvcmUgdGhpcyBvbmUgbG9hZHMuXG4gICAgICAgIHNvdW5kLl9lbmRlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgc291bmQgdG8gdGhlIHF1ZXVlIHRvIGJlIHBsYXllZCBvbiBsb2FkLlxuICAgICAgICB2YXIgc291bmRJZCA9IHNvdW5kLl9pZDtcbiAgICAgICAgc2VsZi5fcXVldWUucHVzaCh7XG4gICAgICAgICAgZXZlbnQ6ICdwbGF5JyxcbiAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5wbGF5KHNvdW5kSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNvdW5kSWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIERvbid0IHBsYXkgdGhlIHNvdW5kIGlmIGFuIGlkIHdhcyBwYXNzZWQgYW5kIGl0IGlzIGFscmVhZHkgcGxheWluZy5cbiAgICAgIGlmIChpZCAmJiAhc291bmQuX3BhdXNlZCkge1xuICAgICAgICAvLyBUcmlnZ2VyIHRoZSBwbGF5IGV2ZW50LCBpbiBvcmRlciB0byBrZWVwIGl0ZXJhdGluZyB0aHJvdWdoIHF1ZXVlLlxuICAgICAgICBpZiAoIWludGVybmFsKSB7XG4gICAgICAgICAgc2VsZi5fbG9hZFF1ZXVlKCdwbGF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc291bmQuX2lkO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIEF1ZGlvQ29udGV4dCBpc24ndCBzdXNwZW5kZWQsIGFuZCByZXN1bWUgaXQgaWYgaXQgaXMuXG4gICAgICBpZiAoc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgICAgSG93bGVyLl9hdXRvUmVzdW1lKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIERldGVybWluZSBob3cgbG9uZyB0byBwbGF5IGZvciBhbmQgd2hlcmUgdG8gc3RhcnQgcGxheWluZy5cbiAgICAgIHZhciBzZWVrID0gTWF0aC5tYXgoMCwgc291bmQuX3NlZWsgPiAwID8gc291bmQuX3NlZWsgOiBzZWxmLl9zcHJpdGVbc3ByaXRlXVswXSAvIDEwMDApO1xuICAgICAgdmFyIGR1cmF0aW9uID0gTWF0aC5tYXgoMCwgKChzZWxmLl9zcHJpdGVbc3ByaXRlXVswXSArIHNlbGYuX3Nwcml0ZVtzcHJpdGVdWzFdKSAvIDEwMDApIC0gc2Vlayk7XG4gICAgICB2YXIgdGltZW91dCA9IChkdXJhdGlvbiAqIDEwMDApIC8gTWF0aC5hYnMoc291bmQuX3JhdGUpO1xuICAgICAgdmFyIHN0YXJ0ID0gc2VsZi5fc3ByaXRlW3Nwcml0ZV1bMF0gLyAxMDAwO1xuICAgICAgdmFyIHN0b3AgPSAoc2VsZi5fc3ByaXRlW3Nwcml0ZV1bMF0gKyBzZWxmLl9zcHJpdGVbc3ByaXRlXVsxXSkgLyAxMDAwO1xuICAgICAgc291bmQuX3Nwcml0ZSA9IHNwcml0ZTtcblxuICAgICAgLy8gTWFyayB0aGUgc291bmQgYXMgZW5kZWQgaW5zdGFudGx5IHNvIHRoYXQgdGhpcyBhc3luYyBwbGF5YmFja1xuICAgICAgLy8gZG9lc24ndCBnZXQgZ3JhYmJlZCBieSBhbm90aGVyIGNhbGwgdG8gcGxheSB3aGlsZSB0aGlzIG9uZSB3YWl0cyB0byBzdGFydC5cbiAgICAgIHNvdW5kLl9lbmRlZCA9IGZhbHNlO1xuXG4gICAgICAvLyBVcGRhdGUgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIHNvdW5kLlxuICAgICAgdmFyIHNldFBhcmFtcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzb3VuZC5fcGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHNvdW5kLl9zZWVrID0gc2VlaztcbiAgICAgICAgc291bmQuX3N0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHNvdW5kLl9zdG9wID0gc3RvcDtcbiAgICAgICAgc291bmQuX2xvb3AgPSAhIShzb3VuZC5fbG9vcCB8fCBzZWxmLl9zcHJpdGVbc3ByaXRlXVsyXSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBFbmQgdGhlIHNvdW5kIGluc3RhbnRseSBpZiBzZWVrIGlzIGF0IHRoZSBlbmQuXG4gICAgICBpZiAoc2VlayA+PSBzdG9wKSB7XG4gICAgICAgIHNlbGYuX2VuZGVkKHNvdW5kKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBCZWdpbiB0aGUgYWN0dWFsIHBsYXliYWNrLlxuICAgICAgdmFyIG5vZGUgPSBzb3VuZC5fbm9kZTtcbiAgICAgIGlmIChzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICAvLyBGaXJlIHRoaXMgd2hlbiB0aGUgc291bmQgaXMgcmVhZHkgdG8gcGxheSB0byBiZWdpbiBXZWIgQXVkaW8gcGxheWJhY2suXG4gICAgICAgIHZhciBwbGF5V2ViQXVkaW8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLl9wbGF5TG9jayA9IGZhbHNlO1xuICAgICAgICAgIHNldFBhcmFtcygpO1xuICAgICAgICAgIHNlbGYuX3JlZnJlc2hCdWZmZXIoc291bmQpO1xuXG4gICAgICAgICAgLy8gU2V0dXAgdGhlIHBsYXliYWNrIHBhcmFtcy5cbiAgICAgICAgICB2YXIgdm9sID0gKHNvdW5kLl9tdXRlZCB8fCBzZWxmLl9tdXRlZCkgPyAwIDogc291bmQuX3ZvbHVtZTtcbiAgICAgICAgICBub2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUodm9sLCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICBzb3VuZC5fcGxheVN0YXJ0ID0gSG93bGVyLmN0eC5jdXJyZW50VGltZTtcblxuICAgICAgICAgIC8vIFBsYXkgdGhlIHNvdW5kIHVzaW5nIHRoZSBzdXBwb3J0ZWQgbWV0aG9kLlxuICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5idWZmZXJTb3VyY2Uuc3RhcnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzb3VuZC5fbG9vcCA/IG5vZGUuYnVmZmVyU291cmNlLm5vdGVHcmFpbk9uKDAsIHNlZWssIDg2NDAwKSA6IG5vZGUuYnVmZmVyU291cmNlLm5vdGVHcmFpbk9uKDAsIHNlZWssIGR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291bmQuX2xvb3AgPyBub2RlLmJ1ZmZlclNvdXJjZS5zdGFydCgwLCBzZWVrLCA4NjQwMCkgOiBub2RlLmJ1ZmZlclNvdXJjZS5zdGFydCgwLCBzZWVrLCBkdXJhdGlvbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU3RhcnQgYSBuZXcgdGltZXIgaWYgbm9uZSBpcyBwcmVzZW50LlxuICAgICAgICAgIGlmICh0aW1lb3V0ICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgc2VsZi5fZW5kVGltZXJzW3NvdW5kLl9pZF0gPSBzZXRUaW1lb3V0KHNlbGYuX2VuZGVkLmJpbmQoc2VsZiwgc291bmQpLCB0aW1lb3V0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWludGVybmFsKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBzZWxmLl9lbWl0KCdwbGF5Jywgc291bmQuX2lkKTtcbiAgICAgICAgICAgICAgc2VsZi5fbG9hZFF1ZXVlKCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKEhvd2xlci5zdGF0ZSA9PT0gJ3J1bm5pbmcnICYmIEhvd2xlci5jdHguc3RhdGUgIT09ICdpbnRlcnJ1cHRlZCcpIHtcbiAgICAgICAgICBwbGF5V2ViQXVkaW8oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLl9wbGF5TG9jayA9IHRydWU7XG5cbiAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgYXVkaW8gY29udGV4dCB0byByZXN1bWUgYmVmb3JlIHBsYXlpbmcuXG4gICAgICAgICAgc2VsZi5vbmNlKCdyZXN1bWUnLCBwbGF5V2ViQXVkaW8pO1xuXG4gICAgICAgICAgLy8gQ2FuY2VsIHRoZSBlbmQgdGltZXIuXG4gICAgICAgICAgc2VsZi5fY2xlYXJUaW1lcihzb3VuZC5faWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGaXJlIHRoaXMgd2hlbiB0aGUgc291bmQgaXMgcmVhZHkgdG8gcGxheSB0byBiZWdpbiBIVE1MNSBBdWRpbyBwbGF5YmFjay5cbiAgICAgICAgdmFyIHBsYXlIdG1sNSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG5vZGUuY3VycmVudFRpbWUgPSBzZWVrO1xuICAgICAgICAgIG5vZGUubXV0ZWQgPSBzb3VuZC5fbXV0ZWQgfHwgc2VsZi5fbXV0ZWQgfHwgSG93bGVyLl9tdXRlZCB8fCBub2RlLm11dGVkO1xuICAgICAgICAgIG5vZGUudm9sdW1lID0gc291bmQuX3ZvbHVtZSAqIEhvd2xlci52b2x1bWUoKTtcbiAgICAgICAgICBub2RlLnBsYXliYWNrUmF0ZSA9IHNvdW5kLl9yYXRlO1xuXG4gICAgICAgICAgLy8gU29tZSBicm93c2VycyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoaXMgaXMgY2FsbGVkIHdpdGhvdXQgdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHBsYXkgPSBub2RlLnBsYXkoKTtcblxuICAgICAgICAgICAgLy8gU3VwcG9ydCBvbGRlciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgcHJvbWlzZXMsIGFuZCB0aHVzIGRvbid0IGhhdmUgdGhpcyBpc3N1ZS5cbiAgICAgICAgICAgIGlmIChwbGF5ICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiAocGxheSBpbnN0YW5jZW9mIFByb21pc2UgfHwgdHlwZW9mIHBsYXkudGhlbiA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgICAgLy8gSW1wbGVtZW50cyBhIGxvY2sgdG8gcHJldmVudCBET01FeGNlcHRpb246IFRoZSBwbGF5KCkgcmVxdWVzdCB3YXMgaW50ZXJydXB0ZWQgYnkgYSBjYWxsIHRvIHBhdXNlKCkuXG4gICAgICAgICAgICAgIHNlbGYuX3BsYXlMb2NrID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAvLyBTZXQgcGFyYW0gdmFsdWVzIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgICBzZXRQYXJhbXMoKTtcblxuICAgICAgICAgICAgICAvLyBSZWxlYXNlcyB0aGUgbG9jayBhbmQgZXhlY3V0ZXMgcXVldWVkIGFjdGlvbnMuXG4gICAgICAgICAgICAgIHBsYXlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGYuX3BsYXlMb2NrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBub2RlLl91bmxvY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBpZiAoIWludGVybmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2VtaXQoJ3BsYXknLCBzb3VuZC5faWQpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fbG9hZFF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBzZWxmLl9wbGF5TG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgc2VsZi5fZW1pdCgncGxheWVycm9yJywgc291bmQuX2lkLCAnUGxheWJhY2sgd2FzIHVuYWJsZSB0byBzdGFydC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGFuIGlzc3VlICcgK1xuICAgICAgICAgICAgICAgICAgICAnb24gbW9iaWxlIGRldmljZXMgYW5kIENocm9tZSB3aGVyZSBwbGF5YmFjayB3YXMgbm90IHdpdGhpbiBhIHVzZXIgaW50ZXJhY3Rpb24uJyk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBlbmRlZCBhbmQgcGF1c2VkIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgIHNvdW5kLl9lbmRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBzb3VuZC5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWludGVybmFsKSB7XG4gICAgICAgICAgICAgIHNlbGYuX3BsYXlMb2NrID0gZmFsc2U7XG4gICAgICAgICAgICAgIHNldFBhcmFtcygpO1xuICAgICAgICAgICAgICBzZWxmLl9lbWl0KCdwbGF5Jywgc291bmQuX2lkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0dGluZyByYXRlIGJlZm9yZSBwbGF5aW5nIHdvbid0IHdvcmsgaW4gSUUsIHNvIHdlIHNldCBpdCBhZ2FpbiBoZXJlLlxuICAgICAgICAgICAgbm9kZS5wbGF5YmFja1JhdGUgPSBzb3VuZC5fcmF0ZTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGUgaXMgc3RpbGwgcGF1c2VkLCB0aGVuIHdlIGNhbiBhc3N1bWUgdGhlcmUgd2FzIGEgcGxheWJhY2sgaXNzdWUuXG4gICAgICAgICAgICBpZiAobm9kZS5wYXVzZWQpIHtcbiAgICAgICAgICAgICAgc2VsZi5fZW1pdCgncGxheWVycm9yJywgc291bmQuX2lkLCAnUGxheWJhY2sgd2FzIHVuYWJsZSB0byBzdGFydC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGFuIGlzc3VlICcgK1xuICAgICAgICAgICAgICAgICdvbiBtb2JpbGUgZGV2aWNlcyBhbmQgQ2hyb21lIHdoZXJlIHBsYXliYWNrIHdhcyBub3Qgd2l0aGluIGEgdXNlciBpbnRlcmFjdGlvbi4nKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXR1cCB0aGUgZW5kIHRpbWVyIG9uIHNwcml0ZXMgb3IgbGlzdGVuIGZvciB0aGUgZW5kZWQgZXZlbnQuXG4gICAgICAgICAgICBpZiAoc3ByaXRlICE9PSAnX19kZWZhdWx0JyB8fCBzb3VuZC5fbG9vcCkge1xuICAgICAgICAgICAgICBzZWxmLl9lbmRUaW1lcnNbc291bmQuX2lkXSA9IHNldFRpbWVvdXQoc2VsZi5fZW5kZWQuYmluZChzZWxmLCBzb3VuZCksIHRpbWVvdXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZi5fZW5kVGltZXJzW3NvdW5kLl9pZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBGaXJlIGVuZGVkIG9uIHRoaXMgYXVkaW8gbm9kZS5cbiAgICAgICAgICAgICAgICBzZWxmLl9lbmRlZChzb3VuZCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDbGVhciB0aGlzIGxpc3RlbmVyLlxuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBzZWxmLl9lbmRUaW1lcnNbc291bmQuX2lkXSwgZmFsc2UpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgc2VsZi5fZW5kVGltZXJzW3NvdW5kLl9pZF0sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHNlbGYuX2VtaXQoJ3BsYXllcnJvcicsIHNvdW5kLl9pZCwgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBzdHJlYW1pbmcgYXVkaW8sIG1ha2Ugc3VyZSB0aGUgc3JjIGlzIHNldCBhbmQgbG9hZCBhZ2Fpbi5cbiAgICAgICAgaWYgKG5vZGUuc3JjID09PSAnZGF0YTphdWRpby93YXY7YmFzZTY0LFVrbEdSaWdBQUFCWFFWWkZabTEwSUJJQUFBQUJBQUVBUkt3QUFJaFlBUUFDQUJBQUFBQmtZWFJoQWdBQUFBRUEnKSB7XG4gICAgICAgICAgbm9kZS5zcmMgPSBzZWxmLl9zcmM7XG4gICAgICAgICAgbm9kZS5sb2FkKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQbGF5IGltbWVkaWF0ZWx5IGlmIHJlYWR5LCBvciB3YWl0IGZvciB0aGUgJ2NhbnBsYXl0aHJvdWdoJ2UgdmVudC5cbiAgICAgICAgdmFyIGxvYWRlZE5vUmVhZHlTdGF0ZSA9ICh3aW5kb3cgJiYgd2luZG93LmVqZWN0YSkgfHwgKCFub2RlLnJlYWR5U3RhdGUgJiYgSG93bGVyLl9uYXZpZ2F0b3IuaXNDb2Nvb25KUyk7XG4gICAgICAgIGlmIChub2RlLnJlYWR5U3RhdGUgPj0gMyB8fCBsb2FkZWROb1JlYWR5U3RhdGUpIHtcbiAgICAgICAgICBwbGF5SHRtbDUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLl9wbGF5TG9jayA9IHRydWU7XG4gICAgICAgICAgc2VsZi5fc3RhdGUgPSAnbG9hZGluZyc7XG5cbiAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuX3N0YXRlID0gJ2xvYWRlZCc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEJlZ2luIHBsYXliYWNrLlxuICAgICAgICAgICAgcGxheUh0bWw1KCk7XG5cbiAgICAgICAgICAgIC8vIENsZWFyIHRoaXMgbGlzdGVuZXIuXG4gICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoSG93bGVyLl9jYW5QbGF5RXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoSG93bGVyLl9jYW5QbGF5RXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG5cbiAgICAgICAgICAvLyBDYW5jZWwgdGhlIGVuZCB0aW1lci5cbiAgICAgICAgICBzZWxmLl9jbGVhclRpbWVyKHNvdW5kLl9pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNvdW5kLl9pZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGF1c2UgcGxheWJhY2sgYW5kIHNhdmUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIFRoZSBzb3VuZCBJRCAoZW1wdHkgdG8gcGF1c2UgYWxsIGluIGdyb3VwKS5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIHBhdXNlOiBmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCBvciBhIHBsYXkoKSBwcm9taXNlIGlzIHBlbmRpbmcsIGFkZCBpdCB0byB0aGUgbG9hZCBxdWV1ZSB0byBwYXVzZSB3aGVuIGNhcGFibGUuXG4gICAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnIHx8IHNlbGYuX3BsYXlMb2NrKSB7XG4gICAgICAgIHNlbGYuX3F1ZXVlLnB1c2goe1xuICAgICAgICAgIGV2ZW50OiAncGF1c2UnLFxuICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnBhdXNlKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBubyBpZCBpcyBwYXNzZWQsIGdldCBhbGwgSUQncyB0byBiZSBwYXVzZWQuXG4gICAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuXG4gICAgICBmb3IgKHZhciBpPTA7IGk8aWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIENsZWFyIHRoZSBlbmQgdGltZXIuXG4gICAgICAgIHNlbGYuX2NsZWFyVGltZXIoaWRzW2ldKTtcblxuICAgICAgICAvLyBHZXQgdGhlIHNvdW5kLlxuICAgICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRzW2ldKTtcblxuICAgICAgICBpZiAoc291bmQgJiYgIXNvdW5kLl9wYXVzZWQpIHtcbiAgICAgICAgICAvLyBSZXNldCB0aGUgc2VlayBwb3NpdGlvbi5cbiAgICAgICAgICBzb3VuZC5fc2VlayA9IHNlbGYuc2VlayhpZHNbaV0pO1xuICAgICAgICAgIHNvdW5kLl9yYXRlU2VlayA9IDA7XG4gICAgICAgICAgc291bmQuX3BhdXNlZCA9IHRydWU7XG5cbiAgICAgICAgICAvLyBTdG9wIGN1cnJlbnRseSBydW5uaW5nIGZhZGVzLlxuICAgICAgICAgIHNlbGYuX3N0b3BGYWRlKGlkc1tpXSk7XG5cbiAgICAgICAgICBpZiAoc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHNvdW5kIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgICAgICAgIGlmICghc291bmQuX25vZGUuYnVmZmVyU291cmNlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5zdG9wID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5ub3RlT2ZmKDApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5zdG9wKDApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGJ1ZmZlciBzb3VyY2UuXG4gICAgICAgICAgICAgIHNlbGYuX2NsZWFuQnVmZmVyKHNvdW5kLl9ub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzTmFOKHNvdW5kLl9ub2RlLmR1cmF0aW9uKSB8fCBzb3VuZC5fbm9kZS5kdXJhdGlvbiA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgc291bmQuX25vZGUucGF1c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaXJlIHRoZSBwYXVzZSBldmVudCwgdW5sZXNzIGB0cnVlYCBpcyBwYXNzZWQgYXMgdGhlIDJuZCBhcmd1bWVudC5cbiAgICAgICAgaWYgKCFhcmd1bWVudHNbMV0pIHtcbiAgICAgICAgICBzZWxmLl9lbWl0KCdwYXVzZScsIHNvdW5kID8gc291bmQuX2lkIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3AgcGxheWJhY2sgYW5kIHJlc2V0IHRvIHN0YXJ0LlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgVGhlIHNvdW5kIElEIChlbXB0eSB0byBzdG9wIGFsbCBpbiBncm91cCkuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gaW50ZXJuYWwgSW50ZXJuYWwgVXNlOiB0cnVlIHByZXZlbnRzIGV2ZW50IGZpcmluZy5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIHN0b3A6IGZ1bmN0aW9uKGlkLCBpbnRlcm5hbCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCwgYWRkIGl0IHRvIHRoZSBsb2FkIHF1ZXVlIHRvIHN0b3Agd2hlbiBjYXBhYmxlLlxuICAgICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJyB8fCBzZWxmLl9wbGF5TG9jaykge1xuICAgICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICBldmVudDogJ3N0b3AnLFxuICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnN0b3AoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vIGlkIGlzIHBhc3NlZCwgZ2V0IGFsbCBJRCdzIHRvIGJlIHN0b3BwZWQuXG4gICAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuXG4gICAgICBmb3IgKHZhciBpPTA7IGk8aWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIENsZWFyIHRoZSBlbmQgdGltZXIuXG4gICAgICAgIHNlbGYuX2NsZWFyVGltZXIoaWRzW2ldKTtcblxuICAgICAgICAvLyBHZXQgdGhlIHNvdW5kLlxuICAgICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRzW2ldKTtcblxuICAgICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgICAvLyBSZXNldCB0aGUgc2VlayBwb3NpdGlvbi5cbiAgICAgICAgICBzb3VuZC5fc2VlayA9IHNvdW5kLl9zdGFydCB8fCAwO1xuICAgICAgICAgIHNvdW5kLl9yYXRlU2VlayA9IDA7XG4gICAgICAgICAgc291bmQuX3BhdXNlZCA9IHRydWU7XG4gICAgICAgICAgc291bmQuX2VuZGVkID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIFN0b3AgY3VycmVudGx5IHJ1bm5pbmcgZmFkZXMuXG4gICAgICAgICAgc2VsZi5fc3RvcEZhZGUoaWRzW2ldKTtcblxuICAgICAgICAgIGlmIChzb3VuZC5fbm9kZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgc291bmQncyBBdWRpb0J1ZmZlclNvdXJjZU5vZGUgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgICAgICAgICAgaWYgKHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc291bmQuX25vZGUuYnVmZmVyU291cmNlLnN0b3AgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2Uubm90ZU9mZigwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLnN0b3AoMCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGJ1ZmZlciBzb3VyY2UuXG4gICAgICAgICAgICAgICAgc2VsZi5fY2xlYW5CdWZmZXIoc291bmQuX25vZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc05hTihzb3VuZC5fbm9kZS5kdXJhdGlvbikgfHwgc291bmQuX25vZGUuZHVyYXRpb24gPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgIHNvdW5kLl9ub2RlLmN1cnJlbnRUaW1lID0gc291bmQuX3N0YXJ0IHx8IDA7XG4gICAgICAgICAgICAgIHNvdW5kLl9ub2RlLnBhdXNlKCk7XG5cbiAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIGxpdmUgc3RyZWFtLCBzdG9wIGRvd25sb2FkIG9uY2UgdGhlIGF1ZGlvIGlzIHN0b3BwZWQuXG4gICAgICAgICAgICAgIGlmIChzb3VuZC5fbm9kZS5kdXJhdGlvbiA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9jbGVhclNvdW5kKHNvdW5kLl9ub2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHNlbGYuX2VtaXQoJ3N0b3AnLCBzb3VuZC5faWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXV0ZS91bm11dGUgYSBzaW5nbGUgc291bmQgb3IgYWxsIHNvdW5kcyBpbiB0aGlzIEhvd2wgZ3JvdXAuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gbXV0ZWQgU2V0IHRvIHRydWUgdG8gbXV0ZSBhbmQgZmFsc2UgdG8gdW5tdXRlLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgICAgVGhlIHNvdW5kIElEIHRvIHVwZGF0ZSAob21pdCB0byBtdXRlL3VubXV0ZSBhbGwpLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgbXV0ZTogZnVuY3Rpb24obXV0ZWQsIGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIElmIHRoZSBzb3VuZCBoYXNuJ3QgbG9hZGVkLCBhZGQgaXQgdG8gdGhlIGxvYWQgcXVldWUgdG8gbXV0ZSB3aGVuIGNhcGFibGUuXG4gICAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnfHwgc2VsZi5fcGxheUxvY2spIHtcbiAgICAgICAgc2VsZi5fcXVldWUucHVzaCh7XG4gICAgICAgICAgZXZlbnQ6ICdtdXRlJyxcbiAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5tdXRlKG11dGVkLCBpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYXBwbHlpbmcgbXV0ZS91bm11dGUgdG8gYWxsIHNvdW5kcywgdXBkYXRlIHRoZSBncm91cCdzIHZhbHVlLlxuICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtdXRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgc2VsZi5fbXV0ZWQgPSBtdXRlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5fbXV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm8gaWQgaXMgcGFzc2VkLCBnZXQgYWxsIElEJ3MgdG8gYmUgbXV0ZWQuXG4gICAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuXG4gICAgICBmb3IgKHZhciBpPTA7IGk8aWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEdldCB0aGUgc291bmQuXG4gICAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZHNbaV0pO1xuXG4gICAgICAgIGlmIChzb3VuZCkge1xuICAgICAgICAgIHNvdW5kLl9tdXRlZCA9IG11dGVkO1xuXG4gICAgICAgICAgLy8gQ2FuY2VsIGFjdGl2ZSBmYWRlIGFuZCBzZXQgdGhlIHZvbHVtZSB0byB0aGUgZW5kIHZhbHVlLlxuICAgICAgICAgIGlmIChzb3VuZC5faW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHNlbGYuX3N0b3BGYWRlKHNvdW5kLl9pZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvICYmIHNvdW5kLl9ub2RlKSB7XG4gICAgICAgICAgICBzb3VuZC5fbm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKG11dGVkID8gMCA6IHNvdW5kLl92b2x1bWUsIEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgIHNvdW5kLl9ub2RlLm11dGVkID0gSG93bGVyLl9tdXRlZCA/IHRydWUgOiBtdXRlZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLl9lbWl0KCdtdXRlJywgc291bmQuX2lkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0L3NldCB0aGUgdm9sdW1lIG9mIHRoaXMgc291bmQgb3Igb2YgdGhlIEhvd2wgZ3JvdXAuIFRoaXMgbWV0aG9kIGNhbiBvcHRpb25hbGx5IHRha2UgMCwgMSBvciAyIGFyZ3VtZW50cy5cbiAgICAgKiAgIHZvbHVtZSgpIC0+IFJldHVybnMgdGhlIGdyb3VwJ3Mgdm9sdW1lIHZhbHVlLlxuICAgICAqICAgdm9sdW1lKGlkKSAtPiBSZXR1cm5zIHRoZSBzb3VuZCBpZCdzIGN1cnJlbnQgdm9sdW1lLlxuICAgICAqICAgdm9sdW1lKHZvbCkgLT4gU2V0cyB0aGUgdm9sdW1lIG9mIGFsbCBzb3VuZHMgaW4gdGhpcyBIb3dsIGdyb3VwLlxuICAgICAqICAgdm9sdW1lKHZvbCwgaWQpIC0+IFNldHMgdGhlIHZvbHVtZSBvZiBwYXNzZWQgc291bmQgaWQuXG4gICAgICogQHJldHVybiB7SG93bC9OdW1iZXJ9IFJldHVybnMgc2VsZiBvciBjdXJyZW50IHZvbHVtZS5cbiAgICAgKi9cbiAgICB2b2x1bWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgdm9sLCBpZDtcblxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSB2YWx1ZXMgYmFzZWQgb24gYXJndW1lbnRzLlxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGdyb3Vwcycgdm9sdW1lLlxuICAgICAgICByZXR1cm4gc2VsZi5fdm9sdW1lO1xuICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSB8fCBhcmdzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgYXJnc1sxXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhpcyBpcyBhbiBJRCwgYW5kIGlmIG5vdCwgYXNzdW1lIGl0IGlzIGEgbmV3IHZvbHVtZS5cbiAgICAgICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKCk7XG4gICAgICAgIHZhciBpbmRleCA9IGlkcy5pbmRleE9mKGFyZ3NbMF0pO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIGlkID0gcGFyc2VJbnQoYXJnc1swXSwgMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZvbCA9IHBhcnNlRmxvYXQoYXJnc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPj0gMikge1xuICAgICAgICB2b2wgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICBpZCA9IHBhcnNlSW50KGFyZ3NbMV0sIDEwKTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHRoZSB2b2x1bWUgb3IgcmV0dXJuIHRoZSBjdXJyZW50IHZvbHVtZS5cbiAgICAgIHZhciBzb3VuZDtcbiAgICAgIGlmICh0eXBlb2Ygdm9sICE9PSAndW5kZWZpbmVkJyAmJiB2b2wgPj0gMCAmJiB2b2wgPD0gMSkge1xuICAgICAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCwgYWRkIGl0IHRvIHRoZSBsb2FkIHF1ZXVlIHRvIGNoYW5nZSB2b2x1bWUgd2hlbiBjYXBhYmxlLlxuICAgICAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnfHwgc2VsZi5fcGxheUxvY2spIHtcbiAgICAgICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgIGV2ZW50OiAndm9sdW1lJyxcbiAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHNlbGYudm9sdW1lLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIGdyb3VwIHZvbHVtZS5cbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBzZWxmLl92b2x1bWUgPSB2b2w7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgb25lIG9yIGFsbCB2b2x1bWVzLlxuICAgICAgICBpZCA9IHNlbGYuX2dldFNvdW5kSWRzKGlkKTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPGlkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgLy8gR2V0IHRoZSBzb3VuZC5cbiAgICAgICAgICBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZFtpXSk7XG5cbiAgICAgICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgICAgIHNvdW5kLl92b2x1bWUgPSB2b2w7XG5cbiAgICAgICAgICAgIC8vIFN0b3AgY3VycmVudGx5IHJ1bm5pbmcgZmFkZXMuXG4gICAgICAgICAgICBpZiAoIWFyZ3NbMl0pIHtcbiAgICAgICAgICAgICAgc2VsZi5fc3RvcEZhZGUoaWRbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZi5fd2ViQXVkaW8gJiYgc291bmQuX25vZGUgJiYgIXNvdW5kLl9tdXRlZCkge1xuICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKHZvbCwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvdW5kLl9ub2RlICYmICFzb3VuZC5fbXV0ZWQpIHtcbiAgICAgICAgICAgICAgc291bmQuX25vZGUudm9sdW1lID0gdm9sICogSG93bGVyLnZvbHVtZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLl9lbWl0KCd2b2x1bWUnLCBzb3VuZC5faWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291bmQgPSBpZCA/IHNlbGYuX3NvdW5kQnlJZChpZCkgOiBzZWxmLl9zb3VuZHNbMF07XG4gICAgICAgIHJldHVybiBzb3VuZCA/IHNvdW5kLl92b2x1bWUgOiAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmFkZSBhIGN1cnJlbnRseSBwbGF5aW5nIHNvdW5kIGJldHdlZW4gdHdvIHZvbHVtZXMgKGlmIG5vIGlkIGlzIHBhc3NlZCwgYWxsIHNvdW5kcyB3aWxsIGZhZGUpLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZnJvbSBUaGUgdmFsdWUgdG8gZmFkZSBmcm9tICgwLjAgdG8gMS4wKS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRvICAgVGhlIHZvbHVtZSB0byBmYWRlIHRvICgwLjAgdG8gMS4wKS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGxlbiAgVGltZSBpbiBtaWxsaXNlY29uZHMgdG8gZmFkZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkICAgVGhlIHNvdW5kIGlkIChvbWl0IHRvIGZhZGUgYWxsIHNvdW5kcykuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBmYWRlOiBmdW5jdGlvbihmcm9tLCB0bywgbGVuLCBpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCwgYWRkIGl0IHRvIHRoZSBsb2FkIHF1ZXVlIHRvIGZhZGUgd2hlbiBjYXBhYmxlLlxuICAgICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJyB8fCBzZWxmLl9wbGF5TG9jaykge1xuICAgICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICBldmVudDogJ2ZhZGUnLFxuICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmZhZGUoZnJvbSwgdG8sIGxlbiwgaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdG8vZnJvbS9sZW4gdmFsdWVzIGFyZSBudW1iZXJzLlxuICAgICAgZnJvbSA9IE1hdGgubWluKE1hdGgubWF4KDAsIHBhcnNlRmxvYXQoZnJvbSkpLCAxKTtcbiAgICAgIHRvID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgcGFyc2VGbG9hdCh0bykpLCAxKTtcbiAgICAgIGxlbiA9IHBhcnNlRmxvYXQobGVuKTtcblxuICAgICAgLy8gU2V0IHRoZSB2b2x1bWUgdG8gdGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAgc2VsZi52b2x1bWUoZnJvbSwgaWQpO1xuXG4gICAgICAvLyBGYWRlIHRoZSB2b2x1bWUgb2Ygb25lIG9yIGFsbCBzb3VuZHMuXG4gICAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuICAgICAgZm9yICh2YXIgaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBHZXQgdGhlIHNvdW5kLlxuICAgICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRzW2ldKTtcblxuICAgICAgICAvLyBDcmVhdGUgYSBsaW5lYXIgZmFkZSBvciBmYWxsIGJhY2sgdG8gdGltZW91dHMgd2l0aCBIVE1MNSBBdWRpby5cbiAgICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgICAgLy8gU3RvcCB0aGUgcHJldmlvdXMgZmFkZSBpZiBubyBzcHJpdGUgaXMgYmVpbmcgdXNlZCAob3RoZXJ3aXNlLCB2b2x1bWUgaGFuZGxlcyB0aGlzKS5cbiAgICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICBzZWxmLl9zdG9wRmFkZShpZHNbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHdlIGFyZSB1c2luZyBXZWIgQXVkaW8sIGxldCB0aGUgbmF0aXZlIG1ldGhvZHMgZG8gdGhlIGFjdHVhbCBmYWRlLlxuICAgICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbyAmJiAhc291bmQuX211dGVkKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGN1cnJlbnRUaW1lICsgKGxlbiAvIDEwMDApO1xuICAgICAgICAgICAgc291bmQuX3ZvbHVtZSA9IGZyb207XG4gICAgICAgICAgICBzb3VuZC5fbm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKGZyb20sIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIHNvdW5kLl9ub2RlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodG8sIGVuZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5fc3RhcnRGYWRlSW50ZXJ2YWwoc291bmQsIGZyb20sIHRvLCBsZW4sIGlkc1tpXSwgdHlwZW9mIGlkID09PSAndW5kZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB0aGUgaW50ZXJuYWwgaW50ZXJ2YWwgdG8gZmFkZSBhIHNvdW5kLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc291bmQgUmVmZXJlbmNlIHRvIHNvdW5kIHRvIGZhZGUuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBmcm9tIFRoZSB2YWx1ZSB0byBmYWRlIGZyb20gKDAuMCB0byAxLjApLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdG8gICBUaGUgdm9sdW1lIHRvIGZhZGUgdG8gKDAuMCB0byAxLjApLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gbGVuICBUaW1lIGluIG1pbGxpc2Vjb25kcyB0byBmYWRlLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgICBUaGUgc291bmQgaWQgdG8gZmFkZS5cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBpc0dyb3VwICAgSWYgdHJ1ZSwgc2V0IHRoZSB2b2x1bWUgb24gdGhlIGdyb3VwLlxuICAgICAqL1xuICAgIF9zdGFydEZhZGVJbnRlcnZhbDogZnVuY3Rpb24oc291bmQsIGZyb20sIHRvLCBsZW4sIGlkLCBpc0dyb3VwKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgdm9sID0gZnJvbTtcbiAgICAgIHZhciBkaWZmID0gdG8gLSBmcm9tO1xuICAgICAgdmFyIHN0ZXBzID0gTWF0aC5hYnMoZGlmZiAvIDAuMDEpO1xuICAgICAgdmFyIHN0ZXBMZW4gPSBNYXRoLm1heCg0LCAoc3RlcHMgPiAwKSA/IGxlbiAvIHN0ZXBzIDogbGVuKTtcbiAgICAgIHZhciBsYXN0VGljayA9IERhdGUubm93KCk7XG5cbiAgICAgIC8vIFN0b3JlIHRoZSB2YWx1ZSBiZWluZyBmYWRlZCB0by5cbiAgICAgIHNvdW5kLl9mYWRlVG8gPSB0bztcblxuICAgICAgLy8gVXBkYXRlIHRoZSB2b2x1bWUgdmFsdWUgb24gZWFjaCBpbnRlcnZhbCB0aWNrLlxuICAgICAgc291bmQuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdm9sdW1lIGJhc2VkIG9uIHRoZSB0aW1lIHNpbmNlIHRoZSBsYXN0IHRpY2suXG4gICAgICAgIHZhciB0aWNrID0gKERhdGUubm93KCkgLSBsYXN0VGljaykgLyBsZW47XG4gICAgICAgIGxhc3RUaWNrID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdm9sICs9IGRpZmYgKiB0aWNrO1xuXG4gICAgICAgIC8vIFJvdW5kIHRvIHdpdGhpbiAyIGRlY2ltYWwgcG9pbnRzLlxuICAgICAgICB2b2wgPSBNYXRoLnJvdW5kKHZvbCAqIDEwMCkgLyAxMDA7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB2b2x1bWUgaXMgaW4gdGhlIHJpZ2h0IGJvdW5kcy5cbiAgICAgICAgaWYgKGRpZmYgPCAwKSB7XG4gICAgICAgICAgdm9sID0gTWF0aC5tYXgodG8sIHZvbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm9sID0gTWF0aC5taW4odG8sIHZvbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGFuZ2UgdGhlIHZvbHVtZS5cbiAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICAgICAgc291bmQuX3ZvbHVtZSA9IHZvbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLnZvbHVtZSh2b2wsIHNvdW5kLl9pZCwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIGdyb3VwJ3Mgdm9sdW1lLlxuICAgICAgICBpZiAoaXNHcm91cCkge1xuICAgICAgICAgIHNlbGYuX3ZvbHVtZSA9IHZvbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdoZW4gdGhlIGZhZGUgaXMgY29tcGxldGUsIHN0b3AgaXQgYW5kIGZpcmUgZXZlbnQuXG4gICAgICAgIGlmICgodG8gPCBmcm9tICYmIHZvbCA8PSB0bykgfHwgKHRvID4gZnJvbSAmJiB2b2wgPj0gdG8pKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChzb3VuZC5faW50ZXJ2YWwpO1xuICAgICAgICAgIHNvdW5kLl9pbnRlcnZhbCA9IG51bGw7XG4gICAgICAgICAgc291bmQuX2ZhZGVUbyA9IG51bGw7XG4gICAgICAgICAgc2VsZi52b2x1bWUodG8sIHNvdW5kLl9pZCk7XG4gICAgICAgICAgc2VsZi5fZW1pdCgnZmFkZScsIHNvdW5kLl9pZCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHN0ZXBMZW4pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdGhhdCBzdG9wcyB0aGUgY3VycmVudGx5IHBsYXlpbmcgZmFkZSB3aGVuXG4gICAgICogYSBuZXcgZmFkZSBzdGFydHMsIHZvbHVtZSBpcyBjaGFuZ2VkIG9yIHRoZSBzb3VuZCBpcyBzdG9wcGVkLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgVGhlIHNvdW5kIGlkLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgX3N0b3BGYWRlOiBmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkKTtcblxuICAgICAgaWYgKHNvdW5kICYmIHNvdW5kLl9pbnRlcnZhbCkge1xuICAgICAgICBpZiAoc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgICAgICBzb3VuZC5fbm9kZS5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFySW50ZXJ2YWwoc291bmQuX2ludGVydmFsKTtcbiAgICAgICAgc291bmQuX2ludGVydmFsID0gbnVsbDtcbiAgICAgICAgc2VsZi52b2x1bWUoc291bmQuX2ZhZGVUbywgaWQpO1xuICAgICAgICBzb3VuZC5fZmFkZVRvID0gbnVsbDtcbiAgICAgICAgc2VsZi5fZW1pdCgnZmFkZScsIGlkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldC9zZXQgdGhlIGxvb3AgcGFyYW1ldGVyIG9uIGEgc291bmQuIFRoaXMgbWV0aG9kIGNhbiBvcHRpb25hbGx5IHRha2UgMCwgMSBvciAyIGFyZ3VtZW50cy5cbiAgICAgKiAgIGxvb3AoKSAtPiBSZXR1cm5zIHRoZSBncm91cCdzIGxvb3AgdmFsdWUuXG4gICAgICogICBsb29wKGlkKSAtPiBSZXR1cm5zIHRoZSBzb3VuZCBpZCdzIGxvb3AgdmFsdWUuXG4gICAgICogICBsb29wKGxvb3ApIC0+IFNldHMgdGhlIGxvb3AgdmFsdWUgZm9yIGFsbCBzb3VuZHMgaW4gdGhpcyBIb3dsIGdyb3VwLlxuICAgICAqICAgbG9vcChsb29wLCBpZCkgLT4gU2V0cyB0aGUgbG9vcCB2YWx1ZSBvZiBwYXNzZWQgc291bmQgaWQuXG4gICAgICogQHJldHVybiB7SG93bC9Cb29sZWFufSBSZXR1cm5zIHNlbGYgb3IgY3VycmVudCBsb29wIHZhbHVlLlxuICAgICAqL1xuICAgIGxvb3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgbG9vcCwgaWQsIHNvdW5kO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIHZhbHVlcyBmb3IgbG9vcCBhbmQgaWQuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBncm91J3MgbG9vcCB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIHNlbGYuX2xvb3A7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgbG9vcCA9IGFyZ3NbMF07XG4gICAgICAgICAgc2VsZi5fbG9vcCA9IGxvb3A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmV0dXJuIHRoaXMgc291bmQncyBsb29wIHZhbHVlLlxuICAgICAgICAgIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKHBhcnNlSW50KGFyZ3NbMF0sIDEwKSk7XG4gICAgICAgICAgcmV0dXJuIHNvdW5kID8gc291bmQuX2xvb3AgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBsb29wID0gYXJnc1swXTtcbiAgICAgICAgaWQgPSBwYXJzZUludChhcmdzWzFdLCAxMCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vIGlkIGlzIHBhc3NlZCwgZ2V0IGFsbCBJRCdzIHRvIGJlIGxvb3BlZC5cbiAgICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcyhpZCk7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8aWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkc1tpXSk7XG5cbiAgICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgICAgc291bmQuX2xvb3AgPSBsb29wO1xuICAgICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbyAmJiBzb3VuZC5fbm9kZSAmJiBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UpIHtcbiAgICAgICAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5sb29wID0gbG9vcDtcbiAgICAgICAgICAgIGlmIChsb29wKSB7XG4gICAgICAgICAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5sb29wU3RhcnQgPSBzb3VuZC5fc3RhcnQgfHwgMDtcbiAgICAgICAgICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLmxvb3BFbmQgPSBzb3VuZC5fc3RvcDtcblxuICAgICAgICAgICAgICAvLyBJZiBwbGF5aW5nLCByZXN0YXJ0IHBsYXliYWNrIHRvIGVuc3VyZSBsb29waW5nIHVwZGF0ZXMuXG4gICAgICAgICAgICAgIGlmIChzZWxmLnBsYXlpbmcoaWRzW2ldKSkge1xuICAgICAgICAgICAgICAgIHNlbGYucGF1c2UoaWRzW2ldLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBzZWxmLnBsYXkoaWRzW2ldLCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0L3NldCB0aGUgcGxheWJhY2sgcmF0ZSBvZiBhIHNvdW5kLiBUaGlzIG1ldGhvZCBjYW4gb3B0aW9uYWxseSB0YWtlIDAsIDEgb3IgMiBhcmd1bWVudHMuXG4gICAgICogICByYXRlKCkgLT4gUmV0dXJucyB0aGUgZmlyc3Qgc291bmQgbm9kZSdzIGN1cnJlbnQgcGxheWJhY2sgcmF0ZS5cbiAgICAgKiAgIHJhdGUoaWQpIC0+IFJldHVybnMgdGhlIHNvdW5kIGlkJ3MgY3VycmVudCBwbGF5YmFjayByYXRlLlxuICAgICAqICAgcmF0ZShyYXRlKSAtPiBTZXRzIHRoZSBwbGF5YmFjayByYXRlIG9mIGFsbCBzb3VuZHMgaW4gdGhpcyBIb3dsIGdyb3VwLlxuICAgICAqICAgcmF0ZShyYXRlLCBpZCkgLT4gU2V0cyB0aGUgcGxheWJhY2sgcmF0ZSBvZiBwYXNzZWQgc291bmQgaWQuXG4gICAgICogQHJldHVybiB7SG93bC9OdW1iZXJ9IFJldHVybnMgc2VsZiBvciB0aGUgY3VycmVudCBwbGF5YmFjayByYXRlLlxuICAgICAqL1xuICAgIHJhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgcmF0ZSwgaWQ7XG5cbiAgICAgIC8vIERldGVybWluZSB0aGUgdmFsdWVzIGJhc2VkIG9uIGFyZ3VtZW50cy5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBXZSB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgcmF0ZSBvZiB0aGUgZmlyc3Qgbm9kZS5cbiAgICAgICAgaWQgPSBzZWxmLl9zb3VuZHNbMF0uX2lkO1xuICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGlzIGlzIGFuIElELCBhbmQgaWYgbm90LCBhc3N1bWUgaXQgaXMgYSBuZXcgcmF0ZSB2YWx1ZS5cbiAgICAgICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKCk7XG4gICAgICAgIHZhciBpbmRleCA9IGlkcy5pbmRleE9mKGFyZ3NbMF0pO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIGlkID0gcGFyc2VJbnQoYXJnc1swXSwgMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJhdGUgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJhdGUgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICBpZCA9IHBhcnNlSW50KGFyZ3NbMV0sIDEwKTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHRoZSBwbGF5YmFjayByYXRlIG9yIHJldHVybiB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgIHZhciBzb3VuZDtcbiAgICAgIGlmICh0eXBlb2YgcmF0ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gSWYgdGhlIHNvdW5kIGhhc24ndCBsb2FkZWQsIGFkZCBpdCB0byB0aGUgbG9hZCBxdWV1ZSB0byBjaGFuZ2UgcGxheWJhY2sgcmF0ZSB3aGVuIGNhcGFibGUuXG4gICAgICAgIGlmIChzZWxmLl9zdGF0ZSAhPT0gJ2xvYWRlZCcgfHwgc2VsZi5fcGxheUxvY2spIHtcbiAgICAgICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgIGV2ZW50OiAncmF0ZScsXG4gICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBzZWxmLnJhdGUuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB0aGUgZ3JvdXAgcmF0ZS5cbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBzZWxmLl9yYXRlID0gcmF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBvbmUgb3IgYWxsIHZvbHVtZXMuXG4gICAgICAgIGlkID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8aWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAvLyBHZXQgdGhlIHNvdW5kLlxuICAgICAgICAgIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkW2ldKTtcblxuICAgICAgICAgIGlmIChzb3VuZCkge1xuICAgICAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBvdXIgcG9zaXRpb24gd2hlbiB0aGUgcmF0ZSBjaGFuZ2VkIGFuZCB1cGRhdGUgdGhlIHBsYXliYWNrXG4gICAgICAgICAgICAvLyBzdGFydCBwb3NpdGlvbiBzbyB3ZSBjYW4gcHJvcGVybHkgYWRqdXN0IHRoZSBzZWVrIHBvc2l0aW9uIGZvciB0aW1lIGVsYXBzZWQuXG4gICAgICAgICAgICBpZiAoc2VsZi5wbGF5aW5nKGlkW2ldKSkge1xuICAgICAgICAgICAgICBzb3VuZC5fcmF0ZVNlZWsgPSBzZWxmLnNlZWsoaWRbaV0pO1xuICAgICAgICAgICAgICBzb3VuZC5fcGxheVN0YXJ0ID0gc2VsZi5fd2ViQXVkaW8gPyBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lIDogc291bmQuX3BsYXlTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdW5kLl9yYXRlID0gcmF0ZTtcblxuICAgICAgICAgICAgLy8gQ2hhbmdlIHRoZSBwbGF5YmFjayByYXRlLlxuICAgICAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvICYmIHNvdW5kLl9ub2RlICYmIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZSkge1xuICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UucGxheWJhY2tSYXRlLnNldFZhbHVlQXRUaW1lKHJhdGUsIEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VuZC5fbm9kZSkge1xuICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5wbGF5YmFja1JhdGUgPSByYXRlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgdGltZXJzLlxuICAgICAgICAgICAgdmFyIHNlZWsgPSBzZWxmLnNlZWsoaWRbaV0pO1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gKChzZWxmLl9zcHJpdGVbc291bmQuX3Nwcml0ZV1bMF0gKyBzZWxmLl9zcHJpdGVbc291bmQuX3Nwcml0ZV1bMV0pIC8gMTAwMCkgLSBzZWVrO1xuICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSAoZHVyYXRpb24gKiAxMDAwKSAvIE1hdGguYWJzKHNvdW5kLl9yYXRlKTtcblxuICAgICAgICAgICAgLy8gU3RhcnQgYSBuZXcgZW5kIHRpbWVyIGlmIHNvdW5kIGlzIGFscmVhZHkgcGxheWluZy5cbiAgICAgICAgICAgIGlmIChzZWxmLl9lbmRUaW1lcnNbaWRbaV1dIHx8ICFzb3VuZC5fcGF1c2VkKSB7XG4gICAgICAgICAgICAgIHNlbGYuX2NsZWFyVGltZXIoaWRbaV0pO1xuICAgICAgICAgICAgICBzZWxmLl9lbmRUaW1lcnNbaWRbaV1dID0gc2V0VGltZW91dChzZWxmLl9lbmRlZC5iaW5kKHNlbGYsIHNvdW5kKSwgdGltZW91dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuX2VtaXQoJ3JhdGUnLCBzb3VuZC5faWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWQpO1xuICAgICAgICByZXR1cm4gc291bmQgPyBzb3VuZC5fcmF0ZSA6IHNlbGYuX3JhdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQvc2V0IHRoZSBzZWVrIHBvc2l0aW9uIG9mIGEgc291bmQuIFRoaXMgbWV0aG9kIGNhbiBvcHRpb25hbGx5IHRha2UgMCwgMSBvciAyIGFyZ3VtZW50cy5cbiAgICAgKiAgIHNlZWsoKSAtPiBSZXR1cm5zIHRoZSBmaXJzdCBzb3VuZCBub2RlJ3MgY3VycmVudCBzZWVrIHBvc2l0aW9uLlxuICAgICAqICAgc2VlayhpZCkgLT4gUmV0dXJucyB0aGUgc291bmQgaWQncyBjdXJyZW50IHNlZWsgcG9zaXRpb24uXG4gICAgICogICBzZWVrKHNlZWspIC0+IFNldHMgdGhlIHNlZWsgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHNvdW5kIG5vZGUuXG4gICAgICogICBzZWVrKHNlZWssIGlkKSAtPiBTZXRzIHRoZSBzZWVrIHBvc2l0aW9uIG9mIHBhc3NlZCBzb3VuZCBpZC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsL051bWJlcn0gUmV0dXJucyBzZWxmIG9yIHRoZSBjdXJyZW50IHNlZWsgcG9zaXRpb24uXG4gICAgICovXG4gICAgc2VlazogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBzZWVrLCBpZDtcblxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSB2YWx1ZXMgYmFzZWQgb24gYXJndW1lbnRzLlxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIFdlIHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgbm9kZS5cbiAgICAgICAgaWYgKHNlbGYuX3NvdW5kcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZCA9IHNlbGYuX3NvdW5kc1swXS5faWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhpcyBpcyBhbiBJRCwgYW5kIGlmIG5vdCwgYXNzdW1lIGl0IGlzIGEgbmV3IHNlZWsgcG9zaXRpb24uXG4gICAgICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcygpO1xuICAgICAgICB2YXIgaW5kZXggPSBpZHMuaW5kZXhPZihhcmdzWzBdKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICBpZCA9IHBhcnNlSW50KGFyZ3NbMF0sIDEwKTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLl9zb3VuZHMubGVuZ3RoKSB7XG4gICAgICAgICAgaWQgPSBzZWxmLl9zb3VuZHNbMF0uX2lkO1xuICAgICAgICAgIHNlZWsgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHNlZWsgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICBpZCA9IHBhcnNlSW50KGFyZ3NbMV0sIDEwKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gSUQsIGJhaWwgb3V0LlxuICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBzb3VuZCBoYXNuJ3QgbG9hZGVkLCBhZGQgaXQgdG8gdGhlIGxvYWQgcXVldWUgdG8gc2VlayB3aGVuIGNhcGFibGUuXG4gICAgICBpZiAodHlwZW9mIHNlZWsgPT09ICdudW1iZXInICYmIChzZWxmLl9zdGF0ZSAhPT0gJ2xvYWRlZCcgfHwgc2VsZi5fcGxheUxvY2spKSB7XG4gICAgICAgIHNlbGYuX3F1ZXVlLnB1c2goe1xuICAgICAgICAgIGV2ZW50OiAnc2VlaycsXG4gICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuc2Vlay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgdGhlIHNvdW5kLlxuICAgICAgdmFyIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkKTtcblxuICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VlayA9PT0gJ251bWJlcicgJiYgc2VlayA+PSAwKSB7XG4gICAgICAgICAgLy8gUGF1c2UgdGhlIHNvdW5kIGFuZCB1cGRhdGUgcG9zaXRpb24gZm9yIHJlc3RhcnRpbmcgcGxheWJhY2suXG4gICAgICAgICAgdmFyIHBsYXlpbmcgPSBzZWxmLnBsYXlpbmcoaWQpO1xuICAgICAgICAgIGlmIChwbGF5aW5nKSB7XG4gICAgICAgICAgICBzZWxmLnBhdXNlKGlkLCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBNb3ZlIHRoZSBwb3NpdGlvbiBvZiB0aGUgdHJhY2sgYW5kIGNhbmNlbCB0aW1lci5cbiAgICAgICAgICBzb3VuZC5fc2VlayA9IHNlZWs7XG4gICAgICAgICAgc291bmQuX2VuZGVkID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5fY2xlYXJUaW1lcihpZCk7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHNlZWsgcG9zaXRpb24gZm9yIEhUTUw1IEF1ZGlvLlxuICAgICAgICAgIGlmICghc2VsZi5fd2ViQXVkaW8gJiYgc291bmQuX25vZGUgJiYgIWlzTmFOKHNvdW5kLl9ub2RlLmR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc291bmQuX25vZGUuY3VycmVudFRpbWUgPSBzZWVrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNlZWsgYW5kIGVtaXQgd2hlbiByZWFkeS5cbiAgICAgICAgICB2YXIgc2Vla0FuZEVtaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFJlc3RhcnQgdGhlIHBsYXliYWNrIGlmIHRoZSBzb3VuZCB3YXMgcGxheWluZy5cbiAgICAgICAgICAgIGlmIChwbGF5aW5nKSB7XG4gICAgICAgICAgICAgIHNlbGYucGxheShpZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuX2VtaXQoJ3NlZWsnLCBpZCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBwbGF5IGxvY2sgdG8gYmUgdW5zZXQgYmVmb3JlIGVtaXR0aW5nIChIVE1MNSBBdWRpbykuXG4gICAgICAgICAgaWYgKHBsYXlpbmcgJiYgIXNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICAgICAgICB2YXIgZW1pdFNlZWsgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKCFzZWxmLl9wbGF5TG9jaykge1xuICAgICAgICAgICAgICAgIHNlZWtBbmRFbWl0KCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChlbWl0U2VlaywgMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGVtaXRTZWVrLCAwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2Vla0FuZEVtaXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICAgICAgICB2YXIgcmVhbFRpbWUgPSBzZWxmLnBsYXlpbmcoaWQpID8gSG93bGVyLmN0eC5jdXJyZW50VGltZSAtIHNvdW5kLl9wbGF5U3RhcnQgOiAwO1xuICAgICAgICAgICAgdmFyIHJhdGVTZWVrID0gc291bmQuX3JhdGVTZWVrID8gc291bmQuX3JhdGVTZWVrIC0gc291bmQuX3NlZWsgOiAwO1xuICAgICAgICAgICAgcmV0dXJuIHNvdW5kLl9zZWVrICsgKHJhdGVTZWVrICsgcmVhbFRpbWUgKiBNYXRoLmFicyhzb3VuZC5fcmF0ZSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc291bmQuX25vZGUuY3VycmVudFRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHNwZWNpZmljIHNvdW5kIGlzIGN1cnJlbnRseSBwbGF5aW5nIG9yIG5vdCAoaWYgaWQgaXMgcHJvdmlkZWQpLCBvciBjaGVjayBpZiBhdCBsZWFzdCBvbmUgb2YgdGhlIHNvdW5kcyBpbiB0aGUgZ3JvdXAgaXMgcGxheWluZyBvciBub3QuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgaWQgVGhlIHNvdW5kIGlkIHRvIGNoZWNrLiBJZiBub25lIGlzIHBhc3NlZCwgdGhlIHdob2xlIHNvdW5kIGdyb3VwIGlzIGNoZWNrZWQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBwbGF5aW5nIGFuZCBmYWxzZSBpZiBub3QuXG4gICAgICovXG4gICAgcGxheWluZzogZnVuY3Rpb24oaWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgLy8gQ2hlY2sgdGhlIHBhc3NlZCBzb3VuZCBJRCAoaWYgYW55KS5cbiAgICAgIGlmICh0eXBlb2YgaWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZCk7XG4gICAgICAgIHJldHVybiBzb3VuZCA/ICFzb3VuZC5fcGF1c2VkIDogZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgbG9vcCB0aHJvdWdoIGFsbCBzb3VuZHMgYW5kIGNoZWNrIGlmIGFueSBhcmUgcGxheWluZy5cbiAgICAgIGZvciAodmFyIGk9MDsgaTxzZWxmLl9zb3VuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFzZWxmLl9zb3VuZHNbaV0uX3BhdXNlZCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkdXJhdGlvbiBvZiB0aGlzIHNvdW5kLiBQYXNzaW5nIGEgc291bmQgaWQgd2lsbCByZXR1cm4gdGhlIHNwcml0ZSBkdXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIFRoZSBzb3VuZCBpZCB0byBjaGVjay4gSWYgbm9uZSBpcyBwYXNzZWQsIHJldHVybiBmdWxsIHNvdXJjZSBkdXJhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEF1ZGlvIGR1cmF0aW9uIGluIHNlY29uZHMuXG4gICAgICovXG4gICAgZHVyYXRpb246IGZ1bmN0aW9uKGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgZHVyYXRpb24gPSBzZWxmLl9kdXJhdGlvbjtcblxuICAgICAgLy8gSWYgd2UgcGFzcyBhbiBJRCwgZ2V0IHRoZSBzb3VuZCBhbmQgcmV0dXJuIHRoZSBzcHJpdGUgbGVuZ3RoLlxuICAgICAgdmFyIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkKTtcbiAgICAgIGlmIChzb3VuZCkge1xuICAgICAgICBkdXJhdGlvbiA9IHNlbGYuX3Nwcml0ZVtzb3VuZC5fc3ByaXRlXVsxXSAvIDEwMDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkdXJhdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBsb2FkZWQgc3RhdGUgb2YgdGhpcyBIb3dsLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gJ3VubG9hZGVkJywgJ2xvYWRpbmcnLCAnbG9hZGVkJ1xuICAgICAqL1xuICAgIHN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5sb2FkIGFuZCBkZXN0cm95IHRoZSBjdXJyZW50IEhvd2wgb2JqZWN0LlxuICAgICAqIFRoaXMgd2lsbCBpbW1lZGlhdGVseSBzdG9wIGFsbCBzb3VuZCBpbnN0YW5jZXMgYXR0YWNoZWQgdG8gdGhpcyBncm91cC5cbiAgICAgKi9cbiAgICB1bmxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBTdG9wIHBsYXlpbmcgYW55IGFjdGl2ZSBzb3VuZHMuXG4gICAgICB2YXIgc291bmRzID0gc2VsZi5fc291bmRzO1xuICAgICAgZm9yICh2YXIgaT0wOyBpPHNvdW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBTdG9wIHRoZSBzb3VuZCBpZiBpdCBpcyBjdXJyZW50bHkgcGxheWluZy5cbiAgICAgICAgaWYgKCFzb3VuZHNbaV0uX3BhdXNlZCkge1xuICAgICAgICAgIHNlbGYuc3RvcChzb3VuZHNbaV0uX2lkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgc291cmNlIG9yIGRpc2Nvbm5lY3QuXG4gICAgICAgIGlmICghc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgICAgICAvLyBTZXQgdGhlIHNvdXJjZSB0byAwLXNlY29uZCBzaWxlbmNlIHRvIHN0b3AgYW55IGRvd25sb2FkaW5nIChleGNlcHQgaW4gSUUpLlxuICAgICAgICAgIHNlbGYuX2NsZWFyU291bmQoc291bmRzW2ldLl9ub2RlKTtcblxuICAgICAgICAgIC8vIFJlbW92ZSBhbnkgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgICAgIHNvdW5kc1tpXS5fbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHNvdW5kc1tpXS5fZXJyb3JGbiwgZmFsc2UpO1xuICAgICAgICAgIHNvdW5kc1tpXS5fbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEhvd2xlci5fY2FuUGxheUV2ZW50LCBzb3VuZHNbaV0uX2xvYWRGbiwgZmFsc2UpO1xuICAgICAgICAgIHNvdW5kc1tpXS5fbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHNvdW5kc1tpXS5fZW5kRm4sIGZhbHNlKTtcblxuICAgICAgICAgIC8vIFJlbGVhc2UgdGhlIEF1ZGlvIG9iamVjdCBiYWNrIHRvIHRoZSBwb29sLlxuICAgICAgICAgIEhvd2xlci5fcmVsZWFzZUh0bWw1QXVkaW8oc291bmRzW2ldLl9ub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVtcHR5IG91dCBhbGwgb2YgdGhlIG5vZGVzLlxuICAgICAgICBkZWxldGUgc291bmRzW2ldLl9ub2RlO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhbGwgdGltZXJzIGFyZSBjbGVhcmVkIG91dC5cbiAgICAgICAgc2VsZi5fY2xlYXJUaW1lcihzb3VuZHNbaV0uX2lkKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSByZWZlcmVuY2VzIGluIHRoZSBnbG9iYWwgSG93bGVyIG9iamVjdC5cbiAgICAgIHZhciBpbmRleCA9IEhvd2xlci5faG93bHMuaW5kZXhPZihzZWxmKTtcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIEhvd2xlci5faG93bHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGVsZXRlIHRoaXMgc291bmQgZnJvbSB0aGUgY2FjaGUgKGlmIG5vIG90aGVyIEhvd2wgaXMgdXNpbmcgaXQpLlxuICAgICAgdmFyIHJlbUNhY2hlID0gdHJ1ZTtcbiAgICAgIGZvciAoaT0wOyBpPEhvd2xlci5faG93bHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKEhvd2xlci5faG93bHNbaV0uX3NyYyA9PT0gc2VsZi5fc3JjIHx8IHNlbGYuX3NyYy5pbmRleE9mKEhvd2xlci5faG93bHNbaV0uX3NyYykgPj0gMCkge1xuICAgICAgICAgIHJlbUNhY2hlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNhY2hlICYmIHJlbUNhY2hlKSB7XG4gICAgICAgIGRlbGV0ZSBjYWNoZVtzZWxmLl9zcmNdO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciBnbG9iYWwgZXJyb3JzLlxuICAgICAgSG93bGVyLm5vQXVkaW8gPSBmYWxzZTtcblxuICAgICAgLy8gQ2xlYXIgb3V0IGBzZWxmYC5cbiAgICAgIHNlbGYuX3N0YXRlID0gJ3VubG9hZGVkJztcbiAgICAgIHNlbGYuX3NvdW5kcyA9IFtdO1xuICAgICAgc2VsZiA9IG51bGw7XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gdG8gYSBjdXN0b20gZXZlbnQuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgIGV2ZW50IEV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgIExpc3RlbmVyIHRvIGNhbGwuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgIGlkICAgIChvcHRpb25hbCkgT25seSBsaXN0ZW4gdG8gZXZlbnRzIGZvciB0aGlzIHNvdW5kLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICBvbmNlICAoSU5URVJOQUwpIE1hcmtzIGV2ZW50IHRvIGZpcmUgb25seSBvbmNlLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uKGV2ZW50LCBmbiwgaWQsIG9uY2UpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBldmVudHMgPSBzZWxmWydfb24nICsgZXZlbnRdO1xuXG4gICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKG9uY2UgPyB7aWQ6IGlkLCBmbjogZm4sIG9uY2U6IG9uY2V9IDoge2lkOiBpZCwgZm46IGZufSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBjdXN0b20gZXZlbnQuIENhbGwgd2l0aG91dCBwYXJhbWV0ZXJzIHRvIHJlbW92ZSBhbGwgZXZlbnRzLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gICBldmVudCBFdmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgICBMaXN0ZW5lciB0byByZW1vdmUuIExlYXZlIGVtcHR5IHRvIHJlbW92ZSBhbGwuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgIGlkICAgIChvcHRpb25hbCkgT25seSByZW1vdmUgZXZlbnRzIGZvciB0aGlzIHNvdW5kLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbihldmVudCwgZm4sIGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgZXZlbnRzID0gc2VsZlsnX29uJyArIGV2ZW50XTtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgLy8gQWxsb3cgcGFzc2luZyBqdXN0IGFuIGV2ZW50IGFuZCBJRC5cbiAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlkID0gZm47XG4gICAgICAgIGZuID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGZuIHx8IGlkKSB7XG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBldmVudCBzdG9yZSBhbmQgcmVtb3ZlIHRoZSBwYXNzZWQgZnVuY3Rpb24uXG4gICAgICAgIGZvciAoaT0wOyBpPGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBpc0lkID0gKGlkID09PSBldmVudHNbaV0uaWQpO1xuICAgICAgICAgIGlmIChmbiA9PT0gZXZlbnRzW2ldLmZuICYmIGlzSWQgfHwgIWZuICYmIGlzSWQpIHtcbiAgICAgICAgICAgIGV2ZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQ2xlYXIgb3V0IGFsbCBldmVudHMgb2YgdGhpcyB0eXBlLlxuICAgICAgICBzZWxmWydfb24nICsgZXZlbnRdID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDbGVhciBvdXQgYWxsIGV2ZW50cyBvZiBldmVyeSB0eXBlLlxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNlbGYpO1xuICAgICAgICBmb3IgKGk9MDsgaTxrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKChrZXlzW2ldLmluZGV4T2YoJ19vbicpID09PSAwKSAmJiBBcnJheS5pc0FycmF5KHNlbGZba2V5c1tpXV0pKSB7XG4gICAgICAgICAgICBzZWxmW2tleXNbaV1dID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gdG8gYSBjdXN0b20gZXZlbnQgYW5kIHJlbW92ZSBpdCBvbmNlIGZpcmVkLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gICBldmVudCBFdmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgICBMaXN0ZW5lciB0byBjYWxsLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICBpZCAgICAob3B0aW9uYWwpIE9ubHkgbGlzdGVuIHRvIGV2ZW50cyBmb3IgdGhpcyBzb3VuZC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIG9uY2U6IGZ1bmN0aW9uKGV2ZW50LCBmbiwgaWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgLy8gU2V0dXAgdGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgc2VsZi5vbihldmVudCwgZm4sIGlkLCAxKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVtaXQgYWxsIGV2ZW50cyBvZiBhIHNwZWNpZmljIHR5cGUgYW5kIHBhc3MgdGhlIHNvdW5kIGlkLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZXZlbnQgRXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkICAgIFNvdW5kIElELlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gbXNnICAgTWVzc2FnZSB0byBnbyB3aXRoIGV2ZW50LlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgX2VtaXQ6IGZ1bmN0aW9uKGV2ZW50LCBpZCwgbXNnKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgZXZlbnRzID0gc2VsZlsnX29uJyArIGV2ZW50XTtcblxuICAgICAgLy8gTG9vcCB0aHJvdWdoIGV2ZW50IHN0b3JlIGFuZCBmaXJlIGFsbCBmdW5jdGlvbnMuXG4gICAgICBmb3IgKHZhciBpPWV2ZW50cy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgIC8vIE9ubHkgZmlyZSB0aGUgbGlzdGVuZXIgaWYgdGhlIGNvcnJlY3QgSUQgaXMgdXNlZC5cbiAgICAgICAgaWYgKCFldmVudHNbaV0uaWQgfHwgZXZlbnRzW2ldLmlkID09PSBpZCB8fCBldmVudCA9PT0gJ2xvYWQnKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbihmbikge1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBpZCwgbXNnKTtcbiAgICAgICAgICB9LmJpbmQoc2VsZiwgZXZlbnRzW2ldLmZuKSwgMCk7XG5cbiAgICAgICAgICAvLyBJZiB0aGlzIGV2ZW50IHdhcyBzZXR1cCB3aXRoIGBvbmNlYCwgcmVtb3ZlIGl0LlxuICAgICAgICAgIGlmIChldmVudHNbaV0ub25jZSkge1xuICAgICAgICAgICAgc2VsZi5vZmYoZXZlbnQsIGV2ZW50c1tpXS5mbiwgZXZlbnRzW2ldLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUGFzcyB0aGUgZXZlbnQgdHlwZSBpbnRvIGxvYWQgcXVldWUgc28gdGhhdCBpdCBjYW4gY29udGludWUgc3RlcHBpbmcuXG4gICAgICBzZWxmLl9sb2FkUXVldWUoZXZlbnQpO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUXVldWUgb2YgYWN0aW9ucyBpbml0aWF0ZWQgYmVmb3JlIHRoZSBzb3VuZCBoYXMgbG9hZGVkLlxuICAgICAqIFRoZXNlIHdpbGwgYmUgY2FsbGVkIGluIHNlcXVlbmNlLCB3aXRoIHRoZSBuZXh0IG9ubHkgZmlyaW5nXG4gICAgICogYWZ0ZXIgdGhlIHByZXZpb3VzIGhhcyBmaW5pc2hlZCBleGVjdXRpbmcgKGV2ZW4gaWYgYXN5bmMgbGlrZSBwbGF5KS5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIF9sb2FkUXVldWU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmIChzZWxmLl9xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB0YXNrID0gc2VsZi5fcXVldWVbMF07XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoaXMgdGFzayBpZiBhIG1hdGNoaW5nIGV2ZW50IHdhcyBwYXNzZWQuXG4gICAgICAgIGlmICh0YXNrLmV2ZW50ID09PSBldmVudCkge1xuICAgICAgICAgIHNlbGYuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgc2VsZi5fbG9hZFF1ZXVlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSdW4gdGhlIHRhc2sgaWYgbm8gZXZlbnQgdHlwZSBpcyBwYXNzZWQuXG4gICAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgICB0YXNrLmFjdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHBsYXliYWNrIGVuZHMgYXQgdGhlIGVuZCBvZiB0aGUgZHVyYXRpb24uXG4gICAgICogQHBhcmFtICB7U291bmR9IHNvdW5kIFRoZSBzb3VuZCBvYmplY3QgdG8gd29yayB3aXRoLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgX2VuZGVkOiBmdW5jdGlvbihzb3VuZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNwcml0ZSA9IHNvdW5kLl9zcHJpdGU7XG5cbiAgICAgIC8vIElmIHdlIGFyZSB1c2luZyBJRSBhbmQgdGhlcmUgd2FzIG5ldHdvcmsgbGF0ZW5jeSB3ZSBtYXkgYmUgY2xpcHBpbmdcbiAgICAgIC8vIGF1ZGlvIGJlZm9yZSBpdCBjb21wbGV0ZXMgcGxheWluZy4gTGV0cyBjaGVjayB0aGUgbm9kZSB0byBtYWtlIHN1cmUgaXRcbiAgICAgIC8vIGJlbGlldmVzIGl0IGhhcyBjb21wbGV0ZWQsIGJlZm9yZSBlbmRpbmcgdGhlIHBsYXliYWNrLlxuICAgICAgaWYgKCFzZWxmLl93ZWJBdWRpbyAmJiBzb3VuZC5fbm9kZSAmJiAhc291bmQuX25vZGUucGF1c2VkICYmICFzb3VuZC5fbm9kZS5lbmRlZCAmJiBzb3VuZC5fbm9kZS5jdXJyZW50VGltZSA8IHNvdW5kLl9zdG9wKSB7XG4gICAgICAgIHNldFRpbWVvdXQoc2VsZi5fZW5kZWQuYmluZChzZWxmLCBzb3VuZCksIDEwMCk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICAvLyBTaG91bGQgdGhpcyBzb3VuZCBsb29wP1xuICAgICAgdmFyIGxvb3AgPSAhIShzb3VuZC5fbG9vcCB8fCBzZWxmLl9zcHJpdGVbc3ByaXRlXVsyXSk7XG5cbiAgICAgIC8vIEZpcmUgdGhlIGVuZGVkIGV2ZW50LlxuICAgICAgc2VsZi5fZW1pdCgnZW5kJywgc291bmQuX2lkKTtcblxuICAgICAgLy8gUmVzdGFydCB0aGUgcGxheWJhY2sgZm9yIEhUTUw1IEF1ZGlvIGxvb3AuXG4gICAgICBpZiAoIXNlbGYuX3dlYkF1ZGlvICYmIGxvb3ApIHtcbiAgICAgICAgc2VsZi5zdG9wKHNvdW5kLl9pZCwgdHJ1ZSkucGxheShzb3VuZC5faWQpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXN0YXJ0IHRoaXMgdGltZXIgaWYgb24gYSBXZWIgQXVkaW8gbG9vcC5cbiAgICAgIGlmIChzZWxmLl93ZWJBdWRpbyAmJiBsb29wKSB7XG4gICAgICAgIHNlbGYuX2VtaXQoJ3BsYXknLCBzb3VuZC5faWQpO1xuICAgICAgICBzb3VuZC5fc2VlayA9IHNvdW5kLl9zdGFydCB8fCAwO1xuICAgICAgICBzb3VuZC5fcmF0ZVNlZWsgPSAwO1xuICAgICAgICBzb3VuZC5fcGxheVN0YXJ0ID0gSG93bGVyLmN0eC5jdXJyZW50VGltZTtcblxuICAgICAgICB2YXIgdGltZW91dCA9ICgoc291bmQuX3N0b3AgLSBzb3VuZC5fc3RhcnQpICogMTAwMCkgLyBNYXRoLmFicyhzb3VuZC5fcmF0ZSk7XG4gICAgICAgIHNlbGYuX2VuZFRpbWVyc1tzb3VuZC5faWRdID0gc2V0VGltZW91dChzZWxmLl9lbmRlZC5iaW5kKHNlbGYsIHNvdW5kKSwgdGltZW91dCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1hcmsgdGhlIG5vZGUgYXMgcGF1c2VkLlxuICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvICYmICFsb29wKSB7XG4gICAgICAgIHNvdW5kLl9wYXVzZWQgPSB0cnVlO1xuICAgICAgICBzb3VuZC5fZW5kZWQgPSB0cnVlO1xuICAgICAgICBzb3VuZC5fc2VlayA9IHNvdW5kLl9zdGFydCB8fCAwO1xuICAgICAgICBzb3VuZC5fcmF0ZVNlZWsgPSAwO1xuICAgICAgICBzZWxmLl9jbGVhclRpbWVyKHNvdW5kLl9pZCk7XG5cbiAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGJ1ZmZlciBzb3VyY2UuXG4gICAgICAgIHNlbGYuX2NsZWFuQnVmZmVyKHNvdW5kLl9ub2RlKTtcblxuICAgICAgICAvLyBBdHRlbXB0IHRvIGF1dG8tc3VzcGVuZCBBdWRpb0NvbnRleHQgaWYgbm8gc291bmRzIGFyZSBzdGlsbCBwbGF5aW5nLlxuICAgICAgICBIb3dsZXIuX2F1dG9TdXNwZW5kKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdoZW4gdXNpbmcgYSBzcHJpdGUsIGVuZCB0aGUgdHJhY2suXG4gICAgICBpZiAoIXNlbGYuX3dlYkF1ZGlvICYmICFsb29wKSB7XG4gICAgICAgIHNlbGYuc3RvcChzb3VuZC5faWQsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIGVuZCB0aW1lciBmb3IgYSBzb3VuZCBwbGF5YmFjay5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIFRoZSBzb3VuZCBJRC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIF9jbGVhclRpbWVyOiBmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAoc2VsZi5fZW5kVGltZXJzW2lkXSkge1xuICAgICAgICAvLyBDbGVhciB0aGUgdGltZW91dCBvciByZW1vdmUgdGhlIGVuZGVkIGxpc3RlbmVyLlxuICAgICAgICBpZiAodHlwZW9mIHNlbGYuX2VuZFRpbWVyc1tpZF0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoc2VsZi5fZW5kVGltZXJzW2lkXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkKTtcbiAgICAgICAgICBpZiAoc291bmQgJiYgc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgIHNvdW5kLl9ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgc2VsZi5fZW5kVGltZXJzW2lkXSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBzZWxmLl9lbmRUaW1lcnNbaWRdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBzb3VuZCBpZGVudGlmaWVkIGJ5IHRoaXMgSUQsIG9yIHJldHVybiBudWxsLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgU291bmQgSURcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgIFNvdW5kIG9iamVjdCBvciBudWxsLlxuICAgICAqL1xuICAgIF9zb3VuZEJ5SWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgc291bmRzIGFuZCBmaW5kIHRoZSBvbmUgd2l0aCB0aGlzIElELlxuICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX3NvdW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaWQgPT09IHNlbGYuX3NvdW5kc1tpXS5faWQpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5fc291bmRzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gaW5hY3RpdmUgc291bmQgZnJvbSB0aGUgcG9vbCBvciBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAqIEByZXR1cm4ge1NvdW5kfSBTb3VuZCBwbGF5YmFjayBvYmplY3QuXG4gICAgICovXG4gICAgX2luYWN0aXZlU291bmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBzZWxmLl9kcmFpbigpO1xuXG4gICAgICAvLyBGaW5kIHRoZSBmaXJzdCBpbmFjdGl2ZSBub2RlIHRvIHJlY3ljbGUuXG4gICAgICBmb3IgKHZhciBpPTA7IGk8c2VsZi5fc291bmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmLl9zb3VuZHNbaV0uX2VuZGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuX3NvdW5kc1tpXS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vIGluYWN0aXZlIG5vZGUgd2FzIGZvdW5kLCBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAgcmV0dXJuIG5ldyBTb3VuZChzZWxmKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhaW4gZXhjZXNzIGluYWN0aXZlIHNvdW5kcyBmcm9tIHRoZSBwb29sLlxuICAgICAqL1xuICAgIF9kcmFpbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgbGltaXQgPSBzZWxmLl9wb29sO1xuICAgICAgdmFyIGNudCA9IDA7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIC8vIElmIHRoZXJlIGFyZSBsZXNzIHNvdW5kcyB0aGFuIHRoZSBtYXggcG9vbCBzaXplLCB3ZSBhcmUgZG9uZS5cbiAgICAgIGlmIChzZWxmLl9zb3VuZHMubGVuZ3RoIDwgbGltaXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIGluYWN0aXZlIHNvdW5kcy5cbiAgICAgIGZvciAoaT0wOyBpPHNlbGYuX3NvdW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5fc291bmRzW2ldLl9lbmRlZCkge1xuICAgICAgICAgIGNudCsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBleGNlc3MgaW5hY3RpdmUgc291bmRzLCBnb2luZyBpbiByZXZlcnNlIG9yZGVyLlxuICAgICAgZm9yIChpPXNlbGYuX3NvdW5kcy5sZW5ndGggLSAxOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgaWYgKGNudCA8PSBsaW1pdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLl9zb3VuZHNbaV0uX2VuZGVkKSB7XG4gICAgICAgICAgLy8gRGlzY29ubmVjdCB0aGUgYXVkaW8gc291cmNlIHdoZW4gdXNpbmcgV2ViIEF1ZGlvLlxuICAgICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbyAmJiBzZWxmLl9zb3VuZHNbaV0uX25vZGUpIHtcbiAgICAgICAgICAgIHNlbGYuX3NvdW5kc1tpXS5fbm9kZS5kaXNjb25uZWN0KDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlbW92ZSBzb3VuZHMgdW50aWwgd2UgaGF2ZSB0aGUgcG9vbCBzaXplLlxuICAgICAgICAgIHNlbGYuX3NvdW5kcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgY250LS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBJRCdzIGZyb20gdGhlIHNvdW5kcyBwb29sLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgT25seSByZXR1cm4gb25lIElEIGlmIG9uZSBpcyBwYXNzZWQuXG4gICAgICogQHJldHVybiB7QXJyYXl9ICAgIEFycmF5IG9mIElEcy5cbiAgICAgKi9cbiAgICBfZ2V0U291bmRJZHM6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBpZHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX3NvdW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlkcy5wdXNoKHNlbGYuX3NvdW5kc1tpXS5faWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlkcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbaWRdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSBzb3VuZCBiYWNrIGludG8gdGhlIGJ1ZmZlciBzb3VyY2UuXG4gICAgICogQHBhcmFtICB7U291bmR9IHNvdW5kIFRoZSBzb3VuZCBvYmplY3QgdG8gd29yayB3aXRoLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgX3JlZnJlc2hCdWZmZXI6IGZ1bmN0aW9uKHNvdW5kKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIFNldHVwIHRoZSBidWZmZXIgc291cmNlIGZvciBwbGF5YmFjay5cbiAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZSA9IEhvd2xlci5jdHguY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UuYnVmZmVyID0gY2FjaGVbc2VsZi5fc3JjXTtcblxuICAgICAgLy8gQ29ubmVjdCB0byB0aGUgY29ycmVjdCBub2RlLlxuICAgICAgaWYgKHNvdW5kLl9wYW5uZXIpIHtcbiAgICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLmNvbm5lY3Qoc291bmQuX3Bhbm5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UuY29ubmVjdChzb3VuZC5fbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldHVwIGxvb3BpbmcgYW5kIHBsYXliYWNrIHJhdGUuXG4gICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UubG9vcCA9IHNvdW5kLl9sb29wO1xuICAgICAgaWYgKHNvdW5kLl9sb29wKSB7XG4gICAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5sb29wU3RhcnQgPSBzb3VuZC5fc3RhcnQgfHwgMDtcbiAgICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLmxvb3BFbmQgPSBzb3VuZC5fc3RvcCB8fCAwO1xuICAgICAgfVxuICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLnBsYXliYWNrUmF0ZS5zZXRWYWx1ZUF0VGltZShzb3VuZC5fcmF0ZSwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmV2ZW50IG1lbW9yeSBsZWFrcyBieSBjbGVhbmluZyB1cCB0aGUgYnVmZmVyIHNvdXJjZSBhZnRlciBwbGF5YmFjay5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG5vZGUgU291bmQncyBhdWRpbyBub2RlIGNvbnRhaW5pbmcgdGhlIGJ1ZmZlciBzb3VyY2UuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBfY2xlYW5CdWZmZXI6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBpc0lPUyA9IEhvd2xlci5fbmF2aWdhdG9yICYmIEhvd2xlci5fbmF2aWdhdG9yLnZlbmRvci5pbmRleE9mKCdBcHBsZScpID49IDA7XG5cbiAgICAgIGlmICghbm9kZS5idWZmZXJTb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIGlmIChIb3dsZXIuX3NjcmF0Y2hCdWZmZXIgJiYgbm9kZS5idWZmZXJTb3VyY2UpIHtcbiAgICAgICAgbm9kZS5idWZmZXJTb3VyY2Uub25lbmRlZCA9IG51bGw7XG4gICAgICAgIG5vZGUuYnVmZmVyU291cmNlLmRpc2Nvbm5lY3QoMCk7XG4gICAgICAgIGlmIChpc0lPUykge1xuICAgICAgICAgIHRyeSB7IG5vZGUuYnVmZmVyU291cmNlLmJ1ZmZlciA9IEhvd2xlci5fc2NyYXRjaEJ1ZmZlcjsgfSBjYXRjaChlKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLmJ1ZmZlclNvdXJjZSA9IG51bGw7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNvdXJjZSB0byBhIDAtc2Vjb25kIHNpbGVuY2UgdG8gc3RvcCBhbnkgZG93bmxvYWRpbmcgKGV4Y2VwdCBpbiBJRSkuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBub2RlIEF1ZGlvIG5vZGUgdG8gY2xlYXIuXG4gICAgICovXG4gICAgX2NsZWFyU291bmQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBjaGVja0lFID0gL01TSUUgfFRyaWRlbnRcXC8vLnRlc3QoSG93bGVyLl9uYXZpZ2F0b3IgJiYgSG93bGVyLl9uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgIGlmICghY2hlY2tJRSkge1xuICAgICAgICBub2RlLnNyYyA9ICdkYXRhOmF1ZGlvL3dhdjtiYXNlNjQsVWtsR1JpZ0FBQUJYUVZaRlptMTBJQklBQUFBQkFBRUFSS3dBQUloWUFRQUNBQkFBQUFCa1lYUmhBZ0FBQUFFQSc7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKiBTaW5nbGUgU291bmQgTWV0aG9kcyAqKi9cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKipcbiAgICogU2V0dXAgdGhlIHNvdW5kIG9iamVjdCwgd2hpY2ggZWFjaCBub2RlIGF0dGFjaGVkIHRvIGEgSG93bCBncm91cCBpcyBjb250YWluZWQgaW4uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBob3dsIFRoZSBIb3dsIHBhcmVudCBncm91cC5cbiAgICovXG4gIHZhciBTb3VuZCA9IGZ1bmN0aW9uKGhvd2wpIHtcbiAgICB0aGlzLl9wYXJlbnQgPSBob3dsO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9O1xuICBTb3VuZC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhIG5ldyBTb3VuZCBvYmplY3QuXG4gICAgICogQHJldHVybiB7U291bmR9XG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgcGFyZW50ID0gc2VsZi5fcGFyZW50O1xuXG4gICAgICAvLyBTZXR1cCB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICAgICAgc2VsZi5fbXV0ZWQgPSBwYXJlbnQuX211dGVkO1xuICAgICAgc2VsZi5fbG9vcCA9IHBhcmVudC5fbG9vcDtcbiAgICAgIHNlbGYuX3ZvbHVtZSA9IHBhcmVudC5fdm9sdW1lO1xuICAgICAgc2VsZi5fcmF0ZSA9IHBhcmVudC5fcmF0ZTtcbiAgICAgIHNlbGYuX3NlZWsgPSAwO1xuICAgICAgc2VsZi5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHNlbGYuX2VuZGVkID0gdHJ1ZTtcbiAgICAgIHNlbGYuX3Nwcml0ZSA9ICdfX2RlZmF1bHQnO1xuXG4gICAgICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBJRCBmb3IgdGhpcyBzb3VuZC5cbiAgICAgIHNlbGYuX2lkID0gKytIb3dsZXIuX2NvdW50ZXI7XG5cbiAgICAgIC8vIEFkZCBpdHNlbGYgdG8gdGhlIHBhcmVudCdzIHBvb2wuXG4gICAgICBwYXJlbnQuX3NvdW5kcy5wdXNoKHNlbGYpO1xuXG4gICAgICAvLyBDcmVhdGUgdGhlIG5ldyBub2RlLlxuICAgICAgc2VsZi5jcmVhdGUoKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgc2V0dXAgYSBuZXcgc291bmQgb2JqZWN0LCB3aGV0aGVyIEhUTUw1IEF1ZGlvIG9yIFdlYiBBdWRpby5cbiAgICAgKiBAcmV0dXJuIHtTb3VuZH1cbiAgICAgKi9cbiAgICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHBhcmVudCA9IHNlbGYuX3BhcmVudDtcbiAgICAgIHZhciB2b2x1bWUgPSAoSG93bGVyLl9tdXRlZCB8fCBzZWxmLl9tdXRlZCB8fCBzZWxmLl9wYXJlbnQuX211dGVkKSA/IDAgOiBzZWxmLl92b2x1bWU7XG5cbiAgICAgIGlmIChwYXJlbnQuX3dlYkF1ZGlvKSB7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgZ2FpbiBub2RlIGZvciBjb250cm9sbGluZyB2b2x1bWUgKHRoZSBzb3VyY2Ugd2lsbCBjb25uZWN0IHRvIHRoaXMpLlxuICAgICAgICBzZWxmLl9ub2RlID0gKHR5cGVvZiBIb3dsZXIuY3R4LmNyZWF0ZUdhaW4gPT09ICd1bmRlZmluZWQnKSA/IEhvd2xlci5jdHguY3JlYXRlR2Fpbk5vZGUoKSA6IEhvd2xlci5jdHguY3JlYXRlR2FpbigpO1xuICAgICAgICBzZWxmLl9ub2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUodm9sdW1lLCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgc2VsZi5fbm9kZS5wYXVzZWQgPSB0cnVlO1xuICAgICAgICBzZWxmLl9ub2RlLmNvbm5lY3QoSG93bGVyLm1hc3RlckdhaW4pO1xuICAgICAgfSBlbHNlIGlmICghSG93bGVyLm5vQXVkaW8pIHtcbiAgICAgICAgLy8gR2V0IGFuIHVubG9ja2VkIEF1ZGlvIG9iamVjdCBmcm9tIHRoZSBwb29sLlxuICAgICAgICBzZWxmLl9ub2RlID0gSG93bGVyLl9vYnRhaW5IdG1sNUF1ZGlvKCk7XG5cbiAgICAgICAgLy8gTGlzdGVuIGZvciBlcnJvcnMgKGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMtYXV0aG9yLXZpZXcvc3BlYy5odG1sI21lZGlhZXJyb3IpLlxuICAgICAgICBzZWxmLl9lcnJvckZuID0gc2VsZi5fZXJyb3JMaXN0ZW5lci5iaW5kKHNlbGYpO1xuICAgICAgICBzZWxmLl9ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgc2VsZi5fZXJyb3JGbiwgZmFsc2UpO1xuXG4gICAgICAgIC8vIExpc3RlbiBmb3IgJ2NhbnBsYXl0aHJvdWdoJyBldmVudCB0byBsZXQgdXMga25vdyB0aGUgc291bmQgaXMgcmVhZHkuXG4gICAgICAgIHNlbGYuX2xvYWRGbiA9IHNlbGYuX2xvYWRMaXN0ZW5lci5iaW5kKHNlbGYpO1xuICAgICAgICBzZWxmLl9ub2RlLmFkZEV2ZW50TGlzdGVuZXIoSG93bGVyLl9jYW5QbGF5RXZlbnQsIHNlbGYuX2xvYWRGbiwgZmFsc2UpO1xuXG4gICAgICAgIC8vIExpc3RlbiBmb3IgdGhlICdlbmRlZCcgZXZlbnQgb24gdGhlIHNvdW5kIHRvIGFjY291bnQgZm9yIGVkZ2UtY2FzZSB3aGVyZVxuICAgICAgICAvLyBhIGZpbml0ZSBzb3VuZCBoYXMgYSBkdXJhdGlvbiBvZiBJbmZpbml0eS5cbiAgICAgICAgc2VsZi5fZW5kRm4gPSBzZWxmLl9lbmRMaXN0ZW5lci5iaW5kKHNlbGYpO1xuICAgICAgICBzZWxmLl9ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgc2VsZi5fZW5kRm4sIGZhbHNlKTtcblxuICAgICAgICAvLyBTZXR1cCB0aGUgbmV3IGF1ZGlvIG5vZGUuXG4gICAgICAgIHNlbGYuX25vZGUuc3JjID0gcGFyZW50Ll9zcmM7XG4gICAgICAgIHNlbGYuX25vZGUucHJlbG9hZCA9IHBhcmVudC5fcHJlbG9hZCA9PT0gdHJ1ZSA/ICdhdXRvJyA6IHBhcmVudC5fcHJlbG9hZDtcbiAgICAgICAgc2VsZi5fbm9kZS52b2x1bWUgPSB2b2x1bWUgKiBIb3dsZXIudm9sdW1lKCk7XG5cbiAgICAgICAgLy8gQmVnaW4gbG9hZGluZyB0aGUgc291cmNlLlxuICAgICAgICBzZWxmLl9ub2RlLmxvYWQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBwYXJhbWV0ZXJzIG9mIHRoaXMgc291bmQgdG8gdGhlIG9yaWdpbmFsIHN0YXRlIChmb3IgcmVjeWNsZSkuXG4gICAgICogQHJldHVybiB7U291bmR9XG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHBhcmVudCA9IHNlbGYuX3BhcmVudDtcblxuICAgICAgLy8gUmVzZXQgYWxsIG9mIHRoZSBwYXJhbWV0ZXJzIG9mIHRoaXMgc291bmQuXG4gICAgICBzZWxmLl9tdXRlZCA9IHBhcmVudC5fbXV0ZWQ7XG4gICAgICBzZWxmLl9sb29wID0gcGFyZW50Ll9sb29wO1xuICAgICAgc2VsZi5fdm9sdW1lID0gcGFyZW50Ll92b2x1bWU7XG4gICAgICBzZWxmLl9yYXRlID0gcGFyZW50Ll9yYXRlO1xuICAgICAgc2VsZi5fc2VlayA9IDA7XG4gICAgICBzZWxmLl9yYXRlU2VlayA9IDA7XG4gICAgICBzZWxmLl9wYXVzZWQgPSB0cnVlO1xuICAgICAgc2VsZi5fZW5kZWQgPSB0cnVlO1xuICAgICAgc2VsZi5fc3ByaXRlID0gJ19fZGVmYXVsdCc7XG5cbiAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IElEIHNvIHRoYXQgaXQgaXNuJ3QgY29uZnVzZWQgd2l0aCB0aGUgcHJldmlvdXMgc291bmQuXG4gICAgICBzZWxmLl9pZCA9ICsrSG93bGVyLl9jb3VudGVyO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSFRNTDUgQXVkaW8gZXJyb3IgbGlzdGVuZXIgY2FsbGJhY2suXG4gICAgICovXG4gICAgX2Vycm9yTGlzdGVuZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBGaXJlIGFuIGVycm9yIGV2ZW50IGFuZCBwYXNzIGJhY2sgdGhlIGNvZGUuXG4gICAgICBzZWxmLl9wYXJlbnQuX2VtaXQoJ2xvYWRlcnJvcicsIHNlbGYuX2lkLCBzZWxmLl9ub2RlLmVycm9yID8gc2VsZi5fbm9kZS5lcnJvci5jb2RlIDogMCk7XG5cbiAgICAgIC8vIENsZWFyIHRoZSBldmVudCBsaXN0ZW5lci5cbiAgICAgIHNlbGYuX25vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBzZWxmLl9lcnJvckZuLCBmYWxzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhUTUw1IEF1ZGlvIGNhbnBsYXl0aHJvdWdoIGxpc3RlbmVyIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIF9sb2FkTGlzdGVuZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHBhcmVudCA9IHNlbGYuX3BhcmVudDtcblxuICAgICAgLy8gUm91bmQgdXAgdGhlIGR1cmF0aW9uIHRvIGFjY291bnQgZm9yIHRoZSBsb3dlciBwcmVjaXNpb24gaW4gSFRNTDUgQXVkaW8uXG4gICAgICBwYXJlbnQuX2R1cmF0aW9uID0gTWF0aC5jZWlsKHNlbGYuX25vZGUuZHVyYXRpb24gKiAxMCkgLyAxMDtcblxuICAgICAgLy8gU2V0dXAgYSBzcHJpdGUgaWYgbm9uZSBpcyBkZWZpbmVkLlxuICAgICAgaWYgKE9iamVjdC5rZXlzKHBhcmVudC5fc3ByaXRlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcGFyZW50Ll9zcHJpdGUgPSB7X19kZWZhdWx0OiBbMCwgcGFyZW50Ll9kdXJhdGlvbiAqIDEwMDBdfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudC5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICAgIHBhcmVudC5fc3RhdGUgPSAnbG9hZGVkJztcbiAgICAgICAgcGFyZW50Ll9lbWl0KCdsb2FkJyk7XG4gICAgICAgIHBhcmVudC5fbG9hZFF1ZXVlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFyIHRoZSBldmVudCBsaXN0ZW5lci5cbiAgICAgIHNlbGYuX25vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihIb3dsZXIuX2NhblBsYXlFdmVudCwgc2VsZi5fbG9hZEZuLCBmYWxzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhUTUw1IEF1ZGlvIGVuZGVkIGxpc3RlbmVyIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIF9lbmRMaXN0ZW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgcGFyZW50ID0gc2VsZi5fcGFyZW50O1xuXG4gICAgICAvLyBPbmx5IGhhbmRsZSB0aGUgYGVuZGVkYGAgZXZlbnQgaWYgdGhlIGR1cmF0aW9uIGlzIEluZmluaXR5LlxuICAgICAgaWYgKHBhcmVudC5fZHVyYXRpb24gPT09IEluZmluaXR5KSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcGFyZW50IGR1cmF0aW9uIHRvIG1hdGNoIHRoZSByZWFsIGF1ZGlvIGR1cmF0aW9uLlxuICAgICAgICAvLyBSb3VuZCB1cCB0aGUgZHVyYXRpb24gdG8gYWNjb3VudCBmb3IgdGhlIGxvd2VyIHByZWNpc2lvbiBpbiBIVE1MNSBBdWRpby5cbiAgICAgICAgcGFyZW50Ll9kdXJhdGlvbiA9IE1hdGguY2VpbChzZWxmLl9ub2RlLmR1cmF0aW9uICogMTApIC8gMTA7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzcHJpdGUgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgcmVhbCBkdXJhdGlvbi5cbiAgICAgICAgaWYgKHBhcmVudC5fc3ByaXRlLl9fZGVmYXVsdFsxXSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICBwYXJlbnQuX3Nwcml0ZS5fX2RlZmF1bHRbMV0gPSBwYXJlbnQuX2R1cmF0aW9uICogMTAwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJ1biB0aGUgcmVndWxhciBlbmRlZCBtZXRob2QuXG4gICAgICAgIHBhcmVudC5fZW5kZWQoc2VsZik7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFyIHRoZSBldmVudCBsaXN0ZW5lciBzaW5jZSB0aGUgZHVyYXRpb24gaXMgbm93IGNvcnJlY3QuXG4gICAgICBzZWxmLl9ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgc2VsZi5fZW5kRm4sIGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqIEhlbHBlciBNZXRob2RzICoqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIHZhciBjYWNoZSA9IHt9O1xuXG4gIC8qKlxuICAgKiBCdWZmZXIgYSBzb3VuZCBmcm9tIFVSTCwgRGF0YSBVUkkgb3IgY2FjaGUgYW5kIGRlY29kZSB0byBhdWRpbyBzb3VyY2UgKFdlYiBBdWRpbyBBUEkpLlxuICAgKiBAcGFyYW0gIHtIb3dsfSBzZWxmXG4gICAqL1xuICB2YXIgbG9hZEJ1ZmZlciA9IGZ1bmN0aW9uKHNlbGYpIHtcbiAgICB2YXIgdXJsID0gc2VsZi5fc3JjO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGJ1ZmZlciBoYXMgYWxyZWFkeSBiZWVuIGNhY2hlZCBhbmQgdXNlIGl0IGluc3RlYWQuXG4gICAgaWYgKGNhY2hlW3VybF0pIHtcbiAgICAgIC8vIFNldCB0aGUgZHVyYXRpb24gZnJvbSB0aGUgY2FjaGUuXG4gICAgICBzZWxmLl9kdXJhdGlvbiA9IGNhY2hlW3VybF0uZHVyYXRpb247XG5cbiAgICAgIC8vIExvYWQgdGhlIHNvdW5kIGludG8gdGhpcyBIb3dsLlxuICAgICAgbG9hZFNvdW5kKHNlbGYpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKC9eZGF0YTpbXjtdKztiYXNlNjQsLy50ZXN0KHVybCkpIHtcbiAgICAgIC8vIERlY29kZSB0aGUgYmFzZTY0IGRhdGEgVVJJIHdpdGhvdXQgWEhSLCBzaW5jZSBzb21lIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgaXQuXG4gICAgICB2YXIgZGF0YSA9IGF0b2IodXJsLnNwbGl0KCcsJylbMV0pO1xuICAgICAgdmFyIGRhdGFWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaT0wOyBpPGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZGF0YVZpZXdbaV0gPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG5cbiAgICAgIGRlY29kZUF1ZGlvRGF0YShkYXRhVmlldy5idWZmZXIsIHNlbGYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMb2FkIHRoZSBidWZmZXIgZnJvbSB0aGUgVVJMLlxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9wZW4oc2VsZi5feGhyLm1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSBzZWxmLl94aHIud2l0aENyZWRlbnRpYWxzO1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cbiAgICAgIC8vIEFwcGx5IGFueSBjdXN0b20gaGVhZGVycyB0byB0aGUgcmVxdWVzdC5cbiAgICAgIGlmIChzZWxmLl94aHIuaGVhZGVycykge1xuICAgICAgICBPYmplY3Qua2V5cyhzZWxmLl94aHIuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHNlbGYuX3hoci5oZWFkZXJzW2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZ2V0IGEgc3VjY2Vzc2Z1bCByZXNwb25zZSBiYWNrLlxuICAgICAgICB2YXIgY29kZSA9ICh4aHIuc3RhdHVzICsgJycpWzBdO1xuICAgICAgICBpZiAoY29kZSAhPT0gJzAnICYmIGNvZGUgIT09ICcyJyAmJiBjb2RlICE9PSAnMycpIHtcbiAgICAgICAgICBzZWxmLl9lbWl0KCdsb2FkZXJyb3InLCBudWxsLCAnRmFpbGVkIGxvYWRpbmcgYXVkaW8gZmlsZSB3aXRoIHN0YXR1czogJyArIHhoci5zdGF0dXMgKyAnLicpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29kZUF1ZGlvRGF0YSh4aHIucmVzcG9uc2UsIHNlbGYpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGVycm9yLCBzd2l0Y2ggdG8gSFRNTDUgQXVkaW8uXG4gICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICAgIHNlbGYuX2h0bWw1ID0gdHJ1ZTtcbiAgICAgICAgICBzZWxmLl93ZWJBdWRpbyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuX3NvdW5kcyA9IFtdO1xuICAgICAgICAgIGRlbGV0ZSBjYWNoZVt1cmxdO1xuICAgICAgICAgIHNlbGYubG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2FmZVhoclNlbmQoeGhyKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNlbmQgdGhlIFhIUiByZXF1ZXN0IHdyYXBwZWQgaW4gYSB0cnkvY2F0Y2guXG4gICAqIEBwYXJhbSAge09iamVjdH0geGhyIFhIUiB0byBzZW5kLlxuICAgKi9cbiAgdmFyIHNhZmVYaHJTZW5kID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHhoci5zZW5kKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgeGhyLm9uZXJyb3IoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY29kZSBhdWRpbyBkYXRhIGZyb20gYW4gYXJyYXkgYnVmZmVyLlxuICAgKiBAcGFyYW0gIHtBcnJheUJ1ZmZlcn0gYXJyYXlidWZmZXIgVGhlIGF1ZGlvIGRhdGEuXG4gICAqIEBwYXJhbSAge0hvd2x9ICAgICAgICBzZWxmXG4gICAqL1xuICB2YXIgZGVjb2RlQXVkaW9EYXRhID0gZnVuY3Rpb24oYXJyYXlidWZmZXIsIHNlbGYpIHtcbiAgICAvLyBGaXJlIGEgbG9hZCBlcnJvciBpZiBzb21ldGhpbmcgYnJva2UuXG4gICAgdmFyIGVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLl9lbWl0KCdsb2FkZXJyb3InLCBudWxsLCAnRGVjb2RpbmcgYXVkaW8gZGF0YSBmYWlsZWQuJyk7XG4gICAgfTtcblxuICAgIC8vIExvYWQgdGhlIHNvdW5kIG9uIHN1Y2Nlc3MuXG4gICAgdmFyIHN1Y2Nlc3MgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIGlmIChidWZmZXIgJiYgc2VsZi5fc291bmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY2FjaGVbc2VsZi5fc3JjXSA9IGJ1ZmZlcjtcbiAgICAgICAgbG9hZFNvdW5kKHNlbGYsIGJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcigpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBEZWNvZGUgdGhlIGJ1ZmZlciBpbnRvIGFuIGF1ZGlvIHNvdXJjZS5cbiAgICBpZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIEhvd2xlci5jdHguZGVjb2RlQXVkaW9EYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgSG93bGVyLmN0eC5kZWNvZGVBdWRpb0RhdGEoYXJyYXlidWZmZXIpLnRoZW4oc3VjY2VzcykuY2F0Y2goZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBIb3dsZXIuY3R4LmRlY29kZUF1ZGlvRGF0YShhcnJheWJ1ZmZlciwgc3VjY2VzcywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTb3VuZCBpcyBub3cgbG9hZGVkLCBzbyBmaW5pc2ggc2V0dGluZyBldmVyeXRoaW5nIHVwIGFuZCBmaXJlIHRoZSBsb2FkZWQgZXZlbnQuXG4gICAqIEBwYXJhbSAge0hvd2x9IHNlbGZcbiAgICogQHBhcmFtICB7T2JqZWN0fSBidWZmZXIgVGhlIGRlY29kZWQgYnVmZmVyIHNvdW5kIHNvdXJjZS5cbiAgICovXG4gIHZhciBsb2FkU291bmQgPSBmdW5jdGlvbihzZWxmLCBidWZmZXIpIHtcbiAgICAvLyBTZXQgdGhlIGR1cmF0aW9uLlxuICAgIGlmIChidWZmZXIgJiYgIXNlbGYuX2R1cmF0aW9uKSB7XG4gICAgICBzZWxmLl9kdXJhdGlvbiA9IGJ1ZmZlci5kdXJhdGlvbjtcbiAgICB9XG5cbiAgICAvLyBTZXR1cCBhIHNwcml0ZSBpZiBub25lIGlzIGRlZmluZWQuXG4gICAgaWYgKE9iamVjdC5rZXlzKHNlbGYuX3Nwcml0ZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBzZWxmLl9zcHJpdGUgPSB7X19kZWZhdWx0OiBbMCwgc2VsZi5fZHVyYXRpb24gKiAxMDAwXX07XG4gICAgfVxuXG4gICAgLy8gRmlyZSB0aGUgbG9hZGVkIGV2ZW50LlxuICAgIGlmIChzZWxmLl9zdGF0ZSAhPT0gJ2xvYWRlZCcpIHtcbiAgICAgIHNlbGYuX3N0YXRlID0gJ2xvYWRlZCc7XG4gICAgICBzZWxmLl9lbWl0KCdsb2FkJyk7XG4gICAgICBzZWxmLl9sb2FkUXVldWUoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHVwIHRoZSBhdWRpbyBjb250ZXh0IHdoZW4gYXZhaWxhYmxlLCBvciBzd2l0Y2ggdG8gSFRNTDUgQXVkaW8gbW9kZS5cbiAgICovXG4gIHZhciBzZXR1cEF1ZGlvQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIElmIHdlIGhhdmUgYWxyZWFkeSBkZXRlY3RlZCB0aGF0IFdlYiBBdWRpbyBpc24ndCBzdXBwb3J0ZWQsIGRvbid0IHJ1biB0aGlzIHN0ZXAgYWdhaW4uXG4gICAgaWYgKCFIb3dsZXIudXNpbmdXZWJBdWRpbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHdlIGFyZSB1c2luZyBXZWIgQXVkaW8gYW5kIHNldHVwIHRoZSBBdWRpb0NvbnRleHQgaWYgd2UgYXJlLlxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIEF1ZGlvQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgSG93bGVyLmN0eCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdlYmtpdEF1ZGlvQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgSG93bGVyLmN0eCA9IG5ldyB3ZWJraXRBdWRpb0NvbnRleHQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEhvd2xlci51c2luZ1dlYkF1ZGlvID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBIb3dsZXIudXNpbmdXZWJBdWRpbyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBhdWRpbyBjb250ZXh0IGNyZWF0aW9uIHN0aWxsIGZhaWxlZCwgc2V0IHVzaW5nIHdlYiBhdWRpbyB0byBmYWxzZS5cbiAgICBpZiAoIUhvd2xlci5jdHgpIHtcbiAgICAgIEhvd2xlci51c2luZ1dlYkF1ZGlvID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgYSB3ZWJ2aWV3IGlzIGJlaW5nIHVzZWQgb24gaU9TOCBvciBlYXJsaWVyIChyYXRoZXIgdGhhbiB0aGUgYnJvd3NlcikuXG4gICAgLy8gSWYgaXQgaXMsIGRpc2FibGUgV2ViIEF1ZGlvIGFzIGl0IGNhdXNlcyBjcmFzaGluZy5cbiAgICB2YXIgaU9TID0gKC9pUChob25lfG9kfGFkKS8udGVzdChIb3dsZXIuX25hdmlnYXRvciAmJiBIb3dsZXIuX25hdmlnYXRvci5wbGF0Zm9ybSkpO1xuICAgIHZhciBhcHBWZXJzaW9uID0gSG93bGVyLl9uYXZpZ2F0b3IgJiYgSG93bGVyLl9uYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCgvT1MgKFxcZCspXyhcXGQrKV8/KFxcZCspPy8pO1xuICAgIHZhciB2ZXJzaW9uID0gYXBwVmVyc2lvbiA/IHBhcnNlSW50KGFwcFZlcnNpb25bMV0sIDEwKSA6IG51bGw7XG4gICAgaWYgKGlPUyAmJiB2ZXJzaW9uICYmIHZlcnNpb24gPCA5KSB7XG4gICAgICB2YXIgc2FmYXJpID0gL3NhZmFyaS8udGVzdChIb3dsZXIuX25hdmlnYXRvciAmJiBIb3dsZXIuX25hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG4gICAgICBpZiAoSG93bGVyLl9uYXZpZ2F0b3IgJiYgIXNhZmFyaSkge1xuICAgICAgICBIb3dsZXIudXNpbmdXZWJBdWRpbyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhbmQgZXhwb3NlIHRoZSBtYXN0ZXIgR2Fpbk5vZGUgd2hlbiB1c2luZyBXZWIgQXVkaW8gKHVzZWZ1bCBmb3IgcGx1Z2lucyBvciBhZHZhbmNlZCB1c2FnZSkuXG4gICAgaWYgKEhvd2xlci51c2luZ1dlYkF1ZGlvKSB7XG4gICAgICBIb3dsZXIubWFzdGVyR2FpbiA9ICh0eXBlb2YgSG93bGVyLmN0eC5jcmVhdGVHYWluID09PSAndW5kZWZpbmVkJykgPyBIb3dsZXIuY3R4LmNyZWF0ZUdhaW5Ob2RlKCkgOiBIb3dsZXIuY3R4LmNyZWF0ZUdhaW4oKTtcbiAgICAgIEhvd2xlci5tYXN0ZXJHYWluLmdhaW4uc2V0VmFsdWVBdFRpbWUoSG93bGVyLl9tdXRlZCA/IDAgOiBIb3dsZXIuX3ZvbHVtZSwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICBIb3dsZXIubWFzdGVyR2Fpbi5jb25uZWN0KEhvd2xlci5jdHguZGVzdGluYXRpb24pO1xuICAgIH1cblxuICAgIC8vIFJlLXJ1biB0aGUgc2V0dXAgb24gSG93bGVyLlxuICAgIEhvd2xlci5fc2V0dXAoKTtcbiAgfTtcblxuICAvLyBBZGQgc3VwcG9ydCBmb3IgQU1EIChBc3luY2hyb25vdXMgTW9kdWxlIERlZmluaXRpb24pIGxpYnJhcmllcyBzdWNoIGFzIHJlcXVpcmUuanMuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgSG93bGVyOiBIb3dsZXIsXG4gICAgICAgIEhvd2w6IEhvd2xcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvLyBBZGQgc3VwcG9ydCBmb3IgQ29tbW9uSlMgbGlicmFyaWVzIHN1Y2ggYXMgYnJvd3NlcmlmeS5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMuSG93bGVyID0gSG93bGVyO1xuICAgIGV4cG9ydHMuSG93bCA9IEhvd2w7XG4gIH1cblxuICAvLyBBZGQgdG8gZ2xvYmFsIGluIE5vZGUuanMgKGZvciB0ZXN0aW5nLCBldGMpLlxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBnbG9iYWwuSG93bGVyR2xvYmFsID0gSG93bGVyR2xvYmFsO1xuICAgIGdsb2JhbC5Ib3dsZXIgPSBIb3dsZXI7XG4gICAgZ2xvYmFsLkhvd2wgPSBIb3dsO1xuICAgIGdsb2JhbC5Tb3VuZCA9IFNvdW5kO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7ICAvLyBEZWZpbmUgZ2xvYmFsbHkgaW4gY2FzZSBBTUQgaXMgbm90IGF2YWlsYWJsZSBvciB1bnVzZWQuXG4gICAgd2luZG93Lkhvd2xlckdsb2JhbCA9IEhvd2xlckdsb2JhbDtcbiAgICB3aW5kb3cuSG93bGVyID0gSG93bGVyO1xuICAgIHdpbmRvdy5Ib3dsID0gSG93bDtcbiAgICB3aW5kb3cuU291bmQgPSBTb3VuZDtcbiAgfVxufSkoKTtcblxuXG4vKiFcbiAqICBTcGF0aWFsIFBsdWdpbiAtIEFkZHMgc3VwcG9ydCBmb3Igc3RlcmVvIGFuZCAzRCBhdWRpbyB3aGVyZSBXZWIgQXVkaW8gaXMgc3VwcG9ydGVkLlxuICogIFxuICogIGhvd2xlci5qcyB2Mi4yLjRcbiAqICBob3dsZXJqcy5jb21cbiAqXG4gKiAgKGMpIDIwMTMtMjAyMCwgSmFtZXMgU2ltcHNvbiBvZiBHb2xkRmlyZSBTdHVkaW9zXG4gKiAgZ29sZGZpcmVzdHVkaW9zLmNvbVxuICpcbiAqICBNSVQgTGljZW5zZVxuICovXG5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gU2V0dXAgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICBIb3dsZXJHbG9iYWwucHJvdG90eXBlLl9wb3MgPSBbMCwgMCwgMF07XG4gIEhvd2xlckdsb2JhbC5wcm90b3R5cGUuX29yaWVudGF0aW9uID0gWzAsIDAsIC0xLCAwLCAxLCAwXTtcblxuICAvKiogR2xvYmFsIE1ldGhvZHMgKiovXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgdG8gdXBkYXRlIHRoZSBzdGVyZW8gcGFubmluZyBwb3NpdGlvbiBvZiBhbGwgY3VycmVudCBIb3dscy5cbiAgICogRnV0dXJlIEhvd2xzIHdpbGwgbm90IHVzZSB0aGlzIHZhbHVlIHVubGVzcyBleHBsaWNpdGx5IHNldC5cbiAgICogQHBhcmFtICB7TnVtYmVyfSBwYW4gQSB2YWx1ZSBvZiAtMS4wIGlzIGFsbCB0aGUgd2F5IGxlZnQgYW5kIDEuMCBpcyBhbGwgdGhlIHdheSByaWdodC5cbiAgICogQHJldHVybiB7SG93bGVyL051bWJlcn0gICAgIFNlbGYgb3IgY3VycmVudCBzdGVyZW8gcGFubmluZyB2YWx1ZS5cbiAgICovXG4gIEhvd2xlckdsb2JhbC5wcm90b3R5cGUuc3RlcmVvID0gZnVuY3Rpb24ocGFuKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gU3RvcCByaWdodCBoZXJlIGlmIG5vdCB1c2luZyBXZWIgQXVkaW8uXG4gICAgaWYgKCFzZWxmLmN0eCB8fCAhc2VsZi5jdHgubGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgSG93bHMgYW5kIHVwZGF0ZSB0aGVpciBzdGVyZW8gcGFubmluZy5cbiAgICBmb3IgKHZhciBpPXNlbGYuX2hvd2xzLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcbiAgICAgIHNlbGYuX2hvd2xzW2ldLnN0ZXJlbyhwYW4pO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgbGlzdGVuZXIgaW4gM0QgY2FydGVzaWFuIHNwYWNlLiBTb3VuZHMgdXNpbmdcbiAgICogM0QgcG9zaXRpb24gd2lsbCBiZSByZWxhdGl2ZSB0byB0aGUgbGlzdGVuZXIncyBwb3NpdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB4IFRoZSB4LXBvc2l0aW9uIG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB5IFRoZSB5LXBvc2l0aW9uIG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB6IFRoZSB6LXBvc2l0aW9uIG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7SG93bGVyL0FycmF5fSAgIFNlbGYgb3IgY3VycmVudCBsaXN0ZW5lciBwb3NpdGlvbi5cbiAgICovXG4gIEhvd2xlckdsb2JhbC5wcm90b3R5cGUucG9zID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFN0b3AgcmlnaHQgaGVyZSBpZiBub3QgdXNpbmcgV2ViIEF1ZGlvLlxuICAgIGlmICghc2VsZi5jdHggfHwgIXNlbGYuY3R4Lmxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIGRlZmF1bHRzIGZvciBvcHRpb25hbCAneScgJiAneicuXG4gICAgeSA9ICh0eXBlb2YgeSAhPT0gJ251bWJlcicpID8gc2VsZi5fcG9zWzFdIDogeTtcbiAgICB6ID0gKHR5cGVvZiB6ICE9PSAnbnVtYmVyJykgPyBzZWxmLl9wb3NbMl0gOiB6O1xuXG4gICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgc2VsZi5fcG9zID0gW3gsIHksIHpdO1xuXG4gICAgICBpZiAodHlwZW9mIHNlbGYuY3R4Lmxpc3RlbmVyLnBvc2l0aW9uWCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VsZi5jdHgubGlzdGVuZXIucG9zaXRpb25YLnNldFRhcmdldEF0VGltZShzZWxmLl9wb3NbMF0sIEhvd2xlci5jdHguY3VycmVudFRpbWUsIDAuMSk7XG4gICAgICAgIHNlbGYuY3R4Lmxpc3RlbmVyLnBvc2l0aW9uWS5zZXRUYXJnZXRBdFRpbWUoc2VsZi5fcG9zWzFdLCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lLCAwLjEpO1xuICAgICAgICBzZWxmLmN0eC5saXN0ZW5lci5wb3NpdGlvblouc2V0VGFyZ2V0QXRUaW1lKHNlbGYuX3Bvc1syXSwgSG93bGVyLmN0eC5jdXJyZW50VGltZSwgMC4xKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuY3R4Lmxpc3RlbmVyLnNldFBvc2l0aW9uKHNlbGYuX3Bvc1swXSwgc2VsZi5fcG9zWzFdLCBzZWxmLl9wb3NbMl0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2VsZi5fcG9zO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IHRoZSBkaXJlY3Rpb24gdGhlIGxpc3RlbmVyIGlzIHBvaW50aW5nIGluIHRoZSAzRCBjYXJ0ZXNpYW4gc3BhY2UuXG4gICAqIEEgZnJvbnQgYW5kIHVwIHZlY3RvciBtdXN0IGJlIHByb3ZpZGVkLiBUaGUgZnJvbnQgaXMgdGhlIGRpcmVjdGlvbiB0aGVcbiAgICogZmFjZSBvZiB0aGUgbGlzdGVuZXIgaXMgcG9pbnRpbmcsIGFuZCB1cCBpcyB0aGUgZGlyZWN0aW9uIHRoZSB0b3Agb2YgdGhlXG4gICAqIGxpc3RlbmVyIGlzIHBvaW50aW5nLiBUaHVzLCB0aGVzZSB2YWx1ZXMgYXJlIGV4cGVjdGVkIHRvIGJlIGF0IHJpZ2h0IGFuZ2xlc1xuICAgKiBmcm9tIGVhY2ggb3RoZXIuXG4gICAqIEBwYXJhbSAge051bWJlcn0geCAgIFRoZSB4LW9yaWVudGF0aW9uIG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB5ICAgVGhlIHktb3JpZW50YXRpb24gb2YgdGhlIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHogICBUaGUgei1vcmllbnRhdGlvbiBvZiB0aGUgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSAge051bWJlcn0geFVwIFRoZSB4LW9yaWVudGF0aW9uIG9mIHRoZSB0b3Agb2YgdGhlIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHlVcCBUaGUgeS1vcmllbnRhdGlvbiBvZiB0aGUgdG9wIG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB6VXAgVGhlIHotb3JpZW50YXRpb24gb2YgdGhlIHRvcCBvZiB0aGUgbGlzdGVuZXIuXG4gICAqIEByZXR1cm4ge0hvd2xlci9BcnJheX0gICAgIFJldHVybnMgc2VsZiBvciB0aGUgY3VycmVudCBvcmllbnRhdGlvbiB2ZWN0b3JzLlxuICAgKi9cbiAgSG93bGVyR2xvYmFsLnByb3RvdHlwZS5vcmllbnRhdGlvbiA9IGZ1bmN0aW9uKHgsIHksIHosIHhVcCwgeVVwLCB6VXApIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBTdG9wIHJpZ2h0IGhlcmUgaWYgbm90IHVzaW5nIFdlYiBBdWRpby5cbiAgICBpZiAoIXNlbGYuY3R4IHx8ICFzZWxmLmN0eC5saXN0ZW5lcikge1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBkZWZhdWx0cyBmb3Igb3B0aW9uYWwgJ3knICYgJ3onLlxuICAgIHZhciBvciA9IHNlbGYuX29yaWVudGF0aW9uO1xuICAgIHkgPSAodHlwZW9mIHkgIT09ICdudW1iZXInKSA/IG9yWzFdIDogeTtcbiAgICB6ID0gKHR5cGVvZiB6ICE9PSAnbnVtYmVyJykgPyBvclsyXSA6IHo7XG4gICAgeFVwID0gKHR5cGVvZiB4VXAgIT09ICdudW1iZXInKSA/IG9yWzNdIDogeFVwO1xuICAgIHlVcCA9ICh0eXBlb2YgeVVwICE9PSAnbnVtYmVyJykgPyBvcls0XSA6IHlVcDtcbiAgICB6VXAgPSAodHlwZW9mIHpVcCAhPT0gJ251bWJlcicpID8gb3JbNV0gOiB6VXA7XG5cbiAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgICBzZWxmLl9vcmllbnRhdGlvbiA9IFt4LCB5LCB6LCB4VXAsIHlVcCwgelVwXTtcblxuICAgICAgaWYgKHR5cGVvZiBzZWxmLmN0eC5saXN0ZW5lci5mb3J3YXJkWCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VsZi5jdHgubGlzdGVuZXIuZm9yd2FyZFguc2V0VGFyZ2V0QXRUaW1lKHgsIEhvd2xlci5jdHguY3VycmVudFRpbWUsIDAuMSk7XG4gICAgICAgIHNlbGYuY3R4Lmxpc3RlbmVyLmZvcndhcmRZLnNldFRhcmdldEF0VGltZSh5LCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lLCAwLjEpO1xuICAgICAgICBzZWxmLmN0eC5saXN0ZW5lci5mb3J3YXJkWi5zZXRUYXJnZXRBdFRpbWUoeiwgSG93bGVyLmN0eC5jdXJyZW50VGltZSwgMC4xKTtcbiAgICAgICAgc2VsZi5jdHgubGlzdGVuZXIudXBYLnNldFRhcmdldEF0VGltZSh4VXAsIEhvd2xlci5jdHguY3VycmVudFRpbWUsIDAuMSk7XG4gICAgICAgIHNlbGYuY3R4Lmxpc3RlbmVyLnVwWS5zZXRUYXJnZXRBdFRpbWUoeVVwLCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lLCAwLjEpO1xuICAgICAgICBzZWxmLmN0eC5saXN0ZW5lci51cFouc2V0VGFyZ2V0QXRUaW1lKHpVcCwgSG93bGVyLmN0eC5jdXJyZW50VGltZSwgMC4xKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuY3R4Lmxpc3RlbmVyLnNldE9yaWVudGF0aW9uKHgsIHksIHosIHhVcCwgeVVwLCB6VXApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLyoqIEdyb3VwIE1ldGhvZHMgKiovXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIEFkZCBuZXcgcHJvcGVydGllcyB0byB0aGUgY29yZSBpbml0LlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gX3N1cGVyIENvcmUgaW5pdCBtZXRob2QuXG4gICAqIEByZXR1cm4ge0hvd2x9XG4gICAqL1xuICBIb3dsLnByb3RvdHlwZS5pbml0ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIFNldHVwIHVzZXItZGVmaW5lZCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICBzZWxmLl9vcmllbnRhdGlvbiA9IG8ub3JpZW50YXRpb24gfHwgWzEsIDAsIDBdO1xuICAgICAgc2VsZi5fc3RlcmVvID0gby5zdGVyZW8gfHwgbnVsbDtcbiAgICAgIHNlbGYuX3BvcyA9IG8ucG9zIHx8IG51bGw7XG4gICAgICBzZWxmLl9wYW5uZXJBdHRyID0ge1xuICAgICAgICBjb25lSW5uZXJBbmdsZTogdHlwZW9mIG8uY29uZUlubmVyQW5nbGUgIT09ICd1bmRlZmluZWQnID8gby5jb25lSW5uZXJBbmdsZSA6IDM2MCxcbiAgICAgICAgY29uZU91dGVyQW5nbGU6IHR5cGVvZiBvLmNvbmVPdXRlckFuZ2xlICE9PSAndW5kZWZpbmVkJyA/IG8uY29uZU91dGVyQW5nbGUgOiAzNjAsXG4gICAgICAgIGNvbmVPdXRlckdhaW46IHR5cGVvZiBvLmNvbmVPdXRlckdhaW4gIT09ICd1bmRlZmluZWQnID8gby5jb25lT3V0ZXJHYWluIDogMCxcbiAgICAgICAgZGlzdGFuY2VNb2RlbDogdHlwZW9mIG8uZGlzdGFuY2VNb2RlbCAhPT0gJ3VuZGVmaW5lZCcgPyBvLmRpc3RhbmNlTW9kZWwgOiAnaW52ZXJzZScsXG4gICAgICAgIG1heERpc3RhbmNlOiB0eXBlb2Ygby5tYXhEaXN0YW5jZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLm1heERpc3RhbmNlIDogMTAwMDAsXG4gICAgICAgIHBhbm5pbmdNb2RlbDogdHlwZW9mIG8ucGFubmluZ01vZGVsICE9PSAndW5kZWZpbmVkJyA/IG8ucGFubmluZ01vZGVsIDogJ0hSVEYnLFxuICAgICAgICByZWZEaXN0YW5jZTogdHlwZW9mIG8ucmVmRGlzdGFuY2UgIT09ICd1bmRlZmluZWQnID8gby5yZWZEaXN0YW5jZSA6IDEsXG4gICAgICAgIHJvbGxvZmZGYWN0b3I6IHR5cGVvZiBvLnJvbGxvZmZGYWN0b3IgIT09ICd1bmRlZmluZWQnID8gby5yb2xsb2ZmRmFjdG9yIDogMVxuICAgICAgfTtcblxuICAgICAgLy8gU2V0dXAgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgc2VsZi5fb25zdGVyZW8gPSBvLm9uc3RlcmVvID8gW3tmbjogby5vbnN0ZXJlb31dIDogW107XG4gICAgICBzZWxmLl9vbnBvcyA9IG8ub25wb3MgPyBbe2ZuOiBvLm9ucG9zfV0gOiBbXTtcbiAgICAgIHNlbGYuX29ub3JpZW50YXRpb24gPSBvLm9ub3JpZW50YXRpb24gPyBbe2ZuOiBvLm9ub3JpZW50YXRpb259XSA6IFtdO1xuXG4gICAgICAvLyBDb21wbGV0ZSBpbml0aWxpemF0aW9uIHdpdGggaG93bGVyLmpzIGNvcmUncyBpbml0IGZ1bmN0aW9uLlxuICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG8pO1xuICAgIH07XG4gIH0pKEhvd2wucHJvdG90eXBlLmluaXQpO1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IHRoZSBzdGVyZW8gcGFubmluZyBvZiB0aGUgYXVkaW8gc291cmNlIGZvciB0aGlzIHNvdW5kIG9yIGFsbCBpbiB0aGUgZ3JvdXAuXG4gICAqIEBwYXJhbSAge051bWJlcn0gcGFuICBBIHZhbHVlIG9mIC0xLjAgaXMgYWxsIHRoZSB3YXkgbGVmdCBhbmQgMS4wIGlzIGFsbCB0aGUgd2F5IHJpZ2h0LlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIChvcHRpb25hbCkgVGhlIHNvdW5kIElELiBJZiBub25lIGlzIHBhc3NlZCwgYWxsIGluIGdyb3VwIHdpbGwgYmUgdXBkYXRlZC5cbiAgICogQHJldHVybiB7SG93bC9OdW1iZXJ9ICAgIFJldHVybnMgc2VsZiBvciB0aGUgY3VycmVudCBzdGVyZW8gcGFubmluZyB2YWx1ZS5cbiAgICovXG4gIEhvd2wucHJvdG90eXBlLnN0ZXJlbyA9IGZ1bmN0aW9uKHBhbiwgaWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBTdG9wIHJpZ2h0IGhlcmUgaWYgbm90IHVzaW5nIFdlYiBBdWRpby5cbiAgICBpZiAoIXNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCwgYWRkIGl0IHRvIHRoZSBsb2FkIHF1ZXVlIHRvIGNoYW5nZSBzdGVyZW8gcGFuIHdoZW4gY2FwYWJsZS5cbiAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgZXZlbnQ6ICdzdGVyZW8nLFxuICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYuc3RlcmVvKHBhbiwgaWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIFBhbm5lclN0ZXJlb05vZGUgc3VwcG9ydCBhbmQgZmFsbGJhY2sgdG8gUGFubmVyTm9kZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgIHZhciBwYW5uZXJUeXBlID0gKHR5cGVvZiBIb3dsZXIuY3R4LmNyZWF0ZVN0ZXJlb1Bhbm5lciA9PT0gJ3VuZGVmaW5lZCcpID8gJ3NwYXRpYWwnIDogJ3N0ZXJlbyc7XG5cbiAgICAvLyBTZXR1cCB0aGUgZ3JvdXAncyBzdGVyZW8gcGFubmluZyBpZiBubyBJRCBpcyBwYXNzZWQuXG4gICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFJldHVybiB0aGUgZ3JvdXAncyBzdGVyZW8gcGFubmluZyBpZiBubyBwYXJhbWV0ZXJzIGFyZSBwYXNzZWQuXG4gICAgICBpZiAodHlwZW9mIHBhbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2VsZi5fc3RlcmVvID0gcGFuO1xuICAgICAgICBzZWxmLl9wb3MgPSBbcGFuLCAwLCAwXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9zdGVyZW87XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hhbmdlIHRoZSBzdHJlbyBwYW5uaW5nIG9mIG9uZSBvciBhbGwgc291bmRzIGluIGdyb3VwLlxuICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcyhpZCk7XG4gICAgZm9yICh2YXIgaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gR2V0IHRoZSBzb3VuZC5cbiAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZHNbaV0pO1xuXG4gICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgc291bmQuX3N0ZXJlbyA9IHBhbjtcbiAgICAgICAgICBzb3VuZC5fcG9zID0gW3BhbiwgMCwgMF07XG5cbiAgICAgICAgICBpZiAoc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBmYWxsaW5nIGJhY2ssIG1ha2Ugc3VyZSB0aGUgcGFubmluZ01vZGVsIGlzIGVxdWFscG93ZXIuXG4gICAgICAgICAgICBzb3VuZC5fcGFubmVyQXR0ci5wYW5uaW5nTW9kZWwgPSAnZXF1YWxwb3dlcic7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGEgcGFubmVyIHNldHVwIGFuZCBjcmVhdGUgYSBuZXcgb25lIGlmIG5vdC5cbiAgICAgICAgICAgIGlmICghc291bmQuX3Bhbm5lciB8fCAhc291bmQuX3Bhbm5lci5wYW4pIHtcbiAgICAgICAgICAgICAgc2V0dXBQYW5uZXIoc291bmQsIHBhbm5lclR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFubmVyVHlwZSA9PT0gJ3NwYXRpYWwnKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygc291bmQuX3Bhbm5lci5wb3NpdGlvblggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc291bmQuX3Bhbm5lci5wb3NpdGlvblguc2V0VmFsdWVBdFRpbWUocGFuLCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICBzb3VuZC5fcGFubmVyLnBvc2l0aW9uWS5zZXRWYWx1ZUF0VGltZSgwLCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICBzb3VuZC5fcGFubmVyLnBvc2l0aW9uWi5zZXRWYWx1ZUF0VGltZSgwLCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzb3VuZC5fcGFubmVyLnNldFBvc2l0aW9uKHBhbiwgMCwgMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNvdW5kLl9wYW5uZXIucGFuLnNldFZhbHVlQXRUaW1lKHBhbiwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5fZW1pdCgnc3RlcmVvJywgc291bmQuX2lkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc291bmQuX3N0ZXJlbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IHRoZSAzRCBzcGF0aWFsIHBvc2l0aW9uIG9mIHRoZSBhdWRpbyBzb3VyY2UgZm9yIHRoaXMgc291bmQgb3IgZ3JvdXAgcmVsYXRpdmUgdG8gdGhlIGdsb2JhbCBsaXN0ZW5lci5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB4ICBUaGUgeC1wb3NpdGlvbiBvZiB0aGUgYXVkaW8gc291cmNlLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHkgIFRoZSB5LXBvc2l0aW9uIG9mIHRoZSBhdWRpbyBzb3VyY2UuXG4gICAqIEBwYXJhbSAge051bWJlcn0geiAgVGhlIHotcG9zaXRpb24gb2YgdGhlIGF1ZGlvIHNvdXJjZS5cbiAgICogQHBhcmFtICB7TnVtYmVyfSBpZCAob3B0aW9uYWwpIFRoZSBzb3VuZCBJRC4gSWYgbm9uZSBpcyBwYXNzZWQsIGFsbCBpbiBncm91cCB3aWxsIGJlIHVwZGF0ZWQuXG4gICAqIEByZXR1cm4ge0hvd2wvQXJyYXl9ICAgIFJldHVybnMgc2VsZiBvciB0aGUgY3VycmVudCAzRCBzcGF0aWFsIHBvc2l0aW9uOiBbeCwgeSwgel0uXG4gICAqL1xuICBIb3dsLnByb3RvdHlwZS5wb3MgPSBmdW5jdGlvbih4LCB5LCB6LCBpZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFN0b3AgcmlnaHQgaGVyZSBpZiBub3QgdXNpbmcgV2ViIEF1ZGlvLlxuICAgIGlmICghc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBzb3VuZCBoYXNuJ3QgbG9hZGVkLCBhZGQgaXQgdG8gdGhlIGxvYWQgcXVldWUgdG8gY2hhbmdlIHBvc2l0aW9uIHdoZW4gY2FwYWJsZS5cbiAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgZXZlbnQ6ICdwb3MnLFxuICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYucG9zKHgsIHksIHosIGlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdHMgZm9yIG9wdGlvbmFsICd5JyAmICd6Jy5cbiAgICB5ID0gKHR5cGVvZiB5ICE9PSAnbnVtYmVyJykgPyAwIDogeTtcbiAgICB6ID0gKHR5cGVvZiB6ICE9PSAnbnVtYmVyJykgPyAtMC41IDogejtcblxuICAgIC8vIFNldHVwIHRoZSBncm91cCdzIHNwYXRpYWwgcG9zaXRpb24gaWYgbm8gSUQgaXMgcGFzc2VkLlxuICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBSZXR1cm4gdGhlIGdyb3VwJ3Mgc3BhdGlhbCBwb3NpdGlvbiBpZiBubyBwYXJhbWV0ZXJzIGFyZSBwYXNzZWQuXG4gICAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNlbGYuX3BvcyA9IFt4LCB5LCB6XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9wb3M7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hhbmdlIHRoZSBzcGF0aWFsIHBvc2l0aW9uIG9mIG9uZSBvciBhbGwgc291bmRzIGluIGdyb3VwLlxuICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcyhpZCk7XG4gICAgZm9yICh2YXIgaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gR2V0IHRoZSBzb3VuZC5cbiAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZHNbaV0pO1xuXG4gICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHNvdW5kLl9wb3MgPSBbeCwgeSwgel07XG5cbiAgICAgICAgICBpZiAoc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGEgcGFubmVyIHNldHVwIGFuZCBjcmVhdGUgYSBuZXcgb25lIGlmIG5vdC5cbiAgICAgICAgICAgIGlmICghc291bmQuX3Bhbm5lciB8fCBzb3VuZC5fcGFubmVyLnBhbikge1xuICAgICAgICAgICAgICBzZXR1cFBhbm5lcihzb3VuZCwgJ3NwYXRpYWwnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VuZC5fcGFubmVyLnBvc2l0aW9uWCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgc291bmQuX3Bhbm5lci5wb3NpdGlvblguc2V0VmFsdWVBdFRpbWUoeCwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgIHNvdW5kLl9wYW5uZXIucG9zaXRpb25ZLnNldFZhbHVlQXRUaW1lKHksIEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICBzb3VuZC5fcGFubmVyLnBvc2l0aW9uWi5zZXRWYWx1ZUF0VGltZSh6LCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNvdW5kLl9wYW5uZXIuc2V0UG9zaXRpb24oeCwgeSwgeik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5fZW1pdCgncG9zJywgc291bmQuX2lkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc291bmQuX3BvcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IHRoZSBkaXJlY3Rpb24gdGhlIGF1ZGlvIHNvdXJjZSBpcyBwb2ludGluZyBpbiB0aGUgM0QgY2FydGVzaWFuIGNvb3JkaW5hdGVcbiAgICogc3BhY2UuIERlcGVuZGluZyBvbiBob3cgZGlyZWN0aW9uIHRoZSBzb3VuZCBpcywgYmFzZWQgb24gdGhlIGBjb25lYCBhdHRyaWJ1dGVzLFxuICAgKiBhIHNvdW5kIHBvaW50aW5nIGF3YXkgZnJvbSB0aGUgbGlzdGVuZXIgY2FuIGJlIHF1aWV0IG9yIHNpbGVudC5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB4ICBUaGUgeC1vcmllbnRhdGlvbiBvZiB0aGUgc291cmNlLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHkgIFRoZSB5LW9yaWVudGF0aW9uIG9mIHRoZSBzb3VyY2UuXG4gICAqIEBwYXJhbSAge051bWJlcn0geiAgVGhlIHotb3JpZW50YXRpb24gb2YgdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtICB7TnVtYmVyfSBpZCAob3B0aW9uYWwpIFRoZSBzb3VuZCBJRC4gSWYgbm9uZSBpcyBwYXNzZWQsIGFsbCBpbiBncm91cCB3aWxsIGJlIHVwZGF0ZWQuXG4gICAqIEByZXR1cm4ge0hvd2wvQXJyYXl9ICAgIFJldHVybnMgc2VsZiBvciB0aGUgY3VycmVudCAzRCBzcGF0aWFsIG9yaWVudGF0aW9uOiBbeCwgeSwgel0uXG4gICAqL1xuICBIb3dsLnByb3RvdHlwZS5vcmllbnRhdGlvbiA9IGZ1bmN0aW9uKHgsIHksIHosIGlkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gU3RvcCByaWdodCBoZXJlIGlmIG5vdCB1c2luZyBXZWIgQXVkaW8uXG4gICAgaWYgKCFzZWxmLl93ZWJBdWRpbykge1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHNvdW5kIGhhc24ndCBsb2FkZWQsIGFkZCBpdCB0byB0aGUgbG9hZCBxdWV1ZSB0byBjaGFuZ2Ugb3JpZW50YXRpb24gd2hlbiBjYXBhYmxlLlxuICAgIGlmIChzZWxmLl9zdGF0ZSAhPT0gJ2xvYWRlZCcpIHtcbiAgICAgIHNlbGYuX3F1ZXVlLnB1c2goe1xuICAgICAgICBldmVudDogJ29yaWVudGF0aW9uJyxcbiAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLm9yaWVudGF0aW9uKHgsIHksIHosIGlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdHMgZm9yIG9wdGlvbmFsICd5JyAmICd6Jy5cbiAgICB5ID0gKHR5cGVvZiB5ICE9PSAnbnVtYmVyJykgPyBzZWxmLl9vcmllbnRhdGlvblsxXSA6IHk7XG4gICAgeiA9ICh0eXBlb2YgeiAhPT0gJ251bWJlcicpID8gc2VsZi5fb3JpZW50YXRpb25bMl0gOiB6O1xuXG4gICAgLy8gU2V0dXAgdGhlIGdyb3VwJ3Mgc3BhdGlhbCBvcmllbnRhdGlvbiBpZiBubyBJRCBpcyBwYXNzZWQuXG4gICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFJldHVybiB0aGUgZ3JvdXAncyBzcGF0aWFsIG9yaWVudGF0aW9uIGlmIG5vIHBhcmFtZXRlcnMgYXJlIHBhc3NlZC5cbiAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2VsZi5fb3JpZW50YXRpb24gPSBbeCwgeSwgel07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi5fb3JpZW50YXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hhbmdlIHRoZSBzcGF0aWFsIG9yaWVudGF0aW9uIG9mIG9uZSBvciBhbGwgc291bmRzIGluIGdyb3VwLlxuICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcyhpZCk7XG4gICAgZm9yICh2YXIgaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gR2V0IHRoZSBzb3VuZC5cbiAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZHNbaV0pO1xuXG4gICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHNvdW5kLl9vcmllbnRhdGlvbiA9IFt4LCB5LCB6XTtcblxuICAgICAgICAgIGlmIChzb3VuZC5fbm9kZSkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYSBwYW5uZXIgc2V0dXAgYW5kIGNyZWF0ZSBhIG5ldyBvbmUgaWYgbm90LlxuICAgICAgICAgICAgaWYgKCFzb3VuZC5fcGFubmVyKSB7XG4gICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgcG9zaXRpb24gdG8gc2V0dXAgdGhlIG5vZGUgd2l0aC5cbiAgICAgICAgICAgICAgaWYgKCFzb3VuZC5fcG9zKSB7XG4gICAgICAgICAgICAgICAgc291bmQuX3BvcyA9IHNlbGYuX3BvcyB8fCBbMCwgMCwgLTAuNV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzZXR1cFBhbm5lcihzb3VuZCwgJ3NwYXRpYWwnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VuZC5fcGFubmVyLm9yaWVudGF0aW9uWCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgc291bmQuX3Bhbm5lci5vcmllbnRhdGlvblguc2V0VmFsdWVBdFRpbWUoeCwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgIHNvdW5kLl9wYW5uZXIub3JpZW50YXRpb25ZLnNldFZhbHVlQXRUaW1lKHksIEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICBzb3VuZC5fcGFubmVyLm9yaWVudGF0aW9uWi5zZXRWYWx1ZUF0VGltZSh6LCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNvdW5kLl9wYW5uZXIuc2V0T3JpZW50YXRpb24oeCwgeSwgeik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5fZW1pdCgnb3JpZW50YXRpb24nLCBzb3VuZC5faWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzb3VuZC5fb3JpZW50YXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICAvKipcbiAgICogR2V0L3NldCB0aGUgcGFubmVyIG5vZGUncyBhdHRyaWJ1dGVzIGZvciBhIHNvdW5kIG9yIGdyb3VwIG9mIHNvdW5kcy5cbiAgICogVGhpcyBtZXRob2QgY2FuIG9wdGlvbmFsbCB0YWtlIDAsIDEgb3IgMiBhcmd1bWVudHMuXG4gICAqICAgcGFubmVyQXR0cigpIC0+IFJldHVybnMgdGhlIGdyb3VwJ3MgdmFsdWVzLlxuICAgKiAgIHBhbm5lckF0dHIoaWQpIC0+IFJldHVybnMgdGhlIHNvdW5kIGlkJ3MgdmFsdWVzLlxuICAgKiAgIHBhbm5lckF0dHIobykgLT4gU2V0J3MgdGhlIHZhbHVlcyBvZiBhbGwgc291bmRzIGluIHRoaXMgSG93bCBncm91cC5cbiAgICogICBwYW5uZXJBdHRyKG8sIGlkKSAtPiBTZXQncyB0aGUgdmFsdWVzIG9mIHBhc3NlZCBzb3VuZCBpZC5cbiAgICpcbiAgICogICBBdHRyaWJ1dGVzOlxuICAgKiAgICAgY29uZUlubmVyQW5nbGUgLSAoMzYwIGJ5IGRlZmF1bHQpIEEgcGFyYW1ldGVyIGZvciBkaXJlY3Rpb25hbCBhdWRpbyBzb3VyY2VzLCB0aGlzIGlzIGFuIGFuZ2xlLCBpbiBkZWdyZWVzLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICBpbnNpZGUgb2Ygd2hpY2ggdGhlcmUgd2lsbCBiZSBubyB2b2x1bWUgcmVkdWN0aW9uLlxuICAgKiAgICAgY29uZU91dGVyQW5nbGUgLSAoMzYwIGJ5IGRlZmF1bHQpIEEgcGFyYW1ldGVyIGZvciBkaXJlY3Rpb25hbCBhdWRpbyBzb3VyY2VzLCB0aGlzIGlzIGFuIGFuZ2xlLCBpbiBkZWdyZWVzLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICBvdXRzaWRlIG9mIHdoaWNoIHRoZSB2b2x1bWUgd2lsbCBiZSByZWR1Y2VkIHRvIGEgY29uc3RhbnQgdmFsdWUgb2YgYGNvbmVPdXRlckdhaW5gLlxuICAgKiAgICAgY29uZU91dGVyR2FpbiAtICgwIGJ5IGRlZmF1bHQpIEEgcGFyYW1ldGVyIGZvciBkaXJlY3Rpb25hbCBhdWRpbyBzb3VyY2VzLCB0aGlzIGlzIHRoZSBnYWluIG91dHNpZGUgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgYGNvbmVPdXRlckFuZ2xlYC4gSXQgaXMgYSBsaW5lYXIgdmFsdWUgaW4gdGhlIHJhbmdlIGBbMCwgMV1gLlxuICAgKiAgICAgZGlzdGFuY2VNb2RlbCAtICgnaW52ZXJzZScgYnkgZGVmYXVsdCkgRGV0ZXJtaW5lcyBhbGdvcml0aG0gdXNlZCB0byByZWR1Y2Ugdm9sdW1lIGFzIGF1ZGlvIG1vdmVzIGF3YXkgZnJvbVxuICAgKiAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLiBDYW4gYmUgYGxpbmVhcmAsIGBpbnZlcnNlYCBvciBgZXhwb25lbnRpYWwuXG4gICAqICAgICBtYXhEaXN0YW5jZSAtICgxMDAwMCBieSBkZWZhdWx0KSBUaGUgbWF4aW11bSBkaXN0YW5jZSBiZXR3ZWVuIHNvdXJjZSBhbmQgbGlzdGVuZXIsIGFmdGVyIHdoaWNoIHRoZSB2b2x1bWVcbiAgICogICAgICAgICAgICAgICAgICAgd2lsbCBub3QgYmUgcmVkdWNlZCBhbnkgZnVydGhlci5cbiAgICogICAgIHJlZkRpc3RhbmNlIC0gKDEgYnkgZGVmYXVsdCkgQSByZWZlcmVuY2UgZGlzdGFuY2UgZm9yIHJlZHVjaW5nIHZvbHVtZSBhcyBzb3VyY2UgbW92ZXMgZnVydGhlciBmcm9tIHRoZSBsaXN0ZW5lci5cbiAgICogICAgICAgICAgICAgICAgICAgVGhpcyBpcyBzaW1wbHkgYSB2YXJpYWJsZSBvZiB0aGUgZGlzdGFuY2UgbW9kZWwgYW5kIGhhcyBhIGRpZmZlcmVudCBlZmZlY3QgZGVwZW5kaW5nIG9uIHdoaWNoIG1vZGVsXG4gICAqICAgICAgICAgICAgICAgICAgIGlzIHVzZWQgYW5kIHRoZSBzY2FsZSBvZiB5b3VyIGNvb3JkaW5hdGVzLiBHZW5lcmFsbHksIHZvbHVtZSB3aWxsIGJlIGVxdWFsIHRvIDEgYXQgdGhpcyBkaXN0YW5jZS5cbiAgICogICAgIHJvbGxvZmZGYWN0b3IgLSAoMSBieSBkZWZhdWx0KSBIb3cgcXVpY2tseSB0aGUgdm9sdW1lIHJlZHVjZXMgYXMgc291cmNlIG1vdmVzIGZyb20gbGlzdGVuZXIuIFRoaXMgaXMgc2ltcGx5IGFcbiAgICogICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZSBvZiB0aGUgZGlzdGFuY2UgbW9kZWwgYW5kIGNhbiBiZSBpbiB0aGUgcmFuZ2Ugb2YgYFswLCAxXWAgd2l0aCBgbGluZWFyYCBhbmQgYFswLCDiiJ5dYFxuICAgKiAgICAgICAgICAgICAgICAgICAgIHdpdGggYGludmVyc2VgIGFuZCBgZXhwb25lbnRpYWxgLlxuICAgKiAgICAgcGFubmluZ01vZGVsIC0gKCdIUlRGJyBieSBkZWZhdWx0KSBEZXRlcm1pbmVzIHdoaWNoIHNwYXRpYWxpemF0aW9uIGFsZ29yaXRobSBpcyB1c2VkIHRvIHBvc2l0aW9uIGF1ZGlvLlxuICAgKiAgICAgICAgICAgICAgICAgICAgIENhbiBiZSBgSFJURmAgb3IgYGVxdWFscG93ZXJgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtIb3dsL09iamVjdH0gUmV0dXJucyBzZWxmIG9yIGN1cnJlbnQgcGFubmVyIGF0dHJpYnV0ZXMuXG4gICAqL1xuICBIb3dsLnByb3RvdHlwZS5wYW5uZXJBdHRyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBvLCBpZCwgc291bmQ7XG5cbiAgICAvLyBTdG9wIHJpZ2h0IGhlcmUgaWYgbm90IHVzaW5nIFdlYiBBdWRpby5cbiAgICBpZiAoIXNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIHZhbHVlcyBiYXNlZCBvbiBhcmd1bWVudHMuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBSZXR1cm4gdGhlIGdyb3VwJ3MgcGFubmVyIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gICAgICByZXR1cm4gc2VsZi5fcGFubmVyQXR0cjtcbiAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG8gPSBhcmdzWzBdO1xuXG4gICAgICAgIC8vIFNldCB0aGUgZ3JvdSdzIHBhbm5lciBhdHRyaWJ1dGUgdmFsdWVzLlxuICAgICAgICBpZiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGlmICghby5wYW5uZXJBdHRyKSB7XG4gICAgICAgICAgICBvLnBhbm5lckF0dHIgPSB7XG4gICAgICAgICAgICAgIGNvbmVJbm5lckFuZ2xlOiBvLmNvbmVJbm5lckFuZ2xlLFxuICAgICAgICAgICAgICBjb25lT3V0ZXJBbmdsZTogby5jb25lT3V0ZXJBbmdsZSxcbiAgICAgICAgICAgICAgY29uZU91dGVyR2Fpbjogby5jb25lT3V0ZXJHYWluLFxuICAgICAgICAgICAgICBkaXN0YW5jZU1vZGVsOiBvLmRpc3RhbmNlTW9kZWwsXG4gICAgICAgICAgICAgIG1heERpc3RhbmNlOiBvLm1heERpc3RhbmNlLFxuICAgICAgICAgICAgICByZWZEaXN0YW5jZTogby5yZWZEaXN0YW5jZSxcbiAgICAgICAgICAgICAgcm9sbG9mZkZhY3Rvcjogby5yb2xsb2ZmRmFjdG9yLFxuICAgICAgICAgICAgICBwYW5uaW5nTW9kZWw6IG8ucGFubmluZ01vZGVsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuX3Bhbm5lckF0dHIgPSB7XG4gICAgICAgICAgICBjb25lSW5uZXJBbmdsZTogdHlwZW9mIG8ucGFubmVyQXR0ci5jb25lSW5uZXJBbmdsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLnBhbm5lckF0dHIuY29uZUlubmVyQW5nbGUgOiBzZWxmLl9jb25lSW5uZXJBbmdsZSxcbiAgICAgICAgICAgIGNvbmVPdXRlckFuZ2xlOiB0eXBlb2Ygby5wYW5uZXJBdHRyLmNvbmVPdXRlckFuZ2xlICE9PSAndW5kZWZpbmVkJyA/IG8ucGFubmVyQXR0ci5jb25lT3V0ZXJBbmdsZSA6IHNlbGYuX2NvbmVPdXRlckFuZ2xlLFxuICAgICAgICAgICAgY29uZU91dGVyR2FpbjogdHlwZW9mIG8ucGFubmVyQXR0ci5jb25lT3V0ZXJHYWluICE9PSAndW5kZWZpbmVkJyA/IG8ucGFubmVyQXR0ci5jb25lT3V0ZXJHYWluIDogc2VsZi5fY29uZU91dGVyR2FpbixcbiAgICAgICAgICAgIGRpc3RhbmNlTW9kZWw6IHR5cGVvZiBvLnBhbm5lckF0dHIuZGlzdGFuY2VNb2RlbCAhPT0gJ3VuZGVmaW5lZCcgPyBvLnBhbm5lckF0dHIuZGlzdGFuY2VNb2RlbCA6IHNlbGYuX2Rpc3RhbmNlTW9kZWwsXG4gICAgICAgICAgICBtYXhEaXN0YW5jZTogdHlwZW9mIG8ucGFubmVyQXR0ci5tYXhEaXN0YW5jZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLnBhbm5lckF0dHIubWF4RGlzdGFuY2UgOiBzZWxmLl9tYXhEaXN0YW5jZSxcbiAgICAgICAgICAgIHJlZkRpc3RhbmNlOiB0eXBlb2Ygby5wYW5uZXJBdHRyLnJlZkRpc3RhbmNlICE9PSAndW5kZWZpbmVkJyA/IG8ucGFubmVyQXR0ci5yZWZEaXN0YW5jZSA6IHNlbGYuX3JlZkRpc3RhbmNlLFxuICAgICAgICAgICAgcm9sbG9mZkZhY3RvcjogdHlwZW9mIG8ucGFubmVyQXR0ci5yb2xsb2ZmRmFjdG9yICE9PSAndW5kZWZpbmVkJyA/IG8ucGFubmVyQXR0ci5yb2xsb2ZmRmFjdG9yIDogc2VsZi5fcm9sbG9mZkZhY3RvcixcbiAgICAgICAgICAgIHBhbm5pbmdNb2RlbDogdHlwZW9mIG8ucGFubmVyQXR0ci5wYW5uaW5nTW9kZWwgIT09ICd1bmRlZmluZWQnID8gby5wYW5uZXJBdHRyLnBhbm5pbmdNb2RlbCA6IHNlbGYuX3Bhbm5pbmdNb2RlbFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldHVybiB0aGlzIHNvdW5kJ3MgcGFubmVyIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gICAgICAgIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKHBhcnNlSW50KGFyZ3NbMF0sIDEwKSk7XG4gICAgICAgIHJldHVybiBzb3VuZCA/IHNvdW5kLl9wYW5uZXJBdHRyIDogc2VsZi5fcGFubmVyQXR0cjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICBvID0gYXJnc1swXTtcbiAgICAgIGlkID0gcGFyc2VJbnQoYXJnc1sxXSwgMTApO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgdmFsdWVzIG9mIHRoZSBzcGVjaWZpZWQgc291bmRzLlxuICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcyhpZCk7XG4gICAgZm9yICh2YXIgaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRzW2ldKTtcblxuICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgIC8vIE1lcmdlIHRoZSBuZXcgdmFsdWVzIGludG8gdGhlIHNvdW5kLlxuICAgICAgICB2YXIgcGEgPSBzb3VuZC5fcGFubmVyQXR0cjtcbiAgICAgICAgcGEgPSB7XG4gICAgICAgICAgY29uZUlubmVyQW5nbGU6IHR5cGVvZiBvLmNvbmVJbm5lckFuZ2xlICE9PSAndW5kZWZpbmVkJyA/IG8uY29uZUlubmVyQW5nbGUgOiBwYS5jb25lSW5uZXJBbmdsZSxcbiAgICAgICAgICBjb25lT3V0ZXJBbmdsZTogdHlwZW9mIG8uY29uZU91dGVyQW5nbGUgIT09ICd1bmRlZmluZWQnID8gby5jb25lT3V0ZXJBbmdsZSA6IHBhLmNvbmVPdXRlckFuZ2xlLFxuICAgICAgICAgIGNvbmVPdXRlckdhaW46IHR5cGVvZiBvLmNvbmVPdXRlckdhaW4gIT09ICd1bmRlZmluZWQnID8gby5jb25lT3V0ZXJHYWluIDogcGEuY29uZU91dGVyR2FpbixcbiAgICAgICAgICBkaXN0YW5jZU1vZGVsOiB0eXBlb2Ygby5kaXN0YW5jZU1vZGVsICE9PSAndW5kZWZpbmVkJyA/IG8uZGlzdGFuY2VNb2RlbCA6IHBhLmRpc3RhbmNlTW9kZWwsXG4gICAgICAgICAgbWF4RGlzdGFuY2U6IHR5cGVvZiBvLm1heERpc3RhbmNlICE9PSAndW5kZWZpbmVkJyA/IG8ubWF4RGlzdGFuY2UgOiBwYS5tYXhEaXN0YW5jZSxcbiAgICAgICAgICByZWZEaXN0YW5jZTogdHlwZW9mIG8ucmVmRGlzdGFuY2UgIT09ICd1bmRlZmluZWQnID8gby5yZWZEaXN0YW5jZSA6IHBhLnJlZkRpc3RhbmNlLFxuICAgICAgICAgIHJvbGxvZmZGYWN0b3I6IHR5cGVvZiBvLnJvbGxvZmZGYWN0b3IgIT09ICd1bmRlZmluZWQnID8gby5yb2xsb2ZmRmFjdG9yIDogcGEucm9sbG9mZkZhY3RvcixcbiAgICAgICAgICBwYW5uaW5nTW9kZWw6IHR5cGVvZiBvLnBhbm5pbmdNb2RlbCAhPT0gJ3VuZGVmaW5lZCcgPyBvLnBhbm5pbmdNb2RlbCA6IHBhLnBhbm5pbmdNb2RlbFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBwYW5uZXIgbm9kZSBpZiBvbmUgZG9lc24ndCBhbHJlYWR5IGV4aXN0LlxuICAgICAgICB2YXIgcGFubmVyID0gc291bmQuX3Bhbm5lcjtcbiAgICAgICAgaWYgKCFwYW5uZXIpIHtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIHBvc2l0aW9uIHRvIHNldHVwIHRoZSBub2RlIHdpdGguXG4gICAgICAgICAgaWYgKCFzb3VuZC5fcG9zKSB7XG4gICAgICAgICAgICBzb3VuZC5fcG9zID0gc2VsZi5fcG9zIHx8IFswLCAwLCAtMC41XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgcGFubmVyIG5vZGUuXG4gICAgICAgICAgc2V0dXBQYW5uZXIoc291bmQsICdzcGF0aWFsJyk7XG4gICAgICAgICAgcGFubmVyID0gc291bmQuX3Bhbm5lclxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBwYW5uZXIgdmFsdWVzIG9yIGNyZWF0ZSBhIG5ldyBwYW5uZXIgaWYgbm9uZSBleGlzdHMuXG4gICAgICAgIHBhbm5lci5jb25lSW5uZXJBbmdsZSA9IHBhLmNvbmVJbm5lckFuZ2xlO1xuICAgICAgICBwYW5uZXIuY29uZU91dGVyQW5nbGUgPSBwYS5jb25lT3V0ZXJBbmdsZTtcbiAgICAgICAgcGFubmVyLmNvbmVPdXRlckdhaW4gPSBwYS5jb25lT3V0ZXJHYWluO1xuICAgICAgICBwYW5uZXIuZGlzdGFuY2VNb2RlbCA9IHBhLmRpc3RhbmNlTW9kZWw7XG4gICAgICAgIHBhbm5lci5tYXhEaXN0YW5jZSA9IHBhLm1heERpc3RhbmNlO1xuICAgICAgICBwYW5uZXIucmVmRGlzdGFuY2UgPSBwYS5yZWZEaXN0YW5jZTtcbiAgICAgICAgcGFubmVyLnJvbGxvZmZGYWN0b3IgPSBwYS5yb2xsb2ZmRmFjdG9yO1xuICAgICAgICBwYW5uZXIucGFubmluZ01vZGVsID0gcGEucGFubmluZ01vZGVsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8qKiBTaW5nbGUgU291bmQgTWV0aG9kcyAqKi9cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKipcbiAgICogQWRkIG5ldyBwcm9wZXJ0aWVzIHRvIHRoZSBjb3JlIFNvdW5kIGluaXQuXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBfc3VwZXIgQ29yZSBTb3VuZCBpbml0IG1ldGhvZC5cbiAgICogQHJldHVybiB7U291bmR9XG4gICAqL1xuICBTb3VuZC5wcm90b3R5cGUuaW5pdCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgcGFyZW50ID0gc2VsZi5fcGFyZW50O1xuXG4gICAgICAvLyBTZXR1cCB1c2VyLWRlZmluZWQgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICAgICAgc2VsZi5fb3JpZW50YXRpb24gPSBwYXJlbnQuX29yaWVudGF0aW9uO1xuICAgICAgc2VsZi5fc3RlcmVvID0gcGFyZW50Ll9zdGVyZW87XG4gICAgICBzZWxmLl9wb3MgPSBwYXJlbnQuX3BvcztcbiAgICAgIHNlbGYuX3Bhbm5lckF0dHIgPSBwYXJlbnQuX3Bhbm5lckF0dHI7XG5cbiAgICAgIC8vIENvbXBsZXRlIGluaXRpbGl6YXRpb24gd2l0aCBob3dsZXIuanMgY29yZSBTb3VuZCdzIGluaXQgZnVuY3Rpb24uXG4gICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcblxuICAgICAgLy8gSWYgYSBzdGVyZW8gb3IgcG9zaXRpb24gd2FzIHNwZWNpZmllZCwgc2V0IGl0IHVwLlxuICAgICAgaWYgKHNlbGYuX3N0ZXJlbykge1xuICAgICAgICBwYXJlbnQuc3RlcmVvKHNlbGYuX3N0ZXJlbyk7XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuX3Bvcykge1xuICAgICAgICBwYXJlbnQucG9zKHNlbGYuX3Bvc1swXSwgc2VsZi5fcG9zWzFdLCBzZWxmLl9wb3NbMl0sIHNlbGYuX2lkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KShTb3VuZC5wcm90b3R5cGUuaW5pdCk7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSBTb3VuZC5yZXNldCBtZXRob2QgdG8gY2xlYW4gdXAgcHJvcGVydGllcyBmcm9tIHRoZSBzcGF0aWFsIHBsdWdpbi5cbiAgICogQHBhcmFtICB7RnVuY3Rpb259IF9zdXBlciBTb3VuZCByZXNldCBtZXRob2QuXG4gICAqIEByZXR1cm4ge1NvdW5kfVxuICAgKi9cbiAgU291bmQucHJvdG90eXBlLnJlc2V0ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBwYXJlbnQgPSBzZWxmLl9wYXJlbnQ7XG5cbiAgICAgIC8vIFJlc2V0IGFsbCBzcGF0aWFsIHBsdWdpbiBwcm9wZXJ0aWVzIG9uIHRoaXMgc291bmQuXG4gICAgICBzZWxmLl9vcmllbnRhdGlvbiA9IHBhcmVudC5fb3JpZW50YXRpb247XG4gICAgICBzZWxmLl9zdGVyZW8gPSBwYXJlbnQuX3N0ZXJlbztcbiAgICAgIHNlbGYuX3BvcyA9IHBhcmVudC5fcG9zO1xuICAgICAgc2VsZi5fcGFubmVyQXR0ciA9IHBhcmVudC5fcGFubmVyQXR0cjtcblxuICAgICAgLy8gSWYgYSBzdGVyZW8gb3IgcG9zaXRpb24gd2FzIHNwZWNpZmllZCwgc2V0IGl0IHVwLlxuICAgICAgaWYgKHNlbGYuX3N0ZXJlbykge1xuICAgICAgICBwYXJlbnQuc3RlcmVvKHNlbGYuX3N0ZXJlbyk7XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuX3Bvcykge1xuICAgICAgICBwYXJlbnQucG9zKHNlbGYuX3Bvc1swXSwgc2VsZi5fcG9zWzFdLCBzZWxmLl9wb3NbMl0sIHNlbGYuX2lkKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZi5fcGFubmVyKSB7XG4gICAgICAgIC8vIERpc2Nvbm5lY3QgdGhlIHBhbm5lci5cbiAgICAgICAgc2VsZi5fcGFubmVyLmRpc2Nvbm5lY3QoMCk7XG4gICAgICAgIHNlbGYuX3Bhbm5lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyZW50Ll9yZWZyZXNoQnVmZmVyKHNlbGYpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb21wbGV0ZSByZXNldHRpbmcgb2YgdGhlIHNvdW5kLlxuICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIH07XG4gIH0pKFNvdW5kLnByb3RvdHlwZS5yZXNldCk7XG5cbiAgLyoqIEhlbHBlciBNZXRob2RzICoqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcGFubmVyIG5vZGUgYW5kIHNhdmUgaXQgb24gdGhlIHNvdW5kLlxuICAgKiBAcGFyYW0gIHtTb3VuZH0gc291bmQgU3BlY2lmaWMgc291bmQgdG8gc2V0dXAgcGFubmluZyBvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSBvZiBwYW5uZXIgdG8gY3JlYXRlOiAnc3RlcmVvJyBvciAnc3BhdGlhbCcuXG4gICAqL1xuICB2YXIgc2V0dXBQYW5uZXIgPSBmdW5jdGlvbihzb3VuZCwgdHlwZSkge1xuICAgIHR5cGUgPSB0eXBlIHx8ICdzcGF0aWFsJztcblxuICAgIC8vIENyZWF0ZSB0aGUgbmV3IHBhbm5lciBub2RlLlxuICAgIGlmICh0eXBlID09PSAnc3BhdGlhbCcpIHtcbiAgICAgIHNvdW5kLl9wYW5uZXIgPSBIb3dsZXIuY3R4LmNyZWF0ZVBhbm5lcigpO1xuICAgICAgc291bmQuX3Bhbm5lci5jb25lSW5uZXJBbmdsZSA9IHNvdW5kLl9wYW5uZXJBdHRyLmNvbmVJbm5lckFuZ2xlO1xuICAgICAgc291bmQuX3Bhbm5lci5jb25lT3V0ZXJBbmdsZSA9IHNvdW5kLl9wYW5uZXJBdHRyLmNvbmVPdXRlckFuZ2xlO1xuICAgICAgc291bmQuX3Bhbm5lci5jb25lT3V0ZXJHYWluID0gc291bmQuX3Bhbm5lckF0dHIuY29uZU91dGVyR2FpbjtcbiAgICAgIHNvdW5kLl9wYW5uZXIuZGlzdGFuY2VNb2RlbCA9IHNvdW5kLl9wYW5uZXJBdHRyLmRpc3RhbmNlTW9kZWw7XG4gICAgICBzb3VuZC5fcGFubmVyLm1heERpc3RhbmNlID0gc291bmQuX3Bhbm5lckF0dHIubWF4RGlzdGFuY2U7XG4gICAgICBzb3VuZC5fcGFubmVyLnJlZkRpc3RhbmNlID0gc291bmQuX3Bhbm5lckF0dHIucmVmRGlzdGFuY2U7XG4gICAgICBzb3VuZC5fcGFubmVyLnJvbGxvZmZGYWN0b3IgPSBzb3VuZC5fcGFubmVyQXR0ci5yb2xsb2ZmRmFjdG9yO1xuICAgICAgc291bmQuX3Bhbm5lci5wYW5uaW5nTW9kZWwgPSBzb3VuZC5fcGFubmVyQXR0ci5wYW5uaW5nTW9kZWw7XG5cbiAgICAgIGlmICh0eXBlb2Ygc291bmQuX3Bhbm5lci5wb3NpdGlvblggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNvdW5kLl9wYW5uZXIucG9zaXRpb25YLnNldFZhbHVlQXRUaW1lKHNvdW5kLl9wb3NbMF0sIEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgICAgICBzb3VuZC5fcGFubmVyLnBvc2l0aW9uWS5zZXRWYWx1ZUF0VGltZShzb3VuZC5fcG9zWzFdLCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgc291bmQuX3Bhbm5lci5wb3NpdGlvblouc2V0VmFsdWVBdFRpbWUoc291bmQuX3Bvc1syXSwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VuZC5fcGFubmVyLnNldFBvc2l0aW9uKHNvdW5kLl9wb3NbMF0sIHNvdW5kLl9wb3NbMV0sIHNvdW5kLl9wb3NbMl0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHNvdW5kLl9wYW5uZXIub3JpZW50YXRpb25YICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzb3VuZC5fcGFubmVyLm9yaWVudGF0aW9uWC5zZXRWYWx1ZUF0VGltZShzb3VuZC5fb3JpZW50YXRpb25bMF0sIEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgICAgICBzb3VuZC5fcGFubmVyLm9yaWVudGF0aW9uWS5zZXRWYWx1ZUF0VGltZShzb3VuZC5fb3JpZW50YXRpb25bMV0sIEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgICAgICBzb3VuZC5fcGFubmVyLm9yaWVudGF0aW9uWi5zZXRWYWx1ZUF0VGltZShzb3VuZC5fb3JpZW50YXRpb25bMl0sIEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291bmQuX3Bhbm5lci5zZXRPcmllbnRhdGlvbihzb3VuZC5fb3JpZW50YXRpb25bMF0sIHNvdW5kLl9vcmllbnRhdGlvblsxXSwgc291bmQuX29yaWVudGF0aW9uWzJdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc291bmQuX3Bhbm5lciA9IEhvd2xlci5jdHguY3JlYXRlU3RlcmVvUGFubmVyKCk7XG4gICAgICBzb3VuZC5fcGFubmVyLnBhbi5zZXRWYWx1ZUF0VGltZShzb3VuZC5fc3RlcmVvLCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICB9XG5cbiAgICBzb3VuZC5fcGFubmVyLmNvbm5lY3Qoc291bmQuX25vZGUpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBjb25uZWN0aW9ucy5cbiAgICBpZiAoIXNvdW5kLl9wYXVzZWQpIHtcbiAgICAgIHNvdW5kLl9wYXJlbnQucGF1c2Uoc291bmQuX2lkLCB0cnVlKS5wbGF5KHNvdW5kLl9pZCwgdHJ1ZSk7XG4gICAgfVxuICB9O1xufSkoKTtcbiJdLCJuYW1lcyI6WyJIb3dsZXJHbG9iYWwiLCJpbml0IiwicHJvdG90eXBlIiwic2VsZiIsIkhvd2xlciIsIl9jb3VudGVyIiwiX2h0bWw1QXVkaW9Qb29sIiwiaHRtbDVQb29sU2l6ZSIsIl9jb2RlY3MiLCJfaG93bHMiLCJfbXV0ZWQiLCJfdm9sdW1lIiwiX2NhblBsYXlFdmVudCIsIl9uYXZpZ2F0b3IiLCJ3aW5kb3ciLCJuYXZpZ2F0b3IiLCJtYXN0ZXJHYWluIiwibm9BdWRpbyIsInVzaW5nV2ViQXVkaW8iLCJhdXRvU3VzcGVuZCIsImN0eCIsImF1dG9VbmxvY2siLCJfc2V0dXAiLCJ2b2x1bWUiLCJ2b2wiLCJwYXJzZUZsb2F0Iiwic2V0dXBBdWRpb0NvbnRleHQiLCJnYWluIiwic2V0VmFsdWVBdFRpbWUiLCJjdXJyZW50VGltZSIsImkiLCJsZW5ndGgiLCJfd2ViQXVkaW8iLCJpZHMiLCJfZ2V0U291bmRJZHMiLCJqIiwic291bmQiLCJfc291bmRCeUlkIiwiX25vZGUiLCJtdXRlIiwibXV0ZWQiLCJzdG9wIiwidW5sb2FkIiwiY2xvc2UiLCJjb2RlY3MiLCJleHQiLCJyZXBsYWNlIiwic3RhdGUiLCJfYXV0b1N1c3BlbmQiLCJBdWRpbyIsInRlc3QiLCJvbmNhbnBsYXl0aHJvdWdoIiwiZSIsIl9zZXR1cENvZGVjcyIsImF1ZGlvVGVzdCIsImVyciIsImNhblBsYXlUeXBlIiwibXBlZ1Rlc3QiLCJ1YSIsInVzZXJBZ2VudCIsImNoZWNrT3BlcmEiLCJtYXRjaCIsImlzT2xkT3BlcmEiLCJwYXJzZUludCIsInNwbGl0IiwiY2hlY2tTYWZhcmkiLCJpbmRleE9mIiwic2FmYXJpVmVyc2lvbiIsImlzT2xkU2FmYXJpIiwibXAzIiwibXBlZyIsIm9wdXMiLCJvZ2ciLCJvZ2EiLCJ3YXYiLCJhYWMiLCJjYWYiLCJtNGEiLCJtNGIiLCJtcDQiLCJ3ZWJhIiwid2VibSIsImRvbGJ5IiwiZmxhYyIsIl91bmxvY2tBdWRpbyIsIl9hdWRpb1VubG9ja2VkIiwiX21vYmlsZVVubG9hZGVkIiwic2FtcGxlUmF0ZSIsIl9zY3JhdGNoQnVmZmVyIiwiY3JlYXRlQnVmZmVyIiwidW5sb2NrIiwiYXVkaW9Ob2RlIiwiX3VubG9ja2VkIiwiX3JlbGVhc2VIdG1sNUF1ZGlvIiwibG9hZCIsIl9hdXRvUmVzdW1lIiwic291cmNlIiwiY3JlYXRlQnVmZmVyU291cmNlIiwiYnVmZmVyIiwiY29ubmVjdCIsImRlc3RpbmF0aW9uIiwic3RhcnQiLCJub3RlT24iLCJyZXN1bWUiLCJvbmVuZGVkIiwiZGlzY29ubmVjdCIsImRvY3VtZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIl9lbWl0IiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9vYnRhaW5IdG1sNUF1ZGlvIiwicG9wIiwidGVzdFBsYXkiLCJwbGF5IiwiUHJvbWlzZSIsInRoZW4iLCJjYXRjaCIsImNvbnNvbGUiLCJ3YXJuIiwiYXVkaW8iLCJwdXNoIiwic3VzcGVuZCIsIl9zb3VuZHMiLCJfcGF1c2VkIiwiX3N1c3BlbmRUaW1lciIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJoYW5kbGVTdXNwZW5zaW9uIiwiX3Jlc3VtZUFmdGVyU3VzcGVuZCIsIkhvd2wiLCJvIiwic3JjIiwiZXJyb3IiLCJfYXV0b3BsYXkiLCJhdXRvcGxheSIsIl9mb3JtYXQiLCJmb3JtYXQiLCJfaHRtbDUiLCJodG1sNSIsIl9sb29wIiwibG9vcCIsIl9wb29sIiwicG9vbCIsIl9wcmVsb2FkIiwicHJlbG9hZCIsIl9yYXRlIiwicmF0ZSIsIl9zcHJpdGUiLCJzcHJpdGUiLCJfc3JjIiwidW5kZWZpbmVkIiwiX3hociIsIm1ldGhvZCIsInhociIsImhlYWRlcnMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJfZHVyYXRpb24iLCJfc3RhdGUiLCJfZW5kVGltZXJzIiwiX3F1ZXVlIiwiX3BsYXlMb2NrIiwiX29uZW5kIiwib25lbmQiLCJmbiIsIl9vbmZhZGUiLCJvbmZhZGUiLCJfb25sb2FkIiwib25sb2FkIiwiX29ubG9hZGVycm9yIiwib25sb2FkZXJyb3IiLCJfb25wbGF5ZXJyb3IiLCJvbnBsYXllcnJvciIsIl9vbnBhdXNlIiwib25wYXVzZSIsIl9vbnBsYXkiLCJvbnBsYXkiLCJfb25zdG9wIiwib25zdG9wIiwiX29ubXV0ZSIsIm9ubXV0ZSIsIl9vbnZvbHVtZSIsIm9udm9sdW1lIiwiX29ucmF0ZSIsIm9ucmF0ZSIsIl9vbnNlZWsiLCJvbnNlZWsiLCJfb251bmxvY2siLCJvbnVubG9jayIsIl9vbnJlc3VtZSIsImV2ZW50IiwiYWN0aW9uIiwidXJsIiwic3RyIiwiZXhlYyIsInRvTG93ZXJDYXNlIiwibG9jYXRpb24iLCJwcm90b2NvbCIsInNsaWNlIiwiU291bmQiLCJsb2FkQnVmZmVyIiwiaW50ZXJuYWwiLCJpZCIsIm51bSIsIl9lbmRlZCIsIl9pZCIsIl9pbmFjdGl2ZVNvdW5kIiwic291bmRJZCIsIl9sb2FkUXVldWUiLCJzZWVrIiwiTWF0aCIsIm1heCIsIl9zZWVrIiwiZHVyYXRpb24iLCJ0aW1lb3V0IiwiYWJzIiwic2V0UGFyYW1zIiwiX3N0YXJ0IiwiX3N0b3AiLCJub2RlIiwicGxheVdlYkF1ZGlvIiwiX3JlZnJlc2hCdWZmZXIiLCJfcGxheVN0YXJ0IiwiYnVmZmVyU291cmNlIiwibm90ZUdyYWluT24iLCJJbmZpbml0eSIsImJpbmQiLCJvbmNlIiwiX2NsZWFyVGltZXIiLCJwbGF5SHRtbDUiLCJwbGF5YmFja1JhdGUiLCJwYXVzZWQiLCJsb2FkZWROb1JlYWR5U3RhdGUiLCJlamVjdGEiLCJyZWFkeVN0YXRlIiwiaXNDb2Nvb25KUyIsImxpc3RlbmVyIiwicGF1c2UiLCJfcmF0ZVNlZWsiLCJfc3RvcEZhZGUiLCJub3RlT2ZmIiwiX2NsZWFuQnVmZmVyIiwiaXNOYU4iLCJhcmd1bWVudHMiLCJfY2xlYXJTb3VuZCIsIl9pbnRlcnZhbCIsImFyZ3MiLCJpbmRleCIsImFwcGx5IiwiZmFkZSIsImZyb20iLCJ0byIsImxlbiIsIm1pbiIsImVuZCIsImxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lIiwiX3N0YXJ0RmFkZUludGVydmFsIiwiaXNHcm91cCIsImRpZmYiLCJzdGVwcyIsInN0ZXBMZW4iLCJsYXN0VGljayIsIkRhdGUiLCJub3ciLCJfZmFkZVRvIiwic2V0SW50ZXJ2YWwiLCJ0aWNrIiwicm91bmQiLCJjbGVhckludGVydmFsIiwiY2FuY2VsU2NoZWR1bGVkVmFsdWVzIiwibG9vcFN0YXJ0IiwibG9vcEVuZCIsInBsYXlpbmciLCJzZWVrQW5kRW1pdCIsImVtaXRTZWVrIiwicmVhbFRpbWUiLCJyYXRlU2VlayIsInNvdW5kcyIsIl9lcnJvckZuIiwiX2xvYWRGbiIsIl9lbmRGbiIsInNwbGljZSIsInJlbUNhY2hlIiwiY2FjaGUiLCJvbiIsImV2ZW50cyIsIm9mZiIsImlzSWQiLCJrZXlzIiwiT2JqZWN0IiwiQXJyYXkiLCJpc0FycmF5IiwibXNnIiwiY2FsbCIsInRhc2siLCJzaGlmdCIsImVuZGVkIiwiX2RyYWluIiwicmVzZXQiLCJsaW1pdCIsImNudCIsIl9wYW5uZXIiLCJpc0lPUyIsInZlbmRvciIsImNoZWNrSUUiLCJob3dsIiwiX3BhcmVudCIsInBhcmVudCIsImNyZWF0ZSIsImNyZWF0ZUdhaW4iLCJjcmVhdGVHYWluTm9kZSIsIl9lcnJvckxpc3RlbmVyIiwiX2xvYWRMaXN0ZW5lciIsIl9lbmRMaXN0ZW5lciIsImNvZGUiLCJjZWlsIiwiX19kZWZhdWx0IiwibG9hZFNvdW5kIiwiZGF0YSIsImF0b2IiLCJkYXRhVmlldyIsIlVpbnQ4QXJyYXkiLCJjaGFyQ29kZUF0IiwiZGVjb2RlQXVkaW9EYXRhIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwicmVzcG9uc2VUeXBlIiwiZm9yRWFjaCIsImtleSIsInNldFJlcXVlc3RIZWFkZXIiLCJzdGF0dXMiLCJyZXNwb25zZSIsIm9uZXJyb3IiLCJzYWZlWGhyU2VuZCIsInNlbmQiLCJhcnJheWJ1ZmZlciIsInN1Y2Nlc3MiLCJBdWRpb0NvbnRleHQiLCJ3ZWJraXRBdWRpb0NvbnRleHQiLCJpT1MiLCJwbGF0Zm9ybSIsImFwcFZlcnNpb24iLCJ2ZXJzaW9uIiwic2FmYXJpIiwiZGVmaW5lIiwiYW1kIiwiZXhwb3J0cyIsImdsb2JhbCIsIl9wb3MiLCJfb3JpZW50YXRpb24iLCJzdGVyZW8iLCJwYW4iLCJwb3MiLCJ4IiwieSIsInoiLCJwb3NpdGlvblgiLCJzZXRUYXJnZXRBdFRpbWUiLCJwb3NpdGlvblkiLCJwb3NpdGlvbloiLCJzZXRQb3NpdGlvbiIsIm9yaWVudGF0aW9uIiwieFVwIiwieVVwIiwielVwIiwib3IiLCJmb3J3YXJkWCIsImZvcndhcmRZIiwiZm9yd2FyZFoiLCJ1cFgiLCJ1cFkiLCJ1cFoiLCJzZXRPcmllbnRhdGlvbiIsIl9zdXBlciIsIl9zdGVyZW8iLCJfcGFubmVyQXR0ciIsImNvbmVJbm5lckFuZ2xlIiwiY29uZU91dGVyQW5nbGUiLCJjb25lT3V0ZXJHYWluIiwiZGlzdGFuY2VNb2RlbCIsIm1heERpc3RhbmNlIiwicGFubmluZ01vZGVsIiwicmVmRGlzdGFuY2UiLCJyb2xsb2ZmRmFjdG9yIiwiX29uc3RlcmVvIiwib25zdGVyZW8iLCJfb25wb3MiLCJvbnBvcyIsIl9vbm9yaWVudGF0aW9uIiwib25vcmllbnRhdGlvbiIsInBhbm5lclR5cGUiLCJjcmVhdGVTdGVyZW9QYW5uZXIiLCJzZXR1cFBhbm5lciIsIm9yaWVudGF0aW9uWCIsIm9yaWVudGF0aW9uWSIsIm9yaWVudGF0aW9uWiIsInBhbm5lckF0dHIiLCJfY29uZUlubmVyQW5nbGUiLCJfY29uZU91dGVyQW5nbGUiLCJfY29uZU91dGVyR2FpbiIsIl9kaXN0YW5jZU1vZGVsIiwiX21heERpc3RhbmNlIiwiX3JlZkRpc3RhbmNlIiwiX3JvbGxvZmZGYWN0b3IiLCJfcGFubmluZ01vZGVsIiwicGEiLCJwYW5uZXIiLCJ0eXBlIiwiY3JlYXRlUGFubmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/howler/dist/howler.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBRTlDLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyx5QkFBeUJSLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUSxzQkFBc0JULE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJUywyQkFBMkJWLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVSxrQkFBa0JYLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSx1QkFBdUJiLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYSxtQkFBbUJkLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJYyx3QkFBd0JmLE9BQU9nQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhO1lBQ2xDLElBQUlBLGtCQUFrQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVO2dCQUMv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LE9BQU8sUUFBUTtvQkFDckMsSUFBSXVFLGdCQUFnQnZHLHlCQUF5QmI7b0JBQzdDLElBQUlzTSxPQUFPM0ssT0FBTzJLLElBQUksQ0FBQ3pKLE9BQU9pSyxNQUFNLENBQUMsU0FBVUMsQ0FBQzt3QkFDOUMsT0FBT0EsTUFBTTtvQkFDZjtvQkFDQSxJQUFJQyxnQkFBZ0JWLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxvQkFBb0JpTyxLQUFLVyxJQUFJLENBQUMsYUFBYSxXQUFXO29CQUU1RixJQUFJLENBQUNWLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxFQUFFO3dCQUN6RCxJQUFJRSxlQUFlWixLQUFLak8sTUFBTSxHQUFHLElBQUksTUFBTWlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7d0JBRTdFaFAsTUFBTSx1RUFBdUUsd0JBQXdCLDBCQUEwQixzRUFBc0Usd0JBQXdCLHFDQUFxQytPLGVBQWU1RixlQUFlOEYsY0FBYzlGO3dCQUU5U21GLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxHQUFHO29CQUN6RDtnQkFDRjtnQkFFQSxJQUFJaE4sU0FBU25ELHFCQUFxQjtvQkFDaEN1UCxzQkFBc0J6RjtnQkFDeEIsT0FBTztvQkFDTG1GLGtCQUFrQm5GO2dCQUNwQjtnQkFFQSxPQUFPQTtZQUNUO1FBQ0YsRUFBRSwrREFBK0Q7UUFFakUsSUFBSXdHLFNBQVNYO1FBRWJZLGdCQUFnQixHQUFHdlE7UUFDbkJ1USxjQUFjLEdBQUdEO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/ZmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInVuZGVmaW5lZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJhc3NpZ24iLCJPYmplY3QiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiaGFzT3duUHJvcGVydHkiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYkMSIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImRpZFdhcm5BYm91dEtleVNwcmVhZCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImpvaW4iLCJhZnRlckV4YW1wbGUiLCJqc3hERVYiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDhMQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/page.tsx":
/*!**************************!*\
  !*** ./src/app/page.tsx ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var howler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! howler */ \"(app-pages-browser)/./node_modules/howler/dist/howler.js\");\n/* harmony import */ var howler__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(howler__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nconst INTERVALS = [\n    0.1,\n    1,\n    2,\n    4,\n    8,\n    15\n];\nconst MAX_GUESSES = 6;\nfunction Home() {\n    _s();\n    const [isPlaying, setIsPlaying] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [currentSong, setCurrentSong] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [guess, setGuess] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [score, setScore] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [round, setRound] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [currentInterval, setCurrentInterval] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [songData, setSongData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [suggestions, setSuggestions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [showSuggestions, setShowSuggestions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const inputRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [guesses, setGuesses] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(Array(MAX_GUESSES).fill(\"\"));\n    const [statuses, setStatuses] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(Array(MAX_GUESSES).fill(\"\"));\n    const [showModal, setShowModal] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [lastResult, setLastResult] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const inputContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const startGame = async function() {\n        let attempt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;\n        const MAX_ATTEMPTS = 50;\n        const BATCH_SIZE = 5; // Number of songs to try in parallel\n        try {\n            // Fetch multiple songs in parallel\n            const songPromises = Array(BATCH_SIZE).fill(null).map(()=>fetch(\"/api/song\").then((res)=>res.json()));\n            const results = await Promise.allSettled(songPromises);\n            // Find the first successful song with a valid preview URL\n            const validSong = results.find((result)=>result.status === \"fulfilled\" && result.value.previewUrl);\n            if (!validSong || validSong.status !== \"fulfilled\") {\n                throw new Error(\"No valid songs found in batch\");\n            }\n            const data = validSong.value;\n            console.log(\"Loading song with preview URL:\", data.previewUrl);\n            // Create and test the sound in parallel with other operations\n            const sound = new howler__WEBPACK_IMPORTED_MODULE_2__.Howl({\n                src: [\n                    data.previewUrl\n                ],\n                html5: true,\n                onload: ()=>{\n                    console.log(\"Song loaded successfully\");\n                    setCurrentSong(sound);\n                    setSongData({\n                        title: data.title,\n                        artist: data.artist\n                    });\n                    setIsPlaying(true);\n                    setCurrentInterval(0);\n                    playCurrentInterval(sound);\n                },\n                onloaderror: (id, error)=>{\n                    console.error(\"Error loading song:\", error);\n                    if (attempt < MAX_ATTEMPTS) {\n                        startGame(attempt + 1);\n                    } else {\n                        alert(\"Failed to load a playable song after several attempts. Please try again.\");\n                    }\n                },\n                onplayerror: (id, error)=>{\n                    console.error(\"Error playing song:\", error);\n                    if (attempt < MAX_ATTEMPTS) {\n                        startGame(attempt + 1);\n                    } else {\n                        alert(\"Failed to play a song after several attempts. Please try again.\");\n                    }\n                }\n            });\n        } catch (error) {\n            console.error(\"Error starting game:\", error);\n            if (attempt >= 5) {\n                alert(\"Failed to start game after several attempts. Please try again.\");\n            } else {\n                startGame(attempt + 1);\n            }\n        }\n    };\n    const playCurrentInterval = (sound)=>{\n        sound.stop();\n        sound.seek(0);\n        sound.play();\n        // Stop after the current interval\n        setTimeout(()=>{\n            sound.stop();\n        }, INTERVALS[currentInterval] * 1000);\n    };\n    const replayCurrentInterval = ()=>{\n        if (!currentSong) return;\n        playCurrentInterval(currentSong);\n    };\n    const playNextInterval = ()=>{\n        if (!currentSong || currentInterval >= MAX_GUESSES - 1) return;\n        // Mark current guess as incorrect if not already correct or incorrect\n        setGuesses((prev)=>{\n            const updated = [\n                ...prev\n            ];\n            if (!updated[currentInterval]) updated[currentInterval] = \"\";\n            return updated;\n        });\n        setStatuses((prev)=>{\n            const updated = [\n                ...prev\n            ];\n            if (!updated[currentInterval]) updated[currentInterval] = \"incorrect\";\n            return updated;\n        });\n        setCurrentInterval((prev)=>prev + 1);\n        playCurrentInterval(currentSong);\n    };\n    // Click-away listener for suggestions\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        function handleClickOutside(event) {\n            if (inputContainerRef.current && !inputContainerRef.current.contains(event.target)) {\n                setShowSuggestions(false);\n            }\n        }\n        if (showSuggestions) {\n            document.addEventListener(\"mousedown\", handleClickOutside);\n        }\n        return ()=>{\n            document.removeEventListener(\"mousedown\", handleClickOutside);\n        };\n    }, [\n        showSuggestions\n    ]);\n    const handleSuggestionClick = (suggestion)=>{\n        setGuess(suggestion);\n        setShowSuggestions(false);\n        if (inputRef.current) {\n            inputRef.current.focus();\n        }\n    };\n    const handleGuess = async (e)=>{\n        e.preventDefault();\n        if (!currentSong || !songData) return;\n        try {\n            const response = await fetch(\"/api/check\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    guess,\n                    title: songData.title,\n                    artist: songData.artist\n                })\n            });\n            const data = await response.json();\n            const newGuesses = [\n                ...guesses\n            ];\n            const newStatuses = [\n                ...statuses\n            ];\n            newGuesses[currentInterval] = guess;\n            newStatuses[currentInterval] = data.correct ? \"correct\" : \"incorrect\";\n            setGuesses(newGuesses);\n            setStatuses(newStatuses);\n            if (data.correct) {\n                setLastResult({\n                    correct: data.correct,\n                    actualTitle: data.actualTitle,\n                    actualArtist: data.actualArtist\n                });\n                setShowModal(true);\n            } else if (currentInterval === MAX_GUESSES - 1) {\n                setLastResult({\n                    correct: false,\n                    actualTitle: data.actualTitle,\n                    actualArtist: data.actualArtist\n                });\n                setShowModal(true);\n            } else {\n                setGuess(\"\");\n                setTimeout(()=>playNextInterval(), 200); // slight delay for feedback\n            }\n        } catch (error) {\n            console.error(\"Error checking guess:\", error);\n        }\n    };\n    const handleNextSong = ()=>{\n        setScore(score + ((lastResult === null || lastResult === void 0 ? void 0 : lastResult.correct) ? 1 : 0));\n        setRound(round + 1);\n        setGuess(\"\");\n        if (currentSong) currentSong.stop();\n        setIsPlaying(false);\n        setCurrentInterval(0);\n        setSongData(null);\n        setSuggestions([]);\n        setGuesses(Array(MAX_GUESSES).fill(\"\"));\n        setStatuses(Array(MAX_GUESSES).fill(\"\"));\n        setShowModal(false);\n        setLastResult(null);\n    };\n    // Fetch live song suggestions from iTunes API with debounce and deduplication\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!guess) {\n            setSuggestions([]);\n            return;\n        }\n        const controller = new AbortController();\n        const debounceTimeout = setTimeout(async ()=>{\n            try {\n                const res = await fetch(\"https://itunes.apple.com/search?term=\".concat(encodeURIComponent(guess), \"&entity=song&limit=10\"), {\n                    signal: controller.signal\n                });\n                const data = await res.json();\n                if (data.results) {\n                    // Deduplicate by title + artist\n                    const seen = new Set();\n                    const uniqueSuggestions = [];\n                    for (const song of data.results){\n                        const key = \"\".concat(song.trackName.toLowerCase(), \" - \").concat(song.artistName.toLowerCase());\n                        if (!seen.has(key)) {\n                            seen.add(key);\n                            uniqueSuggestions.push(\"\".concat(song.trackName, \" - \").concat(song.artistName));\n                        }\n                        if (uniqueSuggestions.length >= 5) break;\n                    }\n                    setSuggestions(uniqueSuggestions);\n                } else {\n                    setSuggestions([]);\n                }\n            } catch (e) {\n                if (e.name !== \"AbortError\") setSuggestions([]);\n            }\n        }, 200); // 200ms debounce\n        return ()=>{\n            controller.abort();\n            clearTimeout(debounceTimeout);\n        };\n    }, [\n        guess\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        className: \"min-h-screen flex flex-col items-center justify-center bg-gradient-to-b from-background to-black p-4\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"w-full max-w-xl mx-auto\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                        className: \"text-5xl font-extrabold text-center mb-6 tracking-tight text-white drop-shadow-lg\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"text-primary\",\n                                children: \"Humm\"\n                            }, void 0, false, {\n                                fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                lineNumber: 249,\n                                columnNumber: 11\n                            }, this),\n                            \"ify\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                        lineNumber: 248,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"card mb-8 shadow-2xl rounded-2xl bg-surface/90 border border-gray-800\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-center mb-6\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"text-lg font-medium text-gray-300\",\n                                        children: [\n                                            \"Round \",\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"font-bold text-white\",\n                                                children: round\n                                            }, void 0, false, {\n                                                fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                                lineNumber: 253,\n                                                columnNumber: 68\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                        lineNumber: 253,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"text-lg font-medium text-gray-300\",\n                                        children: [\n                                            \"Score \",\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"font-bold text-white\",\n                                                children: score\n                                            }, void 0, false, {\n                                                fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                                lineNumber: 254,\n                                                columnNumber: 68\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                        lineNumber: 254,\n                                        columnNumber: 13\n                                    }, this),\n                                    isPlaying && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"text-lg font-semibold text-primary mt-2\",\n                                        children: [\n                                            \"Interval: \",\n                                            INTERVALS[currentInterval],\n                                            \"s\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                        lineNumber: 256,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                lineNumber: 252,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"mb-6 space-y-2\",\n                                children: Array.from({\n                                    length: MAX_GUESSES\n                                }).map((_, idx)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex items-center px-4 py-2 rounded-lg transition-all border \".concat(idx === currentInterval && isPlaying ? \"border-primary bg-primary/10 shadow-md\" : \"border-gray-700 bg-background/80\"),\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"w-16 text-sm font-bold \".concat(idx === currentInterval ? \"text-primary\" : \"text-gray-400\"),\n                                                children: [\n                                                    \"Stage \",\n                                                    idx + 1\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                                lineNumber: 272,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"w-20 text-xs text-gray-400 ml-2\",\n                                                children: [\n                                                    INTERVALS[idx],\n                                                    \"s\"\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                                lineNumber: 273,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"flex-1 ml-4 text-base \".concat(statuses[idx] === \"correct\" ? \"text-green-400\" : statuses[idx] === \"incorrect\" ? \"text-red-400\" : \"text-gray-200\"),\n                                                children: guesses[idx]\n                                            }, void 0, false, {\n                                                fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                                lineNumber: 274,\n                                                columnNumber: 17\n                                            }, this),\n                                            statuses[idx] === \"correct\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"ml-2 text-green-400 font-bold\",\n                                                children: \"✔\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                                lineNumber: 275,\n                                                columnNumber: 49\n                                            }, this),\n                                            statuses[idx] === \"incorrect\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"ml-2 text-red-400 font-bold\",\n                                                children: \"✖\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                                lineNumber: 276,\n                                                columnNumber: 51\n                                            }, this)\n                                        ]\n                                    }, idx, true, {\n                                        fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                        lineNumber: 264,\n                                        columnNumber: 15\n                                    }, this))\n                            }, void 0, false, {\n                                fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                lineNumber: 262,\n                                columnNumber: 11\n                            }, this),\n                            !isPlaying ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>startGame(),\n                                className: \"btn-primary w-full py-3 text-lg rounded-xl shadow-md hover:scale-[1.02] transition-transform\",\n                                children: \"Start New Round\"\n                            }, void 0, false, {\n                                fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                lineNumber: 282,\n                                columnNumber: 13\n                            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"space-y-4\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n                                    onSubmit: handleGuess,\n                                    className: \"space-y-4\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            ref: inputContainerRef,\n                                            className: \"relative flex items-center\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    className: \"absolute left-3 text-gray-500\",\n                                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                                        width: \"20\",\n                                                        height: \"20\",\n                                                        fill: \"none\",\n                                                        viewBox: \"0 0 24 24\",\n                                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                                            stroke: \"currentColor\",\n                                                            strokeWidth: \"2\",\n                                                            d: \"M11 19a8 8 0 100-16 8 8 0 000 16zm7-1l-4.35-4.35\",\n                                                            strokeLinecap: \"round\",\n                                                            strokeLinejoin: \"round\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                                            lineNumber: 293,\n                                                            columnNumber: 81\n                                                        }, this)\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                                        lineNumber: 293,\n                                                        columnNumber: 21\n                                                    }, this)\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                                    lineNumber: 292,\n                                                    columnNumber: 19\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                    ref: inputRef,\n                                                    type: \"text\",\n                                                    value: guess,\n                                                    onChange: (e)=>{\n                                                        setGuess(e.target.value);\n                                                        setShowSuggestions(true);\n                                                    },\n                                                    onFocus: ()=>setShowSuggestions(true),\n                                                    placeholder: \"Know it? Search for the title\",\n                                                    className: \"w-full pl-10 pr-4 py-3 rounded-xl bg-background border border-gray-700 text-lg text-white focus:border-primary focus:ring-2 focus:ring-primary/30 transition-all outline-none\",\n                                                    disabled: currentInterval >= MAX_GUESSES || statuses[currentInterval] === \"correct\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                                    lineNumber: 295,\n                                                    columnNumber: 19\n                                                }, this),\n                                                showSuggestions && suggestions.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: \"absolute left-0 right-0 top-full mt-2 z-20 bg-surface rounded-md shadow-lg border border-gray-700 overflow-y-auto max-h-60 w-full\",\n                                                    children: suggestions.map((suggestion, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                            type: \"button\",\n                                                            onClick: ()=>{\n                                                                handleSuggestionClick(suggestion);\n                                                                if (inputRef.current) inputRef.current.focus();\n                                                            },\n                                                            className: \"w-full text-left px-4 py-2 hover:bg-gray-700 focus:bg-gray-700 focus:outline-none text-base\",\n                                                            children: suggestion\n                                                        }, index, false, {\n                                                            fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                                            lineNumber: 311,\n                                                            columnNumber: 25\n                                                        }, this))\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                                    lineNumber: 309,\n                                                    columnNumber: 21\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                            lineNumber: 291,\n                                            columnNumber: 17\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"flex space-x-2\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    type: \"submit\",\n                                                    className: \"btn-primary flex-1 py-3 text-lg rounded-xl shadow hover:scale-[1.02] transition-transform\",\n                                                    disabled: statuses[currentInterval] === \"correct\",\n                                                    children: \"Submit\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                                    lineNumber: 327,\n                                                    columnNumber: 19\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    type: \"button\",\n                                                    onClick: replayCurrentInterval,\n                                                    className: \"btn-primary flex-1 py-3 text-lg rounded-xl shadow hover:scale-[1.02] transition-transform\",\n                                                    children: \"Replay\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                                    lineNumber: 330,\n                                                    columnNumber: 19\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    type: \"button\",\n                                                    onClick: playNextInterval,\n                                                    className: \"btn-primary flex-1 py-3 text-lg rounded-xl shadow hover:scale-[1.02] transition-transform\",\n                                                    disabled: currentInterval >= MAX_GUESSES - 1,\n                                                    children: \"Play Longer\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                                    lineNumber: 337,\n                                                    columnNumber: 19\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                            lineNumber: 326,\n                                            columnNumber: 17\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                    lineNumber: 290,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                lineNumber: 289,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                        lineNumber: 251,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                lineNumber: 247,\n                columnNumber: 7\n            }, this),\n            showModal && lastResult && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-60\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"bg-surface rounded-2xl shadow-2xl p-8 max-w-md w-full text-center border border-gray-700\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                            className: \"text-2xl font-bold mb-4 \".concat(lastResult.correct ? \"text-green-400\" : \"text-red-400\"),\n                            children: lastResult.correct ? \"Correct!\" : \"Out of Guesses!\"\n                        }, void 0, false, {\n                            fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                            lineNumber: 355,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-lg mb-2 text-gray-200\",\n                            children: \"The correct answer was:\"\n                        }, void 0, false, {\n                            fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                            lineNumber: 356,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-xl font-semibold text-primary mb-6\",\n                            children: [\n                                lastResult.actualTitle || (songData === null || songData === void 0 ? void 0 : songData.title) || \"-\",\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"text-gray-400\",\n                                    children: \" - \"\n                                }, void 0, false, {\n                                    fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                                    lineNumber: 359,\n                                    columnNumber: 15\n                                }, this),\n                                lastResult.actualArtist || (songData === null || songData === void 0 ? void 0 : songData.artist) || \"-\"\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                            lineNumber: 357,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            onClick: handleNextSong,\n                            className: \"btn-primary w-full py-3 text-lg rounded-xl shadow hover:scale-[1.02] transition-transform\",\n                            children: \"Next Song\"\n                        }, void 0, false, {\n                            fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                            lineNumber: 362,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                    lineNumber: 354,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n                lineNumber: 353,\n                columnNumber: 9\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/pravbala/Documents/Coding/Cursor-Songless/src/app/page.tsx\",\n        lineNumber: 246,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"ZxOA3d0hwjwt6xqf5FDi8clMigM=\");\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Ozs4REFDYiw4REFBQ1E7b0RBQU9nQixNQUFLO29EQUFTeEIsV0FBVTtvREFBNEY0QixVQUFVN0gsUUFBUSxDQUFDYixnQkFBZ0IsS0FBSzs4REFBVzs7Ozs7OzhEQUcvSyw4REFBQ3NIO29EQUNDZ0IsTUFBSztvREFDTGYsU0FBUzVEO29EQUNUbUQsV0FBVTs4REFDWDs7Ozs7OzhEQUdELDhEQUFDUTtvREFDQ2dCLE1BQUs7b0RBQ0xmLFNBQVMzRDtvREFDVGtELFdBQVU7b0RBQ1Y0QixVQUFVMUksbUJBQW1CWixjQUFjOzhEQUM1Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFVWjJCLGFBQWFFLDRCQUNaLDhEQUFDOEY7Z0JBQUlELFdBQVU7MEJBQ2IsNEVBQUNDO29CQUFJRCxXQUFVOztzQ0FDYiw4REFBQzhCOzRCQUFHOUIsV0FBVywyQkFBa0YsT0FBdkQ3RixXQUFXb0UsT0FBTyxHQUFHLG1CQUFtQjtzQ0FBbUJwRSxXQUFXb0UsT0FBTyxHQUFHLGFBQWE7Ozs7OztzQ0FDdkksOERBQUM2Qjs0QkFBRUosV0FBVTtzQ0FBNkI7Ozs7OztzQ0FDMUMsOERBQUNJOzRCQUFFSixXQUFVOztnQ0FDVDdGLFdBQVdxRSxXQUFXLEtBQUlwRixxQkFBQUEsK0JBQUFBLFNBQVU2QyxLQUFLLEtBQUk7OENBQy9DLDhEQUFDa0U7b0NBQUtILFdBQVU7OENBQWdCOzs7Ozs7Z0NBQzlCN0YsV0FBV3NFLFlBQVksS0FBSXJGLHFCQUFBQSwrQkFBQUEsU0FBVThDLE1BQU0sS0FBSTs7Ozs7OztzQ0FFbkQsOERBQUNzRTs0QkFDQ0MsU0FBUy9COzRCQUNUc0IsV0FBVTtzQ0FDWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFRYjtHQTNXd0J6SDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL3BhZ2UudHN4P2Y2OGEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBIb3dsIH0gZnJvbSAnaG93bGVyJztcbmltcG9ydCBjb25mZXR0aSBmcm9tICdjYW52YXMtY29uZmV0dGknO1xuXG5jb25zdCBJTlRFUlZBTFMgPSBbMC4xLCAxLCAyLCA0LCA4LCAxNV07XG5jb25zdCBNQVhfR1VFU1NFUyA9IDY7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUoKSB7XG4gIGNvbnN0IFtpc1BsYXlpbmcsIHNldElzUGxheWluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjdXJyZW50U29uZywgc2V0Q3VycmVudFNvbmddID0gdXNlU3RhdGU8SG93bCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbZ3Vlc3MsIHNldEd1ZXNzXSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW3Njb3JlLCBzZXRTY29yZV0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW3JvdW5kLCBzZXRSb3VuZF0gPSB1c2VTdGF0ZSgxKTtcbiAgY29uc3QgW2N1cnJlbnRJbnRlcnZhbCwgc2V0Q3VycmVudEludGVydmFsXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbc29uZ0RhdGEsIHNldFNvbmdEYXRhXSA9IHVzZVN0YXRlPHsgdGl0bGU6IHN0cmluZzsgYXJ0aXN0OiBzdHJpbmcgfSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbc3VnZ2VzdGlvbnMsIHNldFN1Z2dlc3Rpb25zXSA9IHVzZVN0YXRlPHN0cmluZ1tdPihbXSk7XG4gIGNvbnN0IFtzaG93U3VnZ2VzdGlvbnMsIHNldFNob3dTdWdnZXN0aW9uc10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IGlucHV0UmVmID0gdXNlUmVmPEhUTUxJbnB1dEVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBbZ3Vlc3Nlcywgc2V0R3Vlc3Nlc10gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oQXJyYXkoTUFYX0dVRVNTRVMpLmZpbGwoJycpKTtcbiAgY29uc3QgW3N0YXR1c2VzLCBzZXRTdGF0dXNlc10gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oQXJyYXkoTUFYX0dVRVNTRVMpLmZpbGwoJycpKTtcbiAgY29uc3QgW3Nob3dNb2RhbCwgc2V0U2hvd01vZGFsXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2xhc3RSZXN1bHQsIHNldExhc3RSZXN1bHRdID0gdXNlU3RhdGU8eyBjb3JyZWN0OiBib29sZWFuOyBhY3R1YWxUaXRsZTogc3RyaW5nOyBhY3R1YWxBcnRpc3Q6IHN0cmluZyB9IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGlucHV0Q29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcblxuICBjb25zdCBzdGFydEdhbWUgPSBhc3luYyAoYXR0ZW1wdCA9IDEpID0+IHtcbiAgICBjb25zdCBNQVhfQVRURU1QVFMgPSA1MDtcbiAgICBjb25zdCBCQVRDSF9TSVpFID0gNTsgLy8gTnVtYmVyIG9mIHNvbmdzIHRvIHRyeSBpbiBwYXJhbGxlbFxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEZldGNoIG11bHRpcGxlIHNvbmdzIGluIHBhcmFsbGVsXG4gICAgICBjb25zdCBzb25nUHJvbWlzZXMgPSBBcnJheShCQVRDSF9TSVpFKS5maWxsKG51bGwpLm1hcCgoKSA9PiBcbiAgICAgICAgZmV0Y2goJy9hcGkvc29uZycpLnRoZW4ocmVzID0+IHJlcy5qc29uKCkpXG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHNvbmdQcm9taXNlcyk7XG4gICAgICBcbiAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IHN1Y2Nlc3NmdWwgc29uZyB3aXRoIGEgdmFsaWQgcHJldmlldyBVUkxcbiAgICAgIGNvbnN0IHZhbGlkU29uZyA9IHJlc3VsdHMuZmluZChyZXN1bHQgPT4gXG4gICAgICAgIHJlc3VsdC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnICYmIFxuICAgICAgICByZXN1bHQudmFsdWUucHJldmlld1VybFxuICAgICAgKTtcblxuICAgICAgaWYgKCF2YWxpZFNvbmcgfHwgdmFsaWRTb25nLnN0YXR1cyAhPT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCBzb25ncyBmb3VuZCBpbiBiYXRjaCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gdmFsaWRTb25nLnZhbHVlO1xuICAgICAgY29uc29sZS5sb2coJ0xvYWRpbmcgc29uZyB3aXRoIHByZXZpZXcgVVJMOicsIGRhdGEucHJldmlld1VybCk7XG5cbiAgICAgIC8vIENyZWF0ZSBhbmQgdGVzdCB0aGUgc291bmQgaW4gcGFyYWxsZWwgd2l0aCBvdGhlciBvcGVyYXRpb25zXG4gICAgICBjb25zdCBzb3VuZCA9IG5ldyBIb3dsKHtcbiAgICAgICAgc3JjOiBbZGF0YS5wcmV2aWV3VXJsXSxcbiAgICAgICAgaHRtbDU6IHRydWUsXG4gICAgICAgIG9ubG9hZDogKCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdTb25nIGxvYWRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgICAgICBzZXRDdXJyZW50U29uZyhzb3VuZCk7XG4gICAgICAgICAgc2V0U29uZ0RhdGEoeyB0aXRsZTogZGF0YS50aXRsZSwgYXJ0aXN0OiBkYXRhLmFydGlzdCB9KTtcbiAgICAgICAgICBzZXRJc1BsYXlpbmcodHJ1ZSk7XG4gICAgICAgICAgc2V0Q3VycmVudEludGVydmFsKDApO1xuICAgICAgICAgIHBsYXlDdXJyZW50SW50ZXJ2YWwoc291bmQpO1xuICAgICAgICB9LFxuICAgICAgICBvbmxvYWRlcnJvcjogKGlkLCBlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgc29uZzonLCBlcnJvcik7XG4gICAgICAgICAgaWYgKGF0dGVtcHQgPCBNQVhfQVRURU1QVFMpIHtcbiAgICAgICAgICAgIHN0YXJ0R2FtZShhdHRlbXB0ICsgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsZXJ0KCdGYWlsZWQgdG8gbG9hZCBhIHBsYXlhYmxlIHNvbmcgYWZ0ZXIgc2V2ZXJhbCBhdHRlbXB0cy4gUGxlYXNlIHRyeSBhZ2Fpbi4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9ucGxheWVycm9yOiAoaWQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGxheWluZyBzb25nOicsIGVycm9yKTtcbiAgICAgICAgICBpZiAoYXR0ZW1wdCA8IE1BWF9BVFRFTVBUUykge1xuICAgICAgICAgICAgc3RhcnRHYW1lKGF0dGVtcHQgKyAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxlcnQoJ0ZhaWxlZCB0byBwbGF5IGEgc29uZyBhZnRlciBzZXZlcmFsIGF0dGVtcHRzLiBQbGVhc2UgdHJ5IGFnYWluLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHN0YXJ0aW5nIGdhbWU6JywgZXJyb3IpO1xuICAgICAgaWYgKGF0dGVtcHQgPj0gNSkge1xuICAgICAgICBhbGVydCgnRmFpbGVkIHRvIHN0YXJ0IGdhbWUgYWZ0ZXIgc2V2ZXJhbCBhdHRlbXB0cy4gUGxlYXNlIHRyeSBhZ2Fpbi4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0R2FtZShhdHRlbXB0ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHBsYXlDdXJyZW50SW50ZXJ2YWwgPSAoc291bmQ6IEhvd2wpID0+IHtcbiAgICBzb3VuZC5zdG9wKCk7XG4gICAgc291bmQuc2VlaygwKTtcbiAgICBzb3VuZC5wbGF5KCk7XG4gICAgXG4gICAgLy8gU3RvcCBhZnRlciB0aGUgY3VycmVudCBpbnRlcnZhbFxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc291bmQuc3RvcCgpO1xuICAgIH0sIElOVEVSVkFMU1tjdXJyZW50SW50ZXJ2YWxdICogMTAwMCk7XG4gIH07XG5cbiAgY29uc3QgcmVwbGF5Q3VycmVudEludGVydmFsID0gKCkgPT4ge1xuICAgIGlmICghY3VycmVudFNvbmcpIHJldHVybjtcbiAgICBwbGF5Q3VycmVudEludGVydmFsKGN1cnJlbnRTb25nKTtcbiAgfTtcblxuICBjb25zdCBwbGF5TmV4dEludGVydmFsID0gKCkgPT4ge1xuICAgIGlmICghY3VycmVudFNvbmcgfHwgY3VycmVudEludGVydmFsID49IE1BWF9HVUVTU0VTIC0gMSkgcmV0dXJuO1xuICAgIC8vIE1hcmsgY3VycmVudCBndWVzcyBhcyBpbmNvcnJlY3QgaWYgbm90IGFscmVhZHkgY29ycmVjdCBvciBpbmNvcnJlY3RcbiAgICBzZXRHdWVzc2VzKHByZXYgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZCA9IFsuLi5wcmV2XTtcbiAgICAgIGlmICghdXBkYXRlZFtjdXJyZW50SW50ZXJ2YWxdKSB1cGRhdGVkW2N1cnJlbnRJbnRlcnZhbF0gPSAnJztcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0pO1xuICAgIHNldFN0YXR1c2VzKHByZXYgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZCA9IFsuLi5wcmV2XTtcbiAgICAgIGlmICghdXBkYXRlZFtjdXJyZW50SW50ZXJ2YWxdKSB1cGRhdGVkW2N1cnJlbnRJbnRlcnZhbF0gPSAnaW5jb3JyZWN0JztcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0pO1xuICAgIHNldEN1cnJlbnRJbnRlcnZhbChwcmV2ID0+IHByZXYgKyAxKTtcbiAgICBwbGF5Q3VycmVudEludGVydmFsKGN1cnJlbnRTb25nKTtcbiAgfTtcblxuICAvLyBDbGljay1hd2F5IGxpc3RlbmVyIGZvciBzdWdnZXN0aW9uc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrT3V0c2lkZShldmVudDogTW91c2VFdmVudCkge1xuICAgICAgaWYgKFxuICAgICAgICBpbnB1dENvbnRhaW5lclJlZi5jdXJyZW50ICYmXG4gICAgICAgICFpbnB1dENvbnRhaW5lclJlZi5jdXJyZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCBhcyBOb2RlKVxuICAgICAgKSB7XG4gICAgICAgIHNldFNob3dTdWdnZXN0aW9ucyhmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaG93U3VnZ2VzdGlvbnMpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZUNsaWNrT3V0c2lkZSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVDbGlja091dHNpZGUpO1xuICAgIH07XG4gIH0sIFtzaG93U3VnZ2VzdGlvbnNdKTtcblxuICBjb25zdCBoYW5kbGVTdWdnZXN0aW9uQ2xpY2sgPSAoc3VnZ2VzdGlvbjogc3RyaW5nKSA9PiB7XG4gICAgc2V0R3Vlc3Moc3VnZ2VzdGlvbik7XG4gICAgc2V0U2hvd1N1Z2dlc3Rpb25zKGZhbHNlKTtcbiAgICBpZiAoaW5wdXRSZWYuY3VycmVudCkge1xuICAgICAgaW5wdXRSZWYuY3VycmVudC5mb2N1cygpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBoYW5kbGVHdWVzcyA9IGFzeW5jIChlOiBSZWFjdC5Gb3JtRXZlbnQpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCFjdXJyZW50U29uZyB8fCAhc29uZ0RhdGEpIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9jaGVjaycsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZ3Vlc3MsXG4gICAgICAgICAgdGl0bGU6IHNvbmdEYXRhLnRpdGxlLFxuICAgICAgICAgIGFydGlzdDogc29uZ0RhdGEuYXJ0aXN0LFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnN0IG5ld0d1ZXNzZXMgPSBbLi4uZ3Vlc3Nlc107XG4gICAgICBjb25zdCBuZXdTdGF0dXNlcyA9IFsuLi5zdGF0dXNlc107XG4gICAgICBuZXdHdWVzc2VzW2N1cnJlbnRJbnRlcnZhbF0gPSBndWVzcztcbiAgICAgIG5ld1N0YXR1c2VzW2N1cnJlbnRJbnRlcnZhbF0gPSBkYXRhLmNvcnJlY3QgPyAnY29ycmVjdCcgOiAnaW5jb3JyZWN0JztcbiAgICAgIHNldEd1ZXNzZXMobmV3R3Vlc3Nlcyk7XG4gICAgICBzZXRTdGF0dXNlcyhuZXdTdGF0dXNlcyk7XG4gICAgICBpZiAoZGF0YS5jb3JyZWN0KSB7XG4gICAgICAgIHNldExhc3RSZXN1bHQoe1xuICAgICAgICAgIGNvcnJlY3Q6IGRhdGEuY29ycmVjdCxcbiAgICAgICAgICBhY3R1YWxUaXRsZTogZGF0YS5hY3R1YWxUaXRsZSxcbiAgICAgICAgICBhY3R1YWxBcnRpc3Q6IGRhdGEuYWN0dWFsQXJ0aXN0LFxuICAgICAgICB9KTtcbiAgICAgICAgc2V0U2hvd01vZGFsKHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50SW50ZXJ2YWwgPT09IE1BWF9HVUVTU0VTIC0gMSkge1xuICAgICAgICBzZXRMYXN0UmVzdWx0KHtcbiAgICAgICAgICBjb3JyZWN0OiBmYWxzZSxcbiAgICAgICAgICBhY3R1YWxUaXRsZTogZGF0YS5hY3R1YWxUaXRsZSxcbiAgICAgICAgICBhY3R1YWxBcnRpc3Q6IGRhdGEuYWN0dWFsQXJ0aXN0LFxuICAgICAgICB9KTtcbiAgICAgICAgc2V0U2hvd01vZGFsKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0R3Vlc3MoJycpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHBsYXlOZXh0SW50ZXJ2YWwoKSwgMjAwKTsgLy8gc2xpZ2h0IGRlbGF5IGZvciBmZWVkYmFja1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBndWVzczonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZU5leHRTb25nID0gKCkgPT4ge1xuICAgIHNldFNjb3JlKHNjb3JlICsgKGxhc3RSZXN1bHQ/LmNvcnJlY3QgPyAxIDogMCkpO1xuICAgIHNldFJvdW5kKHJvdW5kICsgMSk7XG4gICAgc2V0R3Vlc3MoJycpO1xuICAgIGlmIChjdXJyZW50U29uZykgY3VycmVudFNvbmcuc3RvcCgpO1xuICAgIHNldElzUGxheWluZyhmYWxzZSk7XG4gICAgc2V0Q3VycmVudEludGVydmFsKDApO1xuICAgIHNldFNvbmdEYXRhKG51bGwpO1xuICAgIHNldFN1Z2dlc3Rpb25zKFtdKTtcbiAgICBzZXRHdWVzc2VzKEFycmF5KE1BWF9HVUVTU0VTKS5maWxsKCcnKSk7XG4gICAgc2V0U3RhdHVzZXMoQXJyYXkoTUFYX0dVRVNTRVMpLmZpbGwoJycpKTtcbiAgICBzZXRTaG93TW9kYWwoZmFsc2UpO1xuICAgIHNldExhc3RSZXN1bHQobnVsbCk7XG4gIH07XG5cbiAgLy8gRmV0Y2ggbGl2ZSBzb25nIHN1Z2dlc3Rpb25zIGZyb20gaVR1bmVzIEFQSSB3aXRoIGRlYm91bmNlIGFuZCBkZWR1cGxpY2F0aW9uXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFndWVzcykge1xuICAgICAgc2V0U3VnZ2VzdGlvbnMoW10pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IGRlYm91bmNlVGltZW91dCA9IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vaXR1bmVzLmFwcGxlLmNvbS9zZWFyY2g/dGVybT0ke2VuY29kZVVSSUNvbXBvbmVudChndWVzcyl9JmVudGl0eT1zb25nJmxpbWl0PTEwYCwgeyBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsIH0pO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgaWYgKGRhdGEucmVzdWx0cykge1xuICAgICAgICAgIC8vIERlZHVwbGljYXRlIGJ5IHRpdGxlICsgYXJ0aXN0XG4gICAgICAgICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBjb25zdCB1bmlxdWVTdWdnZXN0aW9ucyA9IFtdO1xuICAgICAgICAgIGZvciAoY29uc3Qgc29uZyBvZiBkYXRhLnJlc3VsdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke3NvbmcudHJhY2tOYW1lLnRvTG93ZXJDYXNlKCl9IC0gJHtzb25nLmFydGlzdE5hbWUudG9Mb3dlckNhc2UoKX1gO1xuICAgICAgICAgICAgaWYgKCFzZWVuLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgIHNlZW4uYWRkKGtleSk7XG4gICAgICAgICAgICAgIHVuaXF1ZVN1Z2dlc3Rpb25zLnB1c2goYCR7c29uZy50cmFja05hbWV9IC0gJHtzb25nLmFydGlzdE5hbWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5pcXVlU3VnZ2VzdGlvbnMubGVuZ3RoID49IDUpIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRTdWdnZXN0aW9ucyh1bmlxdWVTdWdnZXN0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0U3VnZ2VzdGlvbnMoW10pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLm5hbWUgIT09ICdBYm9ydEVycm9yJykgc2V0U3VnZ2VzdGlvbnMoW10pO1xuICAgICAgfVxuICAgIH0sIDIwMCk7IC8vIDIwMG1zIGRlYm91bmNlXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIGNsZWFyVGltZW91dChkZWJvdW5jZVRpbWVvdXQpO1xuICAgIH07XG4gIH0sIFtndWVzc10pO1xuXG4gIHJldHVybiAoXG4gICAgPG1haW4gY2xhc3NOYW1lPVwibWluLWgtc2NyZWVuIGZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGJnLWdyYWRpZW50LXRvLWIgZnJvbS1iYWNrZ3JvdW5kIHRvLWJsYWNrIHAtNFwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWF4LXcteGwgbXgtYXV0b1wiPlxuICAgICAgICA8aDEgY2xhc3NOYW1lPVwidGV4dC01eGwgZm9udC1leHRyYWJvbGQgdGV4dC1jZW50ZXIgbWItNiB0cmFja2luZy10aWdodCB0ZXh0LXdoaXRlIGRyb3Atc2hhZG93LWxnXCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1wcmltYXJ5XCI+SHVtbTwvc3Bhbj5pZnlcbiAgICAgICAgPC9oMT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkIG1iLTggc2hhZG93LTJ4bCByb3VuZGVkLTJ4bCBiZy1zdXJmYWNlLzkwIGJvcmRlciBib3JkZXItZ3JheS04MDBcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtY2VudGVyIG1iLTZcIj5cbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1tZWRpdW0gdGV4dC1ncmF5LTMwMFwiPlJvdW5kIDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtYm9sZCB0ZXh0LXdoaXRlXCI+e3JvdW5kfTwvc3Bhbj48L3A+XG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtbWVkaXVtIHRleHQtZ3JheS0zMDBcIj5TY29yZSA8c3BhbiBjbGFzc05hbWU9XCJmb250LWJvbGQgdGV4dC13aGl0ZVwiPntzY29yZX08L3NwYW4+PC9wPlxuICAgICAgICAgICAge2lzUGxheWluZyAmJiAoXG4gICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1zZW1pYm9sZCB0ZXh0LXByaW1hcnkgbXQtMlwiPlxuICAgICAgICAgICAgICAgIEludGVydmFsOiB7SU5URVJWQUxTW2N1cnJlbnRJbnRlcnZhbF19c1xuICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIHsvKiBHdWVzcyBTdGFnZXMgKi99XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi02IHNwYWNlLXktMlwiPlxuICAgICAgICAgICAge0FycmF5LmZyb20oeyBsZW5ndGg6IE1BWF9HVUVTU0VTIH0pLm1hcCgoXywgaWR4KSA9PiAoXG4gICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBrZXk9e2lkeH1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2BmbGV4IGl0ZW1zLWNlbnRlciBweC00IHB5LTIgcm91bmRlZC1sZyB0cmFuc2l0aW9uLWFsbCBib3JkZXIgJHtcbiAgICAgICAgICAgICAgICAgIGlkeCA9PT0gY3VycmVudEludGVydmFsICYmIGlzUGxheWluZ1xuICAgICAgICAgICAgICAgICAgICA/ICdib3JkZXItcHJpbWFyeSBiZy1wcmltYXJ5LzEwIHNoYWRvdy1tZCdcbiAgICAgICAgICAgICAgICAgICAgOiAnYm9yZGVyLWdyYXktNzAwIGJnLWJhY2tncm91bmQvODAnXG4gICAgICAgICAgICAgICAgfWB9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2B3LTE2IHRleHQtc20gZm9udC1ib2xkICR7aWR4ID09PSBjdXJyZW50SW50ZXJ2YWwgPyAndGV4dC1wcmltYXJ5JyA6ICd0ZXh0LWdyYXktNDAwJ31gfT5TdGFnZSB7aWR4ICsgMX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidy0yMCB0ZXh0LXhzIHRleHQtZ3JheS00MDAgbWwtMlwiPntJTlRFUlZBTFNbaWR4XX1zPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17YGZsZXgtMSBtbC00IHRleHQtYmFzZSAke3N0YXR1c2VzW2lkeF0gPT09ICdjb3JyZWN0JyA/ICd0ZXh0LWdyZWVuLTQwMCcgOiBzdGF0dXNlc1tpZHhdID09PSAnaW5jb3JyZWN0JyA/ICd0ZXh0LXJlZC00MDAnIDogJ3RleHQtZ3JheS0yMDAnfWB9PntndWVzc2VzW2lkeF19PC9zcGFuPlxuICAgICAgICAgICAgICAgIHtzdGF0dXNlc1tpZHhdID09PSAnY29ycmVjdCcgJiYgPHNwYW4gY2xhc3NOYW1lPVwibWwtMiB0ZXh0LWdyZWVuLTQwMCBmb250LWJvbGRcIj7inJQ8L3NwYW4+fVxuICAgICAgICAgICAgICAgIHtzdGF0dXNlc1tpZHhdID09PSAnaW5jb3JyZWN0JyAmJiA8c3BhbiBjbGFzc05hbWU9XCJtbC0yIHRleHQtcmVkLTQwMCBmb250LWJvbGRcIj7inJY8L3NwYW4+fVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICkpfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIHsvKiBJbnB1dCBhbmQgQ29udHJvbHMgKi99XG4gICAgICAgICAgeyFpc1BsYXlpbmcgPyAoXG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHN0YXJ0R2FtZSgpfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidG4tcHJpbWFyeSB3LWZ1bGwgcHktMyB0ZXh0LWxnIHJvdW5kZWQteGwgc2hhZG93LW1kIGhvdmVyOnNjYWxlLVsxLjAyXSB0cmFuc2l0aW9uLXRyYW5zZm9ybVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIFN0YXJ0IE5ldyBSb3VuZFxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgKSA6IChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS00XCI+XG4gICAgICAgICAgICAgIDxmb3JtIG9uU3VibWl0PXtoYW5kbGVHdWVzc30gY2xhc3NOYW1lPVwic3BhY2UteS00XCI+XG4gICAgICAgICAgICAgICAgPGRpdiByZWY9e2lucHV0Q29udGFpbmVyUmVmfSBjbGFzc05hbWU9XCJyZWxhdGl2ZSBmbGV4IGl0ZW1zLWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWJzb2x1dGUgbGVmdC0zIHRleHQtZ3JheS01MDBcIj5cbiAgICAgICAgICAgICAgICAgICAgPHN2ZyB3aWR0aD1cIjIwXCIgaGVpZ2h0PVwiMjBcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2VXaWR0aD1cIjJcIiBkPVwiTTExIDE5YTggOCAwIDEwMC0xNiA4IDggMCAwMDAgMTZ6bTctMWwtNC4zNS00LjM1XCIgc3Ryb2tlTGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiLz48L3N2Zz5cbiAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICByZWY9e2lucHV0UmVmfVxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXtndWVzc31cbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0R3Vlc3MoZS50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgIHNldFNob3dTdWdnZXN0aW9ucyh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgb25Gb2N1cz17KCkgPT4gc2V0U2hvd1N1Z2dlc3Rpb25zKHRydWUpfVxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIktub3cgaXQ/IFNlYXJjaCBmb3IgdGhlIHRpdGxlXCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsIHBsLTEwIHByLTQgcHktMyByb3VuZGVkLXhsIGJnLWJhY2tncm91bmQgYm9yZGVyIGJvcmRlci1ncmF5LTcwMCB0ZXh0LWxnIHRleHQtd2hpdGUgZm9jdXM6Ym9yZGVyLXByaW1hcnkgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctcHJpbWFyeS8zMCB0cmFuc2l0aW9uLWFsbCBvdXRsaW5lLW5vbmVcIlxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17Y3VycmVudEludGVydmFsID49IE1BWF9HVUVTU0VTIHx8IHN0YXR1c2VzW2N1cnJlbnRJbnRlcnZhbF0gPT09ICdjb3JyZWN0J31cbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICB7c2hvd1N1Z2dlc3Rpb25zICYmIHN1Z2dlc3Rpb25zLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIGxlZnQtMCByaWdodC0wIHRvcC1mdWxsIG10LTIgei0yMCBiZy1zdXJmYWNlIHJvdW5kZWQtbWQgc2hhZG93LWxnIGJvcmRlciBib3JkZXItZ3JheS03MDAgb3ZlcmZsb3cteS1hdXRvIG1heC1oLTYwIHctZnVsbFwiPlxuICAgICAgICAgICAgICAgICAgICAgIHtzdWdnZXN0aW9ucy5tYXAoKHN1Z2dlc3Rpb24sIGluZGV4KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17aW5kZXh9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlU3VnZ2VzdGlvbkNsaWNrKHN1Z2dlc3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFJlZi5jdXJyZW50KSBpbnB1dFJlZi5jdXJyZW50LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctZnVsbCB0ZXh0LWxlZnQgcHgtNCBweS0yIGhvdmVyOmJnLWdyYXktNzAwIGZvY3VzOmJnLWdyYXktNzAwIGZvY3VzOm91dGxpbmUtbm9uZSB0ZXh0LWJhc2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICB7c3VnZ2VzdGlvbn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IHNwYWNlLXgtMlwiPlxuICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwic3VibWl0XCIgY2xhc3NOYW1lPVwiYnRuLXByaW1hcnkgZmxleC0xIHB5LTMgdGV4dC1sZyByb3VuZGVkLXhsIHNoYWRvdyBob3ZlcjpzY2FsZS1bMS4wMl0gdHJhbnNpdGlvbi10cmFuc2Zvcm1cIiBkaXNhYmxlZD17c3RhdHVzZXNbY3VycmVudEludGVydmFsXSA9PT0gJ2NvcnJlY3QnfT5cbiAgICAgICAgICAgICAgICAgICAgU3VibWl0XG4gICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3JlcGxheUN1cnJlbnRJbnRlcnZhbH1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYnRuLXByaW1hcnkgZmxleC0xIHB5LTMgdGV4dC1sZyByb3VuZGVkLXhsIHNoYWRvdyBob3ZlcjpzY2FsZS1bMS4wMl0gdHJhbnNpdGlvbi10cmFuc2Zvcm1cIlxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICBSZXBsYXlcbiAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17cGxheU5leHRJbnRlcnZhbH1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYnRuLXByaW1hcnkgZmxleC0xIHB5LTMgdGV4dC1sZyByb3VuZGVkLXhsIHNoYWRvdyBob3ZlcjpzY2FsZS1bMS4wMl0gdHJhbnNpdGlvbi10cmFuc2Zvcm1cIlxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17Y3VycmVudEludGVydmFsID49IE1BWF9HVUVTU0VTIC0gMX1cbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgUGxheSBMb25nZXJcbiAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Zvcm0+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgey8qIE1vZGFsIGZvciBjb3JyZWN0IGFuc3dlciAqL31cbiAgICAgIHtzaG93TW9kYWwgJiYgbGFzdFJlc3VsdCAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZml4ZWQgaW5zZXQtMCB6LTUwIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGJnLWJsYWNrIGJnLW9wYWNpdHktNjBcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLXN1cmZhY2Ugcm91bmRlZC0yeGwgc2hhZG93LTJ4bCBwLTggbWF4LXctbWQgdy1mdWxsIHRleHQtY2VudGVyIGJvcmRlciBib3JkZXItZ3JheS03MDBcIj5cbiAgICAgICAgICAgIDxoMiBjbGFzc05hbWU9e2B0ZXh0LTJ4bCBmb250LWJvbGQgbWItNCAke2xhc3RSZXN1bHQuY29ycmVjdCA/ICd0ZXh0LWdyZWVuLTQwMCcgOiAndGV4dC1yZWQtNDAwJ31gfT57bGFzdFJlc3VsdC5jb3JyZWN0ID8gJ0NvcnJlY3QhJyA6ICdPdXQgb2YgR3Vlc3NlcyEnfTwvaDI+XG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWxnIG1iLTIgdGV4dC1ncmF5LTIwMFwiPlRoZSBjb3JyZWN0IGFuc3dlciB3YXM6PC9wPlxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC14bCBmb250LXNlbWlib2xkIHRleHQtcHJpbWFyeSBtYi02XCI+XG4gICAgICAgICAgICAgIHsobGFzdFJlc3VsdC5hY3R1YWxUaXRsZSB8fCBzb25nRGF0YT8udGl0bGUgfHwgJy0nKX1cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1ncmF5LTQwMFwiPiAtIDwvc3Bhbj5cbiAgICAgICAgICAgICAgeyhsYXN0UmVzdWx0LmFjdHVhbEFydGlzdCB8fCBzb25nRGF0YT8uYXJ0aXN0IHx8ICctJyl9XG4gICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZU5leHRTb25nfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidG4tcHJpbWFyeSB3LWZ1bGwgcHktMyB0ZXh0LWxnIHJvdW5kZWQteGwgc2hhZG93IGhvdmVyOnNjYWxlLVsxLjAyXSB0cmFuc2l0aW9uLXRyYW5zZm9ybVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIE5leHQgU29uZ1xuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8L21haW4+XG4gICk7XG59ICJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsIkhvd2wiLCJJTlRFUlZBTFMiLCJNQVhfR1VFU1NFUyIsIkhvbWUiLCJpc1BsYXlpbmciLCJzZXRJc1BsYXlpbmciLCJjdXJyZW50U29uZyIsInNldEN1cnJlbnRTb25nIiwiZ3Vlc3MiLCJzZXRHdWVzcyIsInNjb3JlIiwic2V0U2NvcmUiLCJyb3VuZCIsInNldFJvdW5kIiwiY3VycmVudEludGVydmFsIiwic2V0Q3VycmVudEludGVydmFsIiwic29uZ0RhdGEiLCJzZXRTb25nRGF0YSIsInN1Z2dlc3Rpb25zIiwic2V0U3VnZ2VzdGlvbnMiLCJzaG93U3VnZ2VzdGlvbnMiLCJzZXRTaG93U3VnZ2VzdGlvbnMiLCJpbnB1dFJlZiIsImd1ZXNzZXMiLCJzZXRHdWVzc2VzIiwiQXJyYXkiLCJmaWxsIiwic3RhdHVzZXMiLCJzZXRTdGF0dXNlcyIsInNob3dNb2RhbCIsInNldFNob3dNb2RhbCIsImxhc3RSZXN1bHQiLCJzZXRMYXN0UmVzdWx0IiwiaW5wdXRDb250YWluZXJSZWYiLCJzdGFydEdhbWUiLCJhdHRlbXB0IiwiTUFYX0FUVEVNUFRTIiwiQkFUQ0hfU0laRSIsInNvbmdQcm9taXNlcyIsIm1hcCIsImZldGNoIiwidGhlbiIsInJlcyIsImpzb24iLCJyZXN1bHRzIiwiUHJvbWlzZSIsImFsbFNldHRsZWQiLCJ2YWxpZFNvbmciLCJmaW5kIiwicmVzdWx0Iiwic3RhdHVzIiwidmFsdWUiLCJwcmV2aWV3VXJsIiwiRXJyb3IiLCJkYXRhIiwiY29uc29sZSIsImxvZyIsInNvdW5kIiwic3JjIiwiaHRtbDUiLCJvbmxvYWQiLCJ0aXRsZSIsImFydGlzdCIsInBsYXlDdXJyZW50SW50ZXJ2YWwiLCJvbmxvYWRlcnJvciIsImlkIiwiZXJyb3IiLCJhbGVydCIsIm9ucGxheWVycm9yIiwic3RvcCIsInNlZWsiLCJwbGF5Iiwic2V0VGltZW91dCIsInJlcGxheUN1cnJlbnRJbnRlcnZhbCIsInBsYXlOZXh0SW50ZXJ2YWwiLCJwcmV2IiwidXBkYXRlZCIsImhhbmRsZUNsaWNrT3V0c2lkZSIsImV2ZW50IiwiY3VycmVudCIsImNvbnRhaW5zIiwidGFyZ2V0IiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhbmRsZVN1Z2dlc3Rpb25DbGljayIsInN1Z2dlc3Rpb24iLCJmb2N1cyIsImhhbmRsZUd1ZXNzIiwiZSIsInByZXZlbnREZWZhdWx0IiwicmVzcG9uc2UiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJuZXdHdWVzc2VzIiwibmV3U3RhdHVzZXMiLCJjb3JyZWN0IiwiYWN0dWFsVGl0bGUiLCJhY3R1YWxBcnRpc3QiLCJoYW5kbGVOZXh0U29uZyIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJkZWJvdW5jZVRpbWVvdXQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJzaWduYWwiLCJzZWVuIiwiU2V0IiwidW5pcXVlU3VnZ2VzdGlvbnMiLCJzb25nIiwia2V5IiwidHJhY2tOYW1lIiwidG9Mb3dlckNhc2UiLCJhcnRpc3ROYW1lIiwiaGFzIiwiYWRkIiwicHVzaCIsImxlbmd0aCIsIm5hbWUiLCJhYm9ydCIsImNsZWFyVGltZW91dCIsIm1haW4iLCJjbGFzc05hbWUiLCJkaXYiLCJoMSIsInNwYW4iLCJwIiwiZnJvbSIsIl8iLCJpZHgiLCJidXR0b24iLCJvbkNsaWNrIiwiZm9ybSIsIm9uU3VibWl0IiwicmVmIiwic3ZnIiwid2lkdGgiLCJoZWlnaHQiLCJ2aWV3Qm94IiwicGF0aCIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwiZCIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VMaW5lam9pbiIsImlucHV0IiwidHlwZSIsIm9uQ2hhbmdlIiwib25Gb2N1cyIsInBsYWNlaG9sZGVyIiwiZGlzYWJsZWQiLCJpbmRleCIsImgyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/page.tsx\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fpravbala%2FDocuments%2FCoding%2FCursor-Songless%2Fsrc%2Fapp%2Fpage.tsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);